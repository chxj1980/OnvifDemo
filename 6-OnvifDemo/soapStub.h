/* soapStub.h
   Generated by gSOAP 2.8.28 from onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_WSDD_2005
#define SOAP_WSA_200408
#define SOAP_NAMESPACE_OF_wsdd	"http://schemas.xmlsoap.org/ws/2005/04/discovery"
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_tdn	"http://www.onvif.org/ver10/network/wsdl"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_trt	"http://www.onvif.org/ver10/media/wsdl"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (7)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault
{
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:98 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (9)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum
{
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (82)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType
{
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* wsa.h:119 */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (106)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues
{
	wsa__Reply = 0
};
#endif

/* wsa.h:127 */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (107)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues
{
	wsa__InvalidMessageInformationHeader = 0,
	wsa__MessageInformationHeaderRequired = 1,
	wsa__DestinationUnreachable = 2,
	wsa__ActionNotSupported = 3,
	wsa__EndpointUnavailable = 4
};
#endif

/* wsdd10.h:111 */
#ifndef SOAP_TYPE_wsdd__FaultCodeType
#define SOAP_TYPE_wsdd__FaultCodeType (151)
/* wsdd:FaultCodeType */
enum wsdd__FaultCodeType
{
	wsdd__MatchingRuleNotSupported = 0
};
#endif

/* wsa5.h:94 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (186)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType
{
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:102 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (187)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType
{
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:252 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (204)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter
{
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* onvif.h:2917 */
#ifndef SOAP_TYPE_tds__AutoGeoModes
#define SOAP_TYPE_tds__AutoGeoModes (1106)
/* tds:AutoGeoModes */
enum tds__AutoGeoModes
{
	tds__AutoGeoModes__Location = 0,
	tds__AutoGeoModes__Heading = 1,
	tds__AutoGeoModes__Leveling = 2
};
#endif

/* onvif.h:2936 */
#ifndef SOAP_TYPE_tds__StorageType
#define SOAP_TYPE_tds__StorageType (1107)
/* tds:StorageType */
enum tds__StorageType
{
	tds__StorageType__NFS = 0,
	tds__StorageType__CIFS = 1,
	tds__StorageType__CDMI = 2,
	tds__StorageType__FTP = 3
};
#endif

/* onvif.h:2975 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (1109)
/* tt:RotateMode */
enum tt__RotateMode
{
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* onvif.h:2994 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (1110)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode
{
	tt__SceneOrientationMode__MANUAL = 0,
	tt__SceneOrientationMode__AUTO = 1
};
#endif

/* onvif.h:3006 */
#ifndef SOAP_TYPE_tt__SceneOrientationOption
#define SOAP_TYPE_tt__SceneOrientationOption (1111)
/* tt:SceneOrientationOption */
enum tt__SceneOrientationOption
{
	tt__SceneOrientationOption__Below = 0,
	tt__SceneOrientationOption__Horizon = 1,
	tt__SceneOrientationOption__Above = 2
};
#endif

/* onvif.h:3019 */
#ifndef SOAP_TYPE_tt__ViewModes
#define SOAP_TYPE_tt__ViewModes (1112)
/* tt:ViewModes */
enum tt__ViewModes
{
	tt__ViewModes__tt_x003aFisheye = 0,
	tt__ViewModes__tt_x003a360Panorama = 1,
	tt__ViewModes__tt_x003a180Panorama = 2,
	tt__ViewModes__tt_x003aQuad = 3,
	tt__ViewModes__tt_x003aOriginal = 4,
	tt__ViewModes__tt_x003aLeftHalf = 5,
	tt__ViewModes__tt_x003aRightHalf = 6,
	tt__ViewModes__tt_x003aDewarp = 7
};
#endif

/* onvif.h:3058 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (1113)
/* tt:VideoEncoding */
enum tt__VideoEncoding
{
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* onvif.h:3068 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (1114)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile
{
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* onvif.h:3077 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (1115)
/* tt:H264Profile */
enum tt__H264Profile
{
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* onvif.h:3091 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (1116)
/* tt:VideoEncodingMimeNames */
enum tt__VideoEncodingMimeNames
{
	tt__VideoEncodingMimeNames__JPEG = 0,
	tt__VideoEncodingMimeNames__MPV4_ES = 1,
	tt__VideoEncodingMimeNames__H264 = 2,
	tt__VideoEncodingMimeNames__H265 = 3
};
#endif

/* onvif.h:3102 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (1117)
/* tt:VideoEncodingProfiles */
enum tt__VideoEncodingProfiles
{
	tt__VideoEncodingProfiles__Simple = 0,
	tt__VideoEncodingProfiles__AdvancedSimple = 1,
	tt__VideoEncodingProfiles__Baseline = 2,
	tt__VideoEncodingProfiles__Main = 3,
	tt__VideoEncodingProfiles__Main10 = 4,
	tt__VideoEncodingProfiles__Extended = 5,
	tt__VideoEncodingProfiles__High = 6
};
#endif

/* onvif.h:3116 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (1118)
/* tt:AudioEncoding */
enum tt__AudioEncoding
{
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* onvif.h:3129 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (1119)
/* tt:AudioEncodingMimeNames */
enum tt__AudioEncodingMimeNames
{
	tt__AudioEncodingMimeNames__PCMU = 0,
	tt__AudioEncodingMimeNames__G726 = 1,
	tt__AudioEncodingMimeNames__MP4A_LATM = 2
};
#endif

/* onvif.h:3139 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (1120)
/* tt:MetadataCompressionType */
enum tt__MetadataCompressionType
{
	tt__MetadataCompressionType__None = 0,
	tt__MetadataCompressionType__GZIP = 1,
	tt__MetadataCompressionType__EXI = 2
};
#endif

/* onvif.h:3149 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (1121)
/* tt:StreamType */
enum tt__StreamType
{
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* onvif.h:3158 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (1122)
/* tt:TransportProtocol */
enum tt__TransportProtocol
{
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* onvif.h:3172 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (1123)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition
{
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* onvif.h:3181 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (1124)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode
{
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* onvif.h:3195 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (1126)
/* tt:Duplex */
enum tt__Duplex
{
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* onvif.h:3211 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (1128)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration
{
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* onvif.h:3222 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (1129)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType
{
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* onvif.h:3232 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (1130)
/* tt:NetworkHostType */
enum tt__NetworkHostType
{
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* onvif.h:3254 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (1134)
/* tt:IPType */
enum tt__IPType
{
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* onvif.h:3271 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (1137)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType
{
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* onvif.h:3280 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (1138)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType
{
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* onvif.h:3295 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (1140)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode
{
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* onvif.h:3305 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (1141)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode
{
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* onvif.h:3317 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (1142)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher
{
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* onvif.h:3338 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (1145)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength
{
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* onvif.h:3351 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (1146)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite
{
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* onvif.h:3362 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (1147)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory
{
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* onvif.h:3379 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (1148)
/* tt:SystemLogType */
enum tt__SystemLogType
{
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* onvif.h:3397 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (1149)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType
{
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* onvif.h:3412 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (1150)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType
{
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* onvif.h:3427 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (1151)
/* tt:UserLevel */
enum tt__UserLevel
{
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* onvif.h:3439 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (1152)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState
{
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* onvif.h:3448 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (1153)
/* tt:RelayIdleState */
enum tt__RelayIdleState
{
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* onvif.h:3457 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (1154)
/* tt:RelayMode */
enum tt__RelayMode
{
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* onvif.h:3466 */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (1155)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState
{
	tt__DigitalIdleState__closed = 0,
	tt__DigitalIdleState__open = 1
};
#endif

/* onvif.h:3475 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (1156)
/* tt:EFlipMode */
enum tt__EFlipMode
{
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* onvif.h:3485 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (1157)
/* tt:ReverseMode */
enum tt__ReverseMode
{
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* onvif.h:3501 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (1159)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState
{
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* onvif.h:3512 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (1160)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection
{
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* onvif.h:3522 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (1161)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation
{
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* onvif.h:3533 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (1162)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode
{
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* onvif.h:3542 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (1163)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode
{
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* onvif.h:3554 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (1164)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode
{
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* onvif.h:3569 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (1165)
/* tt:ExposurePriority */
enum tt__ExposurePriority
{
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* onvif.h:3578 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (1166)
/* tt:ExposureMode */
enum tt__ExposureMode
{
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* onvif.h:3587 */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (1167)
/* tt:Enabled */
enum tt__Enabled
{
	tt__Enabled__ENABLED = 0,
	tt__Enabled__DISABLED = 1
};
#endif

/* onvif.h:3596 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (1168)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode
{
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* onvif.h:3605 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (1169)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode
{
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* onvif.h:3615 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (1170)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode
{
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* onvif.h:3626 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (1171)
/* tt:IrCutFilterAutoBoundaryType */
enum tt__IrCutFilterAutoBoundaryType
{
	tt__IrCutFilterAutoBoundaryType__Common = 0,
	tt__IrCutFilterAutoBoundaryType__ToOn = 1,
	tt__IrCutFilterAutoBoundaryType__ToOff = 2,
	tt__IrCutFilterAutoBoundaryType__Extended = 3
};
#endif

/* onvif.h:3637 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (1172)
/* tt:ToneCompensationMode */
enum tt__ToneCompensationMode
{
	tt__ToneCompensationMode__OFF = 0,
	tt__ToneCompensationMode__ON = 1,
	tt__ToneCompensationMode__AUTO = 2
};
#endif

/* onvif.h:3647 */
#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (1173)
/* tt:DefoggingMode */
enum tt__DefoggingMode
{
	tt__DefoggingMode__OFF = 0,
	tt__DefoggingMode__ON = 1,
	tt__DefoggingMode__AUTO = 2
};
#endif

/* onvif.h:3661 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (1175)
/* tt:PropertyOperation */
enum tt__PropertyOperation
{
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* onvif.h:3671 */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (1176)
/* tt:Direction */
enum tt__Direction
{
	tt__Direction__Left = 0,
	tt__Direction__Right = 1,
	tt__Direction__Any = 2
};
#endif

/* onvif.h:3684 */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (1177)
/* tt:ReceiverMode */
enum tt__ReceiverMode
{
	tt__ReceiverMode__AutoConnect = 0,
	tt__ReceiverMode__AlwaysConnect = 1,
	tt__ReceiverMode__NeverConnect = 2,
	tt__ReceiverMode__Unknown = 3
};
#endif

/* onvif.h:3710 */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (1178)
/* tt:ReceiverState */
enum tt__ReceiverState
{
	tt__ReceiverState__NotConnected = 0,
	tt__ReceiverState__Connecting = 1,
	tt__ReceiverState__Connected = 2,
	tt__ReceiverState__Unknown = 3
};
#endif

/* onvif.h:3741 */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (1181)
/* tt:SearchState */
enum tt__SearchState
{
	tt__SearchState__Queued = 0,
	tt__SearchState__Searching = 1,
	tt__SearchState__Completed = 2,
	tt__SearchState__Unknown = 3
};
#endif

/* onvif.h:3764 */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (1182)
/* tt:RecordingStatus */
enum tt__RecordingStatus
{
	tt__RecordingStatus__Initiated = 0,
	tt__RecordingStatus__Recording = 1,
	tt__RecordingStatus__Stopped = 2,
	tt__RecordingStatus__Removing = 3,
	tt__RecordingStatus__Removed = 4,
	tt__RecordingStatus__Unknown = 5
};
#endif

/* onvif.h:3780 */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (1183)
/* tt:TrackType */
enum tt__TrackType
{
	tt__TrackType__Video = 0,
	tt__TrackType__Audio = 1,
	tt__TrackType__Metadata = 2,
	tt__TrackType__Extended = 3
};
#endif

/* onvif.h:3802 */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (1186)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation
{
	tt__ModeOfOperation__Idle = 0,
	tt__ModeOfOperation__Active = 1,
	tt__ModeOfOperation__Unknown = 2
};
#endif

/* onvif.h:3823 */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (1188)
/* tt:OSDType */
enum tt__OSDType
{
	tt__OSDType__Text = 0,
	tt__OSDType__Image = 1,
	tt__OSDType__Extended = 2
};
#endif

/* onvif.h:3843 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1190)
/* tt:MoveStatus */
enum tt__MoveStatus
{
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/* onvif.h:3853 */
#ifndef SOAP_TYPE_tt__Entity
#define SOAP_TYPE_tt__Entity (1191)
/* tt:Entity */
enum tt__Entity
{
	tt__Entity__Device = 0,
	tt__Entity__VideoSource = 1,
	tt__Entity__AudioSource = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (221)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:76 */
struct _wsse__UsernameToken;	/* wsse.h:114 */
struct _wsse__BinarySecurityToken;	/* wsse.h:125 */
struct _wsse__Reference;	/* wsse.h:135 */
struct _wsse__Embedded;	/* wsse.h:143 */
struct _wsse__KeyIdentifier;	/* wsse.h:152 */
struct _wsse__SecurityTokenReference;	/* wsse.h:162 */
struct ds__SignatureType;	/* ds.h:47 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:74 */
struct ds__KeyInfoType;	/* ds.h:49 */
struct ds__SignedInfoType;	/* ds.h:47 */
struct ds__CanonicalizationMethodType;	/* ds.h:60 */
struct ds__SignatureMethodType;	/* ds.h:63 */
struct ds__ReferenceType;	/* ds.h:66 */
struct ds__TransformsType;	/* ds.h:69 */
struct ds__DigestMethodType;	/* ds.h:80 */
struct ds__KeyValueType;	/* ds.h:86 */
struct ds__RetrievalMethodType;	/* ds.h:87 */
struct ds__X509DataType;	/* wsse.h:165 */
struct ds__X509IssuerSerialType;	/* ds.h:103 */
struct ds__DSAKeyValueType;	/* ds.h:124 */
struct ds__RSAKeyValueType;	/* ds.h:127 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct _wsse__Security;	/* wsse.h:177 */
struct _wsse__Password;	/* wsse.h:115 */
struct wsa__EndpointReferenceType;	/* wsa.h:94 */
struct wsa__ReferencePropertiesType;	/* wsa.h:97 */
struct wsa__ReferenceParametersType;	/* wsa.h:100 */
struct wsa__ServiceNameType;	/* wsa.h:103 */
struct wsa__Relationship;	/* wsa.h:106 */
struct wsdd__HelloType;	/* wsdd10.h:57 */
struct wsdd__ByeType;	/* wsdd10.h:60 */
struct wsdd__ProbeType;	/* wsdd10.h:63 */
struct wsdd__ProbeMatchesType;	/* wsdd10.h:66 */
struct wsdd__ProbeMatchType;	/* wsdd10.h:69 */
struct wsdd__ResolveType;	/* wsdd10.h:72 */
struct wsdd__ResolveMatchesType;	/* wsdd10.h:75 */
struct wsdd__ResolveMatchType;	/* wsdd10.h:78 */
struct wsdd__SecurityType;	/* wsdd10.h:84 */
struct wsdd__SigType;	/* wsdd10.h:87 */
struct wsdd__ScopesType;	/* wsdd10.h:81 */
struct wsdd__AppSequenceType;	/* wsdd10.h:90 */
struct __wsdd__Hello;	/* wsdx.h:67 */
struct __wsdd__Bye;	/* wsdx.h:76 */
struct __wsdd__Probe;	/* wsdx.h:85 */
struct __wsdd__ProbeMatches;	/* wsdx.h:94 */
struct __wsdd__Resolve;	/* wsdx.h:103 */
struct __wsdd__ResolveMatches;	/* wsdx.h:112 */
struct _xop__Include;	/* xop.h:58 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:63 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:66 */
struct wsa5__MetadataType;	/* wsa5.h:69 */
struct wsa5__ProblemActionType;	/* wsa5.h:84 */
struct wsa5__RelatesToType;	/* wsa5.h:72 */
struct chan__ChannelInstanceType;	/* wsa5.h:258 */
struct SOAP_ENV__Fault_alex;	/* wsa5.h:288 */
class xsd__anyType;	/* onvif.h:170 */
struct SOAP_ENV__Envelope;	/* onvif.h:173 */
class xsd__base64Binary;	/* onvif.h:176 */
class xsd__hexBinary;	/* onvif.h:187 */
class _tds__Service_Capabilities;	/* onvif.h:4018 */
class tds__Service;	/* onvif.h:221 */
class tds__DeviceServiceCapabilities;	/* onvif.h:224 */
class tds__NetworkCapabilities;	/* onvif.h:227 */
class tds__SecurityCapabilities;	/* onvif.h:230 */
class tds__SystemCapabilities;	/* onvif.h:233 */
class tds__MiscCapabilities;	/* onvif.h:236 */
class _tds__UserCredential_Extension;	/* onvif.h:4426 */
class tds__UserCredential;	/* onvif.h:239 */
class _tds__StorageConfigurationData_Extension;	/* onvif.h:4478 */
class tds__StorageConfigurationData;	/* onvif.h:242 */
class _tds__GetServices;	/* onvif.h:248 */
class _tds__GetServicesResponse;	/* onvif.h:251 */
class _tds__GetServiceCapabilities;	/* onvif.h:254 */
class _tds__GetServiceCapabilitiesResponse;	/* onvif.h:257 */
class _tds__GetDeviceInformation;	/* onvif.h:260 */
class _tds__GetDeviceInformationResponse;	/* onvif.h:263 */
class _tds__SetSystemDateAndTime;	/* onvif.h:266 */
class _tds__SetSystemDateAndTimeResponse;	/* onvif.h:269 */
class _tds__GetSystemDateAndTime;	/* onvif.h:272 */
class _tds__GetSystemDateAndTimeResponse;	/* onvif.h:275 */
class _tds__SetSystemFactoryDefault;	/* onvif.h:278 */
class _tds__SetSystemFactoryDefaultResponse;	/* onvif.h:281 */
class _tds__UpgradeSystemFirmware;	/* onvif.h:284 */
class _tds__UpgradeSystemFirmwareResponse;	/* onvif.h:287 */
class _tds__SystemReboot;	/* onvif.h:290 */
class _tds__SystemRebootResponse;	/* onvif.h:293 */
class _tds__RestoreSystem;	/* onvif.h:296 */
class _tds__RestoreSystemResponse;	/* onvif.h:299 */
class _tds__GetSystemBackup;	/* onvif.h:302 */
class _tds__GetSystemBackupResponse;	/* onvif.h:305 */
class _tds__GetSystemSupportInformation;	/* onvif.h:308 */
class _tds__GetSystemSupportInformationResponse;	/* onvif.h:311 */
class _tds__GetSystemLog;	/* onvif.h:314 */
class _tds__GetSystemLogResponse;	/* onvif.h:317 */
class _tds__GetScopes;	/* onvif.h:320 */
class _tds__GetScopesResponse;	/* onvif.h:323 */
class _tds__SetScopes;	/* onvif.h:326 */
class _tds__SetScopesResponse;	/* onvif.h:329 */
class _tds__AddScopes;	/* onvif.h:332 */
class _tds__AddScopesResponse;	/* onvif.h:335 */
class _tds__RemoveScopes;	/* onvif.h:338 */
class _tds__RemoveScopesResponse;	/* onvif.h:341 */
class _tds__GetDiscoveryMode;	/* onvif.h:344 */
class _tds__GetDiscoveryModeResponse;	/* onvif.h:347 */
class _tds__SetDiscoveryMode;	/* onvif.h:350 */
class _tds__SetDiscoveryModeResponse;	/* onvif.h:353 */
class _tds__GetRemoteDiscoveryMode;	/* onvif.h:356 */
class _tds__GetRemoteDiscoveryModeResponse;	/* onvif.h:359 */
class _tds__SetRemoteDiscoveryMode;	/* onvif.h:362 */
class _tds__SetRemoteDiscoveryModeResponse;	/* onvif.h:365 */
class _tds__GetDPAddresses;	/* onvif.h:368 */
class _tds__GetDPAddressesResponse;	/* onvif.h:371 */
class _tds__SetDPAddresses;	/* onvif.h:374 */
class _tds__SetDPAddressesResponse;	/* onvif.h:377 */
class _tds__GetEndpointReference;	/* onvif.h:380 */
class _tds__GetEndpointReferenceResponse;	/* onvif.h:383 */
class _tds__GetRemoteUser;	/* onvif.h:386 */
class _tds__GetRemoteUserResponse;	/* onvif.h:389 */
class _tds__SetRemoteUser;	/* onvif.h:392 */
class _tds__SetRemoteUserResponse;	/* onvif.h:395 */
class _tds__GetUsers;	/* onvif.h:398 */
class _tds__GetUsersResponse;	/* onvif.h:401 */
class _tds__CreateUsers;	/* onvif.h:404 */
class _tds__CreateUsersResponse;	/* onvif.h:407 */
class _tds__DeleteUsers;	/* onvif.h:410 */
class _tds__DeleteUsersResponse;	/* onvif.h:413 */
class _tds__SetUser;	/* onvif.h:416 */
class _tds__SetUserResponse;	/* onvif.h:419 */
class _tds__GetWsdlUrl;	/* onvif.h:422 */
class _tds__GetWsdlUrlResponse;	/* onvif.h:425 */
class _tds__GetCapabilities;	/* onvif.h:428 */
class _tds__GetCapabilitiesResponse;	/* onvif.h:431 */
class _tds__GetHostname;	/* onvif.h:434 */
class _tds__GetHostnameResponse;	/* onvif.h:437 */
class _tds__SetHostname;	/* onvif.h:440 */
class _tds__SetHostnameResponse;	/* onvif.h:443 */
class _tds__SetHostnameFromDHCP;	/* onvif.h:446 */
class _tds__SetHostnameFromDHCPResponse;	/* onvif.h:449 */
class _tds__GetDNS;	/* onvif.h:452 */
class _tds__GetDNSResponse;	/* onvif.h:455 */
class _tds__SetDNS;	/* onvif.h:458 */
class _tds__SetDNSResponse;	/* onvif.h:461 */
class _tds__GetNTP;	/* onvif.h:464 */
class _tds__GetNTPResponse;	/* onvif.h:467 */
class _tds__SetNTP;	/* onvif.h:470 */
class _tds__SetNTPResponse;	/* onvif.h:473 */
class _tds__GetDynamicDNS;	/* onvif.h:476 */
class _tds__GetDynamicDNSResponse;	/* onvif.h:479 */
class _tds__SetDynamicDNS;	/* onvif.h:482 */
class _tds__SetDynamicDNSResponse;	/* onvif.h:485 */
class _tds__GetNetworkInterfaces;	/* onvif.h:488 */
class _tds__GetNetworkInterfacesResponse;	/* onvif.h:491 */
class _tds__SetNetworkInterfaces;	/* onvif.h:494 */
class _tds__SetNetworkInterfacesResponse;	/* onvif.h:497 */
class _tds__GetNetworkProtocols;	/* onvif.h:500 */
class _tds__GetNetworkProtocolsResponse;	/* onvif.h:503 */
class _tds__SetNetworkProtocols;	/* onvif.h:506 */
class _tds__SetNetworkProtocolsResponse;	/* onvif.h:509 */
class _tds__GetNetworkDefaultGateway;	/* onvif.h:512 */
class _tds__GetNetworkDefaultGatewayResponse;	/* onvif.h:515 */
class _tds__SetNetworkDefaultGateway;	/* onvif.h:518 */
class _tds__SetNetworkDefaultGatewayResponse;	/* onvif.h:521 */
class _tds__GetZeroConfiguration;	/* onvif.h:524 */
class _tds__GetZeroConfigurationResponse;	/* onvif.h:527 */
class _tds__SetZeroConfiguration;	/* onvif.h:530 */
class _tds__SetZeroConfigurationResponse;	/* onvif.h:533 */
class _tds__GetIPAddressFilter;	/* onvif.h:536 */
class _tds__GetIPAddressFilterResponse;	/* onvif.h:539 */
class _tds__SetIPAddressFilter;	/* onvif.h:542 */
class _tds__SetIPAddressFilterResponse;	/* onvif.h:545 */
class _tds__AddIPAddressFilter;	/* onvif.h:548 */
class _tds__AddIPAddressFilterResponse;	/* onvif.h:551 */
class _tds__RemoveIPAddressFilter;	/* onvif.h:554 */
class _tds__RemoveIPAddressFilterResponse;	/* onvif.h:557 */
class _tds__GetAccessPolicy;	/* onvif.h:560 */
class _tds__GetAccessPolicyResponse;	/* onvif.h:563 */
class _tds__SetAccessPolicy;	/* onvif.h:566 */
class _tds__SetAccessPolicyResponse;	/* onvif.h:569 */
class _tds__CreateCertificate;	/* onvif.h:572 */
class _tds__CreateCertificateResponse;	/* onvif.h:575 */
class _tds__GetCertificates;	/* onvif.h:578 */
class _tds__GetCertificatesResponse;	/* onvif.h:581 */
class _tds__GetCertificatesStatus;	/* onvif.h:584 */
class _tds__GetCertificatesStatusResponse;	/* onvif.h:587 */
class _tds__SetCertificatesStatus;	/* onvif.h:590 */
class _tds__SetCertificatesStatusResponse;	/* onvif.h:593 */
class _tds__DeleteCertificates;	/* onvif.h:596 */
class _tds__DeleteCertificatesResponse;	/* onvif.h:599 */
class _tds__GetPkcs10Request;	/* onvif.h:602 */
class _tds__GetPkcs10RequestResponse;	/* onvif.h:605 */
class _tds__LoadCertificates;	/* onvif.h:608 */
class _tds__LoadCertificatesResponse;	/* onvif.h:611 */
class _tds__GetClientCertificateMode;	/* onvif.h:614 */
class _tds__GetClientCertificateModeResponse;	/* onvif.h:617 */
class _tds__SetClientCertificateMode;	/* onvif.h:620 */
class _tds__SetClientCertificateModeResponse;	/* onvif.h:623 */
class _tds__GetCACertificates;	/* onvif.h:626 */
class _tds__GetCACertificatesResponse;	/* onvif.h:629 */
class _tds__LoadCertificateWithPrivateKey;	/* onvif.h:632 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* onvif.h:635 */
class _tds__GetCertificateInformation;	/* onvif.h:638 */
class _tds__GetCertificateInformationResponse;	/* onvif.h:641 */
class _tds__LoadCACertificates;	/* onvif.h:644 */
class _tds__LoadCACertificatesResponse;	/* onvif.h:647 */
class _tds__CreateDot1XConfiguration;	/* onvif.h:650 */
class _tds__CreateDot1XConfigurationResponse;	/* onvif.h:653 */
class _tds__SetDot1XConfiguration;	/* onvif.h:656 */
class _tds__SetDot1XConfigurationResponse;	/* onvif.h:659 */
class _tds__GetDot1XConfiguration;	/* onvif.h:662 */
class _tds__GetDot1XConfigurationResponse;	/* onvif.h:665 */
class _tds__GetDot1XConfigurations;	/* onvif.h:668 */
class _tds__GetDot1XConfigurationsResponse;	/* onvif.h:671 */
class _tds__DeleteDot1XConfiguration;	/* onvif.h:674 */
class _tds__DeleteDot1XConfigurationResponse;	/* onvif.h:677 */
class _tds__GetRelayOutputs;	/* onvif.h:680 */
class _tds__GetRelayOutputsResponse;	/* onvif.h:683 */
class _tds__SetRelayOutputSettings;	/* onvif.h:686 */
class _tds__SetRelayOutputSettingsResponse;	/* onvif.h:689 */
class _tds__SetRelayOutputState;	/* onvif.h:692 */
class _tds__SetRelayOutputStateResponse;	/* onvif.h:695 */
class _tds__SendAuxiliaryCommand;	/* onvif.h:698 */
class _tds__SendAuxiliaryCommandResponse;	/* onvif.h:701 */
class _tds__GetDot11Capabilities;	/* onvif.h:704 */
class _tds__GetDot11CapabilitiesResponse;	/* onvif.h:707 */
class _tds__GetDot11Status;	/* onvif.h:710 */
class _tds__GetDot11StatusResponse;	/* onvif.h:713 */
class _tds__ScanAvailableDot11Networks;	/* onvif.h:716 */
class _tds__ScanAvailableDot11NetworksResponse;	/* onvif.h:719 */
class _tds__GetSystemUris;	/* onvif.h:722 */
class _tds__GetSystemUrisResponse_Extension;	/* onvif.h:8100 */
class _tds__GetSystemUrisResponse;	/* onvif.h:725 */
class _tds__StartFirmwareUpgrade;	/* onvif.h:728 */
class _tds__StartFirmwareUpgradeResponse;	/* onvif.h:731 */
class _tds__StartSystemRestore;	/* onvif.h:734 */
class _tds__StartSystemRestoreResponse;	/* onvif.h:737 */
class _tds__GetStorageConfigurations;	/* onvif.h:740 */
class _tds__GetStorageConfigurationsResponse;	/* onvif.h:743 */
class _tds__CreateStorageConfiguration;	/* onvif.h:746 */
class _tds__CreateStorageConfigurationResponse;	/* onvif.h:749 */
class _tds__GetStorageConfiguration;	/* onvif.h:752 */
class _tds__GetStorageConfigurationResponse;	/* onvif.h:755 */
class _tds__SetStorageConfiguration;	/* onvif.h:758 */
class _tds__SetStorageConfigurationResponse;	/* onvif.h:761 */
class _tds__DeleteStorageConfiguration;	/* onvif.h:764 */
class _tds__DeleteStorageConfigurationResponse;	/* onvif.h:767 */
class _tds__GetGeoLocation;	/* onvif.h:770 */
class _tds__GetGeoLocationResponse;	/* onvif.h:773 */
class _tds__SetGeoLocation;	/* onvif.h:776 */
class _tds__SetGeoLocationResponse;	/* onvif.h:779 */
class _tds__DeleteGeoLocation;	/* onvif.h:782 */
class _tds__DeleteGeoLocationResponse;	/* onvif.h:785 */
class tt__DeviceEntity;	/* onvif.h:788 */
class tt__IntRectangle;	/* onvif.h:791 */
class tt__IntRectangleRange;	/* onvif.h:794 */
class tt__IntRange;	/* onvif.h:797 */
class tt__FloatRange;	/* onvif.h:800 */
class tt__DurationRange;	/* onvif.h:803 */
class tt__IntList;	/* onvif.h:806 */
class tt__FloatList;	/* onvif.h:809 */
class tt__AnyHolder;	/* onvif.h:812 */
class tt__VideoSourceExtension;	/* onvif.h:818 */
class tt__VideoSourceExtension2;	/* onvif.h:821 */
class tt__Profile;	/* onvif.h:827 */
class tt__ProfileExtension;	/* onvif.h:830 */
class tt__ProfileExtension2;	/* onvif.h:833 */
class tt__ConfigurationEntity;	/* onvif.h:836 */
class tt__VideoSourceConfigurationExtension;	/* onvif.h:842 */
class tt__VideoSourceConfigurationExtension2;	/* onvif.h:845 */
class tt__Rotate;	/* onvif.h:848 */
class tt__RotateExtension;	/* onvif.h:851 */
class tt__LensProjection;	/* onvif.h:854 */
class tt__LensOffset;	/* onvif.h:857 */
class tt__LensDescription;	/* onvif.h:860 */
class tt__VideoSourceConfigurationOptions;	/* onvif.h:863 */
class tt__VideoSourceConfigurationOptionsExtension;	/* onvif.h:866 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* onvif.h:869 */
class tt__RotateOptions;	/* onvif.h:872 */
class tt__RotateOptionsExtension;	/* onvif.h:875 */
class tt__SceneOrientation;	/* onvif.h:878 */
class tt__VideoResolution;	/* onvif.h:884 */
class tt__VideoRateControl;	/* onvif.h:887 */
class tt__Mpeg4Configuration;	/* onvif.h:890 */
class tt__H264Configuration;	/* onvif.h:893 */
class tt__VideoEncoderConfigurationOptions;	/* onvif.h:896 */
class tt__VideoEncoderOptionsExtension;	/* onvif.h:899 */
class tt__VideoEncoderOptionsExtension2;	/* onvif.h:902 */
class tt__JpegOptions;	/* onvif.h:905 */
class tt__Mpeg4Options;	/* onvif.h:911 */
class tt__H264Options;	/* onvif.h:917 */
class tt__VideoResolution2;	/* onvif.h:926 */
class tt__VideoRateControl2;	/* onvif.h:929 */
class tt__VideoEncoder2ConfigurationOptions;	/* onvif.h:932 */
class tt__AudioSourceConfigurationOptions;	/* onvif.h:938 */
class tt__AudioSourceOptionsExtension;	/* onvif.h:941 */
class tt__AudioEncoderConfigurationOptions;	/* onvif.h:947 */
class tt__AudioEncoderConfigurationOption;	/* onvif.h:950 */
class tt__AudioEncoder2ConfigurationOptions;	/* onvif.h:956 */
class tt__MetadataConfigurationExtension;	/* onvif.h:965 */
class tt__PTZFilter;	/* onvif.h:968 */
class _tt__EventSubscription_SubscriptionPolicy;	/* onvif.h:10238 */
class tt__EventSubscription;	/* onvif.h:971 */
class tt__MetadataConfigurationOptions;	/* onvif.h:974 */
class tt__MetadataConfigurationOptionsExtension;	/* onvif.h:977 */
class tt__MetadataConfigurationOptionsExtension2;	/* onvif.h:980 */
class tt__PTZStatusFilterOptions;	/* onvif.h:983 */
class tt__PTZStatusFilterOptionsExtension;	/* onvif.h:986 */
class tt__VideoOutputExtension;	/* onvif.h:992 */
class tt__VideoOutputConfigurationOptions;	/* onvif.h:998 */
class tt__VideoDecoderConfigurationOptions;	/* onvif.h:1001 */
class tt__H264DecOptions;	/* onvif.h:1004 */
class tt__JpegDecOptions;	/* onvif.h:1007 */
class tt__Mpeg4DecOptions;	/* onvif.h:1010 */
class tt__VideoDecoderConfigurationOptionsExtension;	/* onvif.h:1013 */
class tt__AudioOutputConfigurationOptions;	/* onvif.h:1022 */
class tt__AudioDecoderConfigurationOptions;	/* onvif.h:1028 */
class tt__G711DecOptions;	/* onvif.h:1031 */
class tt__AACDecOptions;	/* onvif.h:1034 */
class tt__G726DecOptions;	/* onvif.h:1037 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* onvif.h:1040 */
class tt__MulticastConfiguration;	/* onvif.h:1043 */
class tt__StreamSetup;	/* onvif.h:1046 */
class tt__Transport;	/* onvif.h:1049 */
class tt__MediaUri;	/* onvif.h:1052 */
class tt__Scope;	/* onvif.h:1055 */
class tt__NetworkInterfaceExtension;	/* onvif.h:1061 */
class tt__Dot3Configuration;	/* onvif.h:1064 */
class tt__NetworkInterfaceExtension2;	/* onvif.h:1067 */
class tt__NetworkInterfaceLink;	/* onvif.h:1070 */
class tt__NetworkInterfaceConnectionSetting;	/* onvif.h:1073 */
class tt__NetworkInterfaceInfo;	/* onvif.h:1076 */
class tt__IPv6NetworkInterface;	/* onvif.h:1079 */
class tt__IPv4NetworkInterface;	/* onvif.h:1082 */
class tt__IPv4Configuration;	/* onvif.h:1085 */
class tt__IPv6Configuration;	/* onvif.h:1088 */
class tt__IPv6ConfigurationExtension;	/* onvif.h:1091 */
class tt__NetworkProtocol;	/* onvif.h:1094 */
class tt__NetworkProtocolExtension;	/* onvif.h:1097 */
class tt__NetworkHost;	/* onvif.h:1100 */
class tt__NetworkHostExtension;	/* onvif.h:1103 */
class tt__IPAddress;	/* onvif.h:1106 */
class tt__PrefixedIPv4Address;	/* onvif.h:1109 */
class tt__PrefixedIPv6Address;	/* onvif.h:1112 */
class tt__HostnameInformation;	/* onvif.h:1115 */
class tt__HostnameInformationExtension;	/* onvif.h:1118 */
class tt__DNSInformation;	/* onvif.h:1121 */
class tt__DNSInformationExtension;	/* onvif.h:1124 */
class tt__NTPInformation;	/* onvif.h:1127 */
class tt__NTPInformationExtension;	/* onvif.h:1130 */
class tt__DynamicDNSInformation;	/* onvif.h:1133 */
class tt__DynamicDNSInformationExtension;	/* onvif.h:1136 */
class tt__NetworkInterfaceSetConfiguration;	/* onvif.h:1139 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* onvif.h:1142 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* onvif.h:1145 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* onvif.h:1148 */
class tt__NetworkGateway;	/* onvif.h:1151 */
class tt__NetworkZeroConfiguration;	/* onvif.h:1154 */
class tt__NetworkZeroConfigurationExtension;	/* onvif.h:1157 */
class tt__NetworkZeroConfigurationExtension2;	/* onvif.h:1160 */
class tt__IPAddressFilter;	/* onvif.h:1163 */
class tt__IPAddressFilterExtension;	/* onvif.h:1166 */
class tt__Dot11Configuration;	/* onvif.h:1169 */
class tt__Dot11SecurityConfiguration;	/* onvif.h:1172 */
class tt__Dot11SecurityConfigurationExtension;	/* onvif.h:1175 */
class tt__Dot11PSKSet;	/* onvif.h:1178 */
class tt__Dot11PSKSetExtension;	/* onvif.h:1181 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* onvif.h:1184 */
class tt__Dot11Capabilities;	/* onvif.h:1187 */
class tt__Dot11Status;	/* onvif.h:1190 */
class tt__Dot11AvailableNetworks;	/* onvif.h:1193 */
class tt__Dot11AvailableNetworksExtension;	/* onvif.h:1196 */
class tt__Capabilities;	/* onvif.h:1199 */
class tt__CapabilitiesExtension;	/* onvif.h:1202 */
class tt__CapabilitiesExtension2;	/* onvif.h:1205 */
class tt__AnalyticsCapabilities;	/* onvif.h:1208 */
class tt__DeviceCapabilities;	/* onvif.h:1211 */
class tt__DeviceCapabilitiesExtension;	/* onvif.h:1214 */
class tt__EventCapabilities;	/* onvif.h:1217 */
class tt__IOCapabilities;	/* onvif.h:1220 */
class tt__IOCapabilitiesExtension;	/* onvif.h:1223 */
class tt__IOCapabilitiesExtension2;	/* onvif.h:1226 */
class tt__MediaCapabilities;	/* onvif.h:1229 */
class tt__MediaCapabilitiesExtension;	/* onvif.h:1232 */
class tt__RealTimeStreamingCapabilities;	/* onvif.h:1235 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* onvif.h:1238 */
class tt__ProfileCapabilities;	/* onvif.h:1241 */
class tt__NetworkCapabilities;	/* onvif.h:1244 */
class tt__NetworkCapabilitiesExtension;	/* onvif.h:1247 */
class tt__NetworkCapabilitiesExtension2;	/* onvif.h:1250 */
class tt__SecurityCapabilities;	/* onvif.h:1253 */
class tt__SecurityCapabilitiesExtension;	/* onvif.h:1256 */
class tt__SecurityCapabilitiesExtension2;	/* onvif.h:1259 */
class tt__SystemCapabilities;	/* onvif.h:1262 */
class tt__SystemCapabilitiesExtension;	/* onvif.h:1265 */
class tt__SystemCapabilitiesExtension2;	/* onvif.h:1268 */
class tt__OnvifVersion;	/* onvif.h:1271 */
class tt__ImagingCapabilities;	/* onvif.h:1274 */
class tt__PTZCapabilities;	/* onvif.h:1277 */
class tt__DeviceIOCapabilities;	/* onvif.h:1280 */
class tt__DisplayCapabilities;	/* onvif.h:1283 */
class tt__RecordingCapabilities;	/* onvif.h:1286 */
class tt__SearchCapabilities;	/* onvif.h:1289 */
class tt__ReplayCapabilities;	/* onvif.h:1292 */
class tt__ReceiverCapabilities;	/* onvif.h:1295 */
class tt__AnalyticsDeviceCapabilities;	/* onvif.h:1298 */
class tt__AnalyticsDeviceExtension;	/* onvif.h:1301 */
class tt__SystemLog;	/* onvif.h:1304 */
class tt__SupportInformation;	/* onvif.h:1307 */
class tt__BinaryData;	/* onvif.h:1310 */
class tt__AttachmentData;	/* onvif.h:1313 */
class tt__BackupFile;	/* onvif.h:1316 */
class tt__SystemLogUriList;	/* onvif.h:1319 */
class tt__SystemLogUri;	/* onvif.h:1322 */
class tt__SystemDateTime;	/* onvif.h:1325 */
class tt__SystemDateTimeExtension;	/* onvif.h:1328 */
class tt__DateTime;	/* onvif.h:1331 */
class tt__Date;	/* onvif.h:1334 */
class tt__Time;	/* onvif.h:1337 */
class tt__TimeZone;	/* onvif.h:1340 */
class tt__RemoteUser;	/* onvif.h:1343 */
class tt__User;	/* onvif.h:1346 */
class tt__UserExtension;	/* onvif.h:1349 */
class tt__CertificateGenerationParameters;	/* onvif.h:1352 */
class tt__CertificateGenerationParametersExtension;	/* onvif.h:1355 */
class tt__Certificate;	/* onvif.h:1358 */
class tt__CertificateStatus;	/* onvif.h:1361 */
class tt__CertificateWithPrivateKey;	/* onvif.h:1364 */
class tt__CertificateInformation;	/* onvif.h:1367 */
class tt__CertificateInformationExtension;	/* onvif.h:1373 */
class tt__Dot1XConfiguration;	/* onvif.h:1376 */
class tt__Dot1XConfigurationExtension;	/* onvif.h:1379 */
class tt__EAPMethodConfiguration;	/* onvif.h:1382 */
class tt__EapMethodExtension;	/* onvif.h:1385 */
class tt__TLSConfiguration;	/* onvif.h:1388 */
class tt__GenericEapPwdConfigurationExtension;	/* onvif.h:1391 */
class tt__RelayOutputSettings;	/* onvif.h:1394 */
class tt__PTZNodeExtension;	/* onvif.h:1406 */
class tt__PTZNodeExtension2;	/* onvif.h:1409 */
class tt__PTZPresetTourSupported;	/* onvif.h:1412 */
class tt__PTZPresetTourSupportedExtension;	/* onvif.h:1415 */
class tt__PTZConfigurationExtension;	/* onvif.h:1421 */
class tt__PTZConfigurationExtension2;	/* onvif.h:1424 */
class tt__PTControlDirection;	/* onvif.h:1427 */
class tt__PTControlDirectionExtension;	/* onvif.h:1430 */
class tt__EFlip;	/* onvif.h:1433 */
class tt__Reverse;	/* onvif.h:1436 */
class tt__PTZConfigurationOptions;	/* onvif.h:1439 */
class tt__PTZConfigurationOptions2;	/* onvif.h:1442 */
class tt__PTControlDirectionOptions;	/* onvif.h:1445 */
class tt__PTControlDirectionOptionsExtension;	/* onvif.h:1448 */
class tt__EFlipOptions;	/* onvif.h:1451 */
class tt__EFlipOptionsExtension;	/* onvif.h:1454 */
class tt__ReverseOptions;	/* onvif.h:1457 */
class tt__ReverseOptionsExtension;	/* onvif.h:1460 */
class tt__PanTiltLimits;	/* onvif.h:1463 */
class tt__ZoomLimits;	/* onvif.h:1466 */
class tt__PTZSpaces;	/* onvif.h:1469 */
class tt__PTZSpacesExtension;	/* onvif.h:1472 */
class tt__Space2DDescription;	/* onvif.h:1475 */
class tt__Space1DDescription;	/* onvif.h:1478 */
class tt__PTZSpeed;	/* onvif.h:1481 */
class tt__PTZPreset;	/* onvif.h:1484 */
class tt__PresetTour;	/* onvif.h:1487 */
class tt__PTZPresetTourExtension;	/* onvif.h:1490 */
class tt__PTZPresetTourSpot;	/* onvif.h:1493 */
class tt__PTZPresetTourSpotExtension;	/* onvif.h:1496 */
union _tt__union_PTZPresetTourPresetDetail;	/* onvif.h:15881 */
class tt__PTZPresetTourPresetDetail;	/* onvif.h:1499 */
class tt__PTZPresetTourTypeExtension;	/* onvif.h:1502 */
class tt__PTZPresetTourStatus;	/* onvif.h:1505 */
class tt__PTZPresetTourStatusExtension;	/* onvif.h:1508 */
class tt__PTZPresetTourStartingCondition;	/* onvif.h:1511 */
class tt__PTZPresetTourStartingConditionExtension;	/* onvif.h:1514 */
class tt__PTZPresetTourOptions;	/* onvif.h:1517 */
class tt__PTZPresetTourSpotOptions;	/* onvif.h:1520 */
class tt__PTZPresetTourPresetDetailOptions;	/* onvif.h:1523 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* onvif.h:1526 */
class tt__PTZPresetTourStartingConditionOptions;	/* onvif.h:1529 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* onvif.h:1532 */
class tt__ImagingStatus;	/* onvif.h:1535 */
class tt__FocusStatus;	/* onvif.h:1538 */
class tt__FocusConfiguration;	/* onvif.h:1541 */
class tt__ImagingSettings;	/* onvif.h:1544 */
class tt__ImagingSettingsExtension;	/* onvif.h:1547 */
class tt__Exposure;	/* onvif.h:1550 */
class tt__WideDynamicRange;	/* onvif.h:1553 */
class tt__BacklightCompensation;	/* onvif.h:1556 */
class tt__ImagingOptions;	/* onvif.h:1559 */
class tt__WideDynamicRangeOptions;	/* onvif.h:1562 */
class tt__BacklightCompensationOptions;	/* onvif.h:1565 */
class tt__FocusOptions;	/* onvif.h:1568 */
class tt__ExposureOptions;	/* onvif.h:1571 */
class tt__WhiteBalanceOptions;	/* onvif.h:1574 */
class tt__FocusMove;	/* onvif.h:1577 */
class tt__AbsoluteFocus;	/* onvif.h:1580 */
class tt__RelativeFocus;	/* onvif.h:1583 */
class tt__ContinuousFocus;	/* onvif.h:1586 */
class tt__MoveOptions;	/* onvif.h:1589 */
class tt__AbsoluteFocusOptions;	/* onvif.h:1592 */
class tt__RelativeFocusOptions;	/* onvif.h:1595 */
class tt__ContinuousFocusOptions;	/* onvif.h:1598 */
class tt__WhiteBalance;	/* onvif.h:1601 */
class tt__ImagingStatus20;	/* onvif.h:1604 */
class tt__ImagingStatus20Extension;	/* onvif.h:1607 */
class tt__FocusStatus20;	/* onvif.h:1610 */
class tt__FocusStatus20Extension;	/* onvif.h:1613 */
class tt__ImagingSettings20;	/* onvif.h:1616 */
class tt__ImagingSettingsExtension20;	/* onvif.h:1619 */
class tt__ImagingSettingsExtension202;	/* onvif.h:1622 */
class tt__ImagingSettingsExtension203;	/* onvif.h:1625 */
class tt__ImagingSettingsExtension204;	/* onvif.h:1628 */
class tt__ImageStabilization;	/* onvif.h:1631 */
class tt__ImageStabilizationExtension;	/* onvif.h:1634 */
class tt__IrCutFilterAutoAdjustment;	/* onvif.h:1637 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* onvif.h:1640 */
class tt__WideDynamicRange20;	/* onvif.h:1643 */
class tt__BacklightCompensation20;	/* onvif.h:1646 */
class tt__Exposure20;	/* onvif.h:1649 */
class tt__ToneCompensation;	/* onvif.h:1652 */
class tt__ToneCompensationExtension;	/* onvif.h:1655 */
class tt__Defogging;	/* onvif.h:1658 */
class tt__DefoggingExtension;	/* onvif.h:1661 */
class tt__NoiseReduction;	/* onvif.h:1664 */
class tt__ImagingOptions20;	/* onvif.h:1667 */
class tt__ImagingOptions20Extension;	/* onvif.h:1670 */
class tt__ImagingOptions20Extension2;	/* onvif.h:1673 */
class tt__ImagingOptions20Extension3;	/* onvif.h:1676 */
class tt__ImagingOptions20Extension4;	/* onvif.h:1679 */
class tt__ImageStabilizationOptions;	/* onvif.h:1682 */
class tt__ImageStabilizationOptionsExtension;	/* onvif.h:1685 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* onvif.h:1688 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvif.h:1691 */
class tt__WideDynamicRangeOptions20;	/* onvif.h:1694 */
class tt__BacklightCompensationOptions20;	/* onvif.h:1697 */
class tt__ExposureOptions20;	/* onvif.h:1700 */
class tt__MoveOptions20;	/* onvif.h:1703 */
class tt__RelativeFocusOptions20;	/* onvif.h:1706 */
class tt__WhiteBalance20;	/* onvif.h:1709 */
class tt__WhiteBalance20Extension;	/* onvif.h:1712 */
class tt__FocusConfiguration20;	/* onvif.h:1715 */
class tt__FocusConfiguration20Extension;	/* onvif.h:1718 */
class tt__WhiteBalanceOptions20;	/* onvif.h:1721 */
class tt__WhiteBalanceOptions20Extension;	/* onvif.h:1724 */
class tt__FocusOptions20;	/* onvif.h:1727 */
class tt__FocusOptions20Extension;	/* onvif.h:1730 */
class tt__ToneCompensationOptions;	/* onvif.h:1733 */
class tt__DefoggingOptions;	/* onvif.h:1736 */
class tt__NoiseReductionOptions;	/* onvif.h:1739 */
class tt__MessageExtension;	/* onvif.h:1742 */
class _tt__ItemList_SimpleItem;	/* onvif.h:18744 */
class _tt__ItemList_ElementItem;	/* onvif.h:18772 */
class tt__ItemList;	/* onvif.h:1745 */
class tt__ItemListExtension;	/* onvif.h:1748 */
class tt__MessageDescription;	/* onvif.h:1751 */
class tt__MessageDescriptionExtension;	/* onvif.h:1754 */
class _tt__ItemListDescription_SimpleItemDescription;	/* onvif.h:18925 */
class _tt__ItemListDescription_ElementItemDescription;	/* onvif.h:18950 */
class tt__ItemListDescription;	/* onvif.h:1757 */
class tt__ItemListDescriptionExtension;	/* onvif.h:1760 */
class tt__Polyline;	/* onvif.h:1763 */
class tt__AnalyticsEngineConfiguration;	/* onvif.h:1766 */
class tt__AnalyticsEngineConfigurationExtension;	/* onvif.h:1769 */
class tt__RuleEngineConfiguration;	/* onvif.h:1772 */
class tt__RuleEngineConfigurationExtension;	/* onvif.h:1775 */
class tt__Config;	/* onvif.h:1778 */
class _tt__ConfigDescription_Messages;	/* onvif.h:19198 */
class tt__ConfigDescription;	/* onvif.h:1781 */
class tt__ConfigDescriptionExtension;	/* onvif.h:1784 */
class tt__SupportedRules;	/* onvif.h:1787 */
class tt__SupportedRulesExtension;	/* onvif.h:1790 */
class tt__SupportedAnalyticsModules;	/* onvif.h:1793 */
class tt__SupportedAnalyticsModulesExtension;	/* onvif.h:1796 */
class tt__PolygonConfiguration;	/* onvif.h:1799 */
class tt__PolylineArray;	/* onvif.h:1802 */
class tt__PolylineArrayExtension;	/* onvif.h:1805 */
class tt__PolylineArrayConfiguration;	/* onvif.h:1808 */
class tt__MotionExpression;	/* onvif.h:1811 */
class tt__MotionExpressionConfiguration;	/* onvif.h:1814 */
class tt__CellLayout;	/* onvif.h:1817 */
class tt__PaneConfiguration;	/* onvif.h:1820 */
class tt__PaneLayout;	/* onvif.h:1823 */
class tt__Layout;	/* onvif.h:1826 */
class tt__LayoutExtension;	/* onvif.h:1829 */
class tt__CodingCapabilities;	/* onvif.h:1832 */
class tt__LayoutOptions;	/* onvif.h:1835 */
class tt__LayoutOptionsExtension;	/* onvif.h:1838 */
class tt__PaneLayoutOptions;	/* onvif.h:1841 */
class tt__PaneOptionExtension;	/* onvif.h:1844 */
class tt__Receiver;	/* onvif.h:1847 */
class tt__ReceiverConfiguration;	/* onvif.h:1850 */
class tt__ReceiverStateInformation;	/* onvif.h:1853 */
class tt__SourceReference;	/* onvif.h:1856 */
class tt__DateTimeRange;	/* onvif.h:1859 */
class tt__RecordingSummary;	/* onvif.h:1862 */
class tt__SearchScope;	/* onvif.h:1865 */
class tt__SearchScopeExtension;	/* onvif.h:1868 */
class tt__PTZPositionFilter;	/* onvif.h:1874 */
class tt__MetadataFilter;	/* onvif.h:1877 */
class tt__FindRecordingResultList;	/* onvif.h:1880 */
class tt__FindEventResultList;	/* onvif.h:1883 */
class tt__FindEventResult;	/* onvif.h:1886 */
class tt__FindPTZPositionResultList;	/* onvif.h:1889 */
class tt__FindPTZPositionResult;	/* onvif.h:1892 */
class tt__FindMetadataResultList;	/* onvif.h:1895 */
class tt__FindMetadataResult;	/* onvif.h:1898 */
class tt__RecordingInformation;	/* onvif.h:1901 */
class tt__RecordingSourceInformation;	/* onvif.h:1904 */
class tt__TrackInformation;	/* onvif.h:1907 */
class tt__MediaAttributes;	/* onvif.h:1910 */
class tt__TrackAttributes;	/* onvif.h:1913 */
class tt__TrackAttributesExtension;	/* onvif.h:1916 */
class tt__VideoAttributes;	/* onvif.h:1919 */
class tt__AudioAttributes;	/* onvif.h:1922 */
class tt__MetadataAttributes;	/* onvif.h:1925 */
class tt__RecordingConfiguration;	/* onvif.h:1928 */
class tt__TrackConfiguration;	/* onvif.h:1931 */
class tt__GetRecordingsResponseItem;	/* onvif.h:1934 */
class tt__GetTracksResponseList;	/* onvif.h:1937 */
class tt__GetTracksResponseItem;	/* onvif.h:1940 */
class tt__RecordingJobConfiguration;	/* onvif.h:1943 */
class tt__RecordingJobConfigurationExtension;	/* onvif.h:1946 */
class tt__RecordingJobSource;	/* onvif.h:1949 */
class tt__RecordingJobSourceExtension;	/* onvif.h:1952 */
class tt__RecordingJobTrack;	/* onvif.h:1955 */
class tt__RecordingJobStateInformation;	/* onvif.h:1958 */
class tt__RecordingJobStateInformationExtension;	/* onvif.h:1961 */
class tt__RecordingJobStateSource;	/* onvif.h:1964 */
class tt__RecordingJobStateTracks;	/* onvif.h:1967 */
class tt__RecordingJobStateTrack;	/* onvif.h:1970 */
class tt__GetRecordingJobsResponseItem;	/* onvif.h:1973 */
class tt__ReplayConfiguration;	/* onvif.h:1976 */
class tt__AnalyticsDeviceEngineConfiguration;	/* onvif.h:1982 */
class tt__AnalyticsDeviceEngineConfigurationExtension;	/* onvif.h:1985 */
class tt__EngineConfiguration;	/* onvif.h:1988 */
class tt__AnalyticsEngineInputInfo;	/* onvif.h:1991 */
class tt__AnalyticsEngineInputInfoExtension;	/* onvif.h:1994 */
class tt__SourceIdentification;	/* onvif.h:2000 */
class tt__SourceIdentificationExtension;	/* onvif.h:2003 */
class tt__MetadataInput;	/* onvif.h:2006 */
class tt__MetadataInputExtension;	/* onvif.h:2009 */
class tt__AnalyticsStateInformation;	/* onvif.h:2015 */
class tt__AnalyticsState;	/* onvif.h:2018 */
class tt__ActionEngineEventPayload;	/* onvif.h:2021 */
class tt__ActionEngineEventPayloadExtension;	/* onvif.h:2024 */
class tt__AudioClassCandidate;	/* onvif.h:2027 */
class tt__AudioClassDescriptor;	/* onvif.h:2030 */
class tt__AudioClassDescriptorExtension;	/* onvif.h:2033 */
class tt__ActiveConnection;	/* onvif.h:2036 */
class tt__ProfileStatus;	/* onvif.h:2039 */
class tt__ProfileStatusExtension;	/* onvif.h:2042 */
class tt__OSDPosConfiguration;	/* onvif.h:2048 */
class tt__OSDPosConfigurationExtension;	/* onvif.h:2051 */
class tt__OSDColor;	/* onvif.h:2054 */
class tt__OSDTextConfiguration;	/* onvif.h:2057 */
class tt__OSDTextConfigurationExtension;	/* onvif.h:2060 */
class tt__OSDImgConfiguration;	/* onvif.h:2063 */
class tt__OSDImgConfigurationExtension;	/* onvif.h:2066 */
class tt__ColorspaceRange;	/* onvif.h:2069 */
class tt__ColorOptions;	/* onvif.h:2072 */
class tt__OSDColorOptions;	/* onvif.h:2075 */
class tt__OSDColorOptionsExtension;	/* onvif.h:2078 */
class tt__OSDTextOptions;	/* onvif.h:2081 */
class tt__OSDTextOptionsExtension;	/* onvif.h:2084 */
class tt__OSDImgOptions;	/* onvif.h:2087 */
class tt__OSDImgOptionsExtension;	/* onvif.h:2090 */
class tt__OSDConfigurationExtension;	/* onvif.h:2096 */
class tt__MaximumNumberOfOSDs;	/* onvif.h:2099 */
class tt__OSDConfigurationOptions;	/* onvif.h:2102 */
class tt__OSDConfigurationOptionsExtension;	/* onvif.h:2105 */
class tt__FileProgress;	/* onvif.h:2108 */
class tt__ArrayOfFileProgress;	/* onvif.h:2111 */
class tt__ArrayOfFileProgressExtension;	/* onvif.h:2114 */
class tt__StorageReferencePath;	/* onvif.h:2117 */
class tt__StorageReferencePathExtension;	/* onvif.h:2120 */
class tt__Vector2D;	/* onvif.h:2123 */
class tt__Vector1D;	/* onvif.h:2126 */
class tt__PTZVector;	/* onvif.h:2129 */
class tt__PTZStatus;	/* onvif.h:2132 */
class tt__PTZMoveStatus;	/* onvif.h:2135 */
class tt__Vector;	/* onvif.h:2138 */
class tt__Rectangle;	/* onvif.h:2141 */
class tt__Polygon;	/* onvif.h:2144 */
class tt__Color;	/* onvif.h:2147 */
class tt__ColorCovariance;	/* onvif.h:2150 */
class tt__Transformation;	/* onvif.h:2153 */
class tt__TransformationExtension;	/* onvif.h:2156 */
class tt__GeoLocation;	/* onvif.h:2159 */
class tt__GeoOrientation;	/* onvif.h:2162 */
class tt__LocalLocation;	/* onvif.h:2165 */
class tt__LocalOrientation;	/* onvif.h:2168 */
class tt__LocationEntity;	/* onvif.h:2171 */
class _tt__Message;	/* onvif.h:2174 */
class wsnt__QueryExpressionType;	/* onvif.h:2177 */
class wsnt__TopicExpressionType;	/* onvif.h:2180 */
class wsnt__FilterType;	/* onvif.h:2183 */
class wsnt__SubscriptionPolicyType;	/* onvif.h:2186 */
class _wsnt__NotificationMessageHolderType_Message;	/* onvif.h:23935 */
class wsnt__NotificationMessageHolderType;	/* onvif.h:2189 */
class _wsnt__NotificationProducerRP;	/* onvif.h:2252 */
class _wsnt__SubscriptionManagerRP;	/* onvif.h:2255 */
class _wsnt__Notify;	/* onvif.h:2258 */
class _wsnt__UseRaw;	/* onvif.h:2261 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* onvif.h:24085 */
class _wsnt__Subscribe;	/* onvif.h:2264 */
class _wsnt__SubscribeResponse;	/* onvif.h:2267 */
class _wsnt__GetCurrentMessage;	/* onvif.h:2270 */
class _wsnt__GetCurrentMessageResponse;	/* onvif.h:2273 */
class _wsnt__GetMessages;	/* onvif.h:2276 */
class _wsnt__GetMessagesResponse;	/* onvif.h:2279 */
class _wsnt__DestroyPullPoint;	/* onvif.h:2282 */
class _wsnt__DestroyPullPointResponse;	/* onvif.h:2285 */
class _wsnt__CreatePullPoint;	/* onvif.h:2288 */
class _wsnt__CreatePullPointResponse;	/* onvif.h:2291 */
class _wsnt__Renew;	/* onvif.h:2294 */
class _wsnt__RenewResponse;	/* onvif.h:2297 */
class _wsnt__Unsubscribe;	/* onvif.h:2300 */
class _wsnt__UnsubscribeResponse;	/* onvif.h:2303 */
class _wsnt__PauseSubscription;	/* onvif.h:2306 */
class _wsnt__PauseSubscriptionResponse;	/* onvif.h:2309 */
class _wsnt__ResumeSubscription;	/* onvif.h:2312 */
class _wsnt__ResumeSubscriptionResponse;	/* onvif.h:2315 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* onvif.h:24623 */
class _wsrfbf__BaseFaultType_Description;	/* onvif.h:24644 */
class _wsrfbf__BaseFaultType_FaultCause;	/* onvif.h:24661 */
class wsrfbf__BaseFaultType;	/* onvif.h:2318 */
class wstop__Documentation;	/* onvif.h:2321 */
class wstop__ExtensibleDocumented;	/* onvif.h:2324 */
class wstop__QueryExpressionType;	/* onvif.h:2327 */
class trt__Capabilities;	/* onvif.h:2339 */
class trt__ProfileCapabilities;	/* onvif.h:2342 */
class trt__StreamingCapabilities;	/* onvif.h:2345 */
class trt__VideoSourceMode;	/* onvif.h:2348 */
class trt__VideoSourceModeExtension;	/* onvif.h:2351 */
class _trt__GetServiceCapabilities;	/* onvif.h:2354 */
class _trt__GetServiceCapabilitiesResponse;	/* onvif.h:2357 */
class _trt__GetVideoSources;	/* onvif.h:2360 */
class _trt__GetVideoSourcesResponse;	/* onvif.h:2363 */
class _trt__GetAudioSources;	/* onvif.h:2366 */
class _trt__GetAudioSourcesResponse;	/* onvif.h:2369 */
class _trt__GetAudioOutputs;	/* onvif.h:2372 */
class _trt__GetAudioOutputsResponse;	/* onvif.h:2375 */
class _trt__CreateProfile;	/* onvif.h:2378 */
class _trt__CreateProfileResponse;	/* onvif.h:2381 */
class _trt__GetProfile;	/* onvif.h:2384 */
class _trt__GetProfileResponse;	/* onvif.h:2387 */
class _trt__GetProfiles;	/* onvif.h:2390 */
class _trt__GetProfilesResponse;	/* onvif.h:2393 */
class _trt__AddVideoEncoderConfiguration;	/* onvif.h:2396 */
class _trt__AddVideoEncoderConfigurationResponse;	/* onvif.h:2399 */
class _trt__RemoveVideoEncoderConfiguration;	/* onvif.h:2402 */
class _trt__RemoveVideoEncoderConfigurationResponse;	/* onvif.h:2405 */
class _trt__AddVideoSourceConfiguration;	/* onvif.h:2408 */
class _trt__AddVideoSourceConfigurationResponse;	/* onvif.h:2411 */
class _trt__RemoveVideoSourceConfiguration;	/* onvif.h:2414 */
class _trt__RemoveVideoSourceConfigurationResponse;	/* onvif.h:2417 */
class _trt__AddAudioEncoderConfiguration;	/* onvif.h:2420 */
class _trt__AddAudioEncoderConfigurationResponse;	/* onvif.h:2423 */
class _trt__RemoveAudioEncoderConfiguration;	/* onvif.h:2426 */
class _trt__RemoveAudioEncoderConfigurationResponse;	/* onvif.h:2429 */
class _trt__AddAudioSourceConfiguration;	/* onvif.h:2432 */
class _trt__AddAudioSourceConfigurationResponse;	/* onvif.h:2435 */
class _trt__RemoveAudioSourceConfiguration;	/* onvif.h:2438 */
class _trt__RemoveAudioSourceConfigurationResponse;	/* onvif.h:2441 */
class _trt__AddPTZConfiguration;	/* onvif.h:2444 */
class _trt__AddPTZConfigurationResponse;	/* onvif.h:2447 */
class _trt__RemovePTZConfiguration;	/* onvif.h:2450 */
class _trt__RemovePTZConfigurationResponse;	/* onvif.h:2453 */
class _trt__AddVideoAnalyticsConfiguration;	/* onvif.h:2456 */
class _trt__AddVideoAnalyticsConfigurationResponse;	/* onvif.h:2459 */
class _trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:2462 */
class _trt__RemoveVideoAnalyticsConfigurationResponse;	/* onvif.h:2465 */
class _trt__AddMetadataConfiguration;	/* onvif.h:2468 */
class _trt__AddMetadataConfigurationResponse;	/* onvif.h:2471 */
class _trt__RemoveMetadataConfiguration;	/* onvif.h:2474 */
class _trt__RemoveMetadataConfigurationResponse;	/* onvif.h:2477 */
class _trt__AddAudioOutputConfiguration;	/* onvif.h:2480 */
class _trt__AddAudioOutputConfigurationResponse;	/* onvif.h:2483 */
class _trt__RemoveAudioOutputConfiguration;	/* onvif.h:2486 */
class _trt__RemoveAudioOutputConfigurationResponse;	/* onvif.h:2489 */
class _trt__AddAudioDecoderConfiguration;	/* onvif.h:2492 */
class _trt__AddAudioDecoderConfigurationResponse;	/* onvif.h:2495 */
class _trt__RemoveAudioDecoderConfiguration;	/* onvif.h:2498 */
class _trt__RemoveAudioDecoderConfigurationResponse;	/* onvif.h:2501 */
class _trt__DeleteProfile;	/* onvif.h:2504 */
class _trt__DeleteProfileResponse;	/* onvif.h:2507 */
class _trt__GetVideoEncoderConfigurations;	/* onvif.h:2510 */
class _trt__GetVideoEncoderConfigurationsResponse;	/* onvif.h:2513 */
class _trt__GetVideoSourceConfigurations;	/* onvif.h:2516 */
class _trt__GetVideoSourceConfigurationsResponse;	/* onvif.h:2519 */
class _trt__GetAudioEncoderConfigurations;	/* onvif.h:2522 */
class _trt__GetAudioEncoderConfigurationsResponse;	/* onvif.h:2525 */
class _trt__GetAudioSourceConfigurations;	/* onvif.h:2528 */
class _trt__GetAudioSourceConfigurationsResponse;	/* onvif.h:2531 */
class _trt__GetVideoAnalyticsConfigurations;	/* onvif.h:2534 */
class _trt__GetVideoAnalyticsConfigurationsResponse;	/* onvif.h:2537 */
class _trt__GetMetadataConfigurations;	/* onvif.h:2540 */
class _trt__GetMetadataConfigurationsResponse;	/* onvif.h:2543 */
class _trt__GetAudioOutputConfigurations;	/* onvif.h:2546 */
class _trt__GetAudioOutputConfigurationsResponse;	/* onvif.h:2549 */
class _trt__GetAudioDecoderConfigurations;	/* onvif.h:2552 */
class _trt__GetAudioDecoderConfigurationsResponse;	/* onvif.h:2555 */
class _trt__GetVideoSourceConfiguration;	/* onvif.h:2558 */
class _trt__GetVideoSourceConfigurationResponse;	/* onvif.h:2561 */
class _trt__GetVideoEncoderConfiguration;	/* onvif.h:2564 */
class _trt__GetVideoEncoderConfigurationResponse;	/* onvif.h:2567 */
class _trt__GetAudioSourceConfiguration;	/* onvif.h:2570 */
class _trt__GetAudioSourceConfigurationResponse;	/* onvif.h:2573 */
class _trt__GetAudioEncoderConfiguration;	/* onvif.h:2576 */
class _trt__GetAudioEncoderConfigurationResponse;	/* onvif.h:2579 */
class _trt__GetVideoAnalyticsConfiguration;	/* onvif.h:2582 */
class _trt__GetVideoAnalyticsConfigurationResponse;	/* onvif.h:2585 */
class _trt__GetMetadataConfiguration;	/* onvif.h:2588 */
class _trt__GetMetadataConfigurationResponse;	/* onvif.h:2591 */
class _trt__GetAudioOutputConfiguration;	/* onvif.h:2594 */
class _trt__GetAudioOutputConfigurationResponse;	/* onvif.h:2597 */
class _trt__GetAudioDecoderConfiguration;	/* onvif.h:2600 */
class _trt__GetAudioDecoderConfigurationResponse;	/* onvif.h:2603 */
class _trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:2606 */
class _trt__GetCompatibleVideoEncoderConfigurationsResponse;	/* onvif.h:2609 */
class _trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:2612 */
class _trt__GetCompatibleVideoSourceConfigurationsResponse;	/* onvif.h:2615 */
class _trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:2618 */
class _trt__GetCompatibleAudioEncoderConfigurationsResponse;	/* onvif.h:2621 */
class _trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:2624 */
class _trt__GetCompatibleAudioSourceConfigurationsResponse;	/* onvif.h:2627 */
class _trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:2630 */
class _trt__GetCompatibleVideoAnalyticsConfigurationsResponse;	/* onvif.h:2633 */
class _trt__GetCompatibleMetadataConfigurations;	/* onvif.h:2636 */
class _trt__GetCompatibleMetadataConfigurationsResponse;	/* onvif.h:2639 */
class _trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:2642 */
class _trt__GetCompatibleAudioOutputConfigurationsResponse;	/* onvif.h:2645 */
class _trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:2648 */
class _trt__GetCompatibleAudioDecoderConfigurationsResponse;	/* onvif.h:2651 */
class _trt__SetVideoEncoderConfiguration;	/* onvif.h:2654 */
class _trt__SetVideoEncoderConfigurationResponse;	/* onvif.h:2657 */
class _trt__SetVideoSourceConfiguration;	/* onvif.h:2660 */
class _trt__SetVideoSourceConfigurationResponse;	/* onvif.h:2663 */
class _trt__SetAudioEncoderConfiguration;	/* onvif.h:2666 */
class _trt__SetAudioEncoderConfigurationResponse;	/* onvif.h:2669 */
class _trt__SetAudioSourceConfiguration;	/* onvif.h:2672 */
class _trt__SetAudioSourceConfigurationResponse;	/* onvif.h:2675 */
class _trt__SetVideoAnalyticsConfiguration;	/* onvif.h:2678 */
class _trt__SetVideoAnalyticsConfigurationResponse;	/* onvif.h:2681 */
class _trt__SetMetadataConfiguration;	/* onvif.h:2684 */
class _trt__SetMetadataConfigurationResponse;	/* onvif.h:2687 */
class _trt__SetAudioOutputConfiguration;	/* onvif.h:2690 */
class _trt__SetAudioOutputConfigurationResponse;	/* onvif.h:2693 */
class _trt__SetAudioDecoderConfiguration;	/* onvif.h:2696 */
class _trt__SetAudioDecoderConfigurationResponse;	/* onvif.h:2699 */
class _trt__GetVideoSourceConfigurationOptions;	/* onvif.h:2702 */
class _trt__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:2705 */
class _trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:2708 */
class _trt__GetVideoEncoderConfigurationOptionsResponse;	/* onvif.h:2711 */
class _trt__GetAudioSourceConfigurationOptions;	/* onvif.h:2714 */
class _trt__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:2717 */
class _trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:2720 */
class _trt__GetAudioEncoderConfigurationOptionsResponse;	/* onvif.h:2723 */
class _trt__GetMetadataConfigurationOptions;	/* onvif.h:2726 */
class _trt__GetMetadataConfigurationOptionsResponse;	/* onvif.h:2729 */
class _trt__GetAudioOutputConfigurationOptions;	/* onvif.h:2732 */
class _trt__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:2735 */
class _trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:2738 */
class _trt__GetAudioDecoderConfigurationOptionsResponse;	/* onvif.h:2741 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:2744 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse;	/* onvif.h:2747 */
class _trt__GetStreamUri;	/* onvif.h:2750 */
class _trt__GetStreamUriResponse;	/* onvif.h:2753 */
class _trt__StartMulticastStreaming;	/* onvif.h:2756 */
class _trt__StartMulticastStreamingResponse;	/* onvif.h:2759 */
class _trt__StopMulticastStreaming;	/* onvif.h:2762 */
class _trt__StopMulticastStreamingResponse;	/* onvif.h:2765 */
class _trt__SetSynchronizationPoint;	/* onvif.h:2768 */
class _trt__SetSynchronizationPointResponse;	/* onvif.h:2771 */
class _trt__GetSnapshotUri;	/* onvif.h:2774 */
class _trt__GetSnapshotUriResponse;	/* onvif.h:2777 */
class _trt__GetVideoSourceModes;	/* onvif.h:2780 */
class _trt__GetVideoSourceModesResponse;	/* onvif.h:2783 */
class _trt__SetVideoSourceMode;	/* onvif.h:2786 */
class _trt__SetVideoSourceModeResponse;	/* onvif.h:2789 */
class _trt__GetOSDs;	/* onvif.h:2792 */
class _trt__GetOSDsResponse;	/* onvif.h:2795 */
class _trt__GetOSD;	/* onvif.h:2798 */
class _trt__GetOSDResponse;	/* onvif.h:2801 */
class _trt__SetOSD;	/* onvif.h:2804 */
class _trt__SetOSDResponse;	/* onvif.h:2807 */
class _trt__GetOSDOptions;	/* onvif.h:2810 */
class _trt__GetOSDOptionsResponse;	/* onvif.h:2813 */
class _trt__CreateOSD;	/* onvif.h:2816 */
class _trt__CreateOSDResponse;	/* onvif.h:2819 */
class _trt__DeleteOSD;	/* onvif.h:2822 */
class _trt__DeleteOSDResponse;	/* onvif.h:2825 */
class tds__StorageConfiguration;	/* onvif.h:245 */
class tt__VideoSource;	/* onvif.h:815 */
class tt__AudioSource;	/* onvif.h:824 */
class tt__VideoSourceConfiguration;	/* onvif.h:839 */
class tt__VideoEncoderConfiguration;	/* onvif.h:881 */
class tt__JpegOptions2;	/* onvif.h:908 */
class tt__Mpeg4Options2;	/* onvif.h:914 */
class tt__H264Options2;	/* onvif.h:920 */
class tt__VideoEncoder2Configuration;	/* onvif.h:923 */
class tt__AudioSourceConfiguration;	/* onvif.h:935 */
class tt__AudioEncoderConfiguration;	/* onvif.h:944 */
class tt__AudioEncoder2Configuration;	/* onvif.h:953 */
class tt__VideoAnalyticsConfiguration;	/* onvif.h:959 */
class tt__MetadataConfiguration;	/* onvif.h:962 */
class tt__VideoOutput;	/* onvif.h:989 */
class tt__VideoOutputConfiguration;	/* onvif.h:995 */
class tt__AudioOutput;	/* onvif.h:1016 */
class tt__AudioOutputConfiguration;	/* onvif.h:1019 */
class tt__AudioDecoderConfiguration;	/* onvif.h:1025 */
class tt__NetworkInterface;	/* onvif.h:1058 */
class tt__CertificateUsage;	/* onvif.h:1370 */
class tt__RelayOutput;	/* onvif.h:1397 */
class tt__DigitalInput;	/* onvif.h:1400 */
class tt__PTZNode;	/* onvif.h:1403 */
class tt__PTZConfiguration;	/* onvif.h:1418 */
class tt__EventFilter;	/* onvif.h:1871 */
class tt__AnalyticsEngine;	/* onvif.h:1979 */
class tt__AnalyticsEngineInput;	/* onvif.h:1997 */
class tt__AnalyticsEngineControl;	/* onvif.h:2012 */
class tt__OSDConfiguration;	/* onvif.h:2093 */
class wsnt__SubscribeCreationFailedFaultType;	/* onvif.h:2192 */
class wsnt__InvalidFilterFaultType;	/* onvif.h:2195 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* onvif.h:2198 */
class wsnt__InvalidTopicExpressionFaultType;	/* onvif.h:2201 */
class wsnt__TopicNotSupportedFaultType;	/* onvif.h:2204 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* onvif.h:2207 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* onvif.h:2210 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* onvif.h:2213 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* onvif.h:2216 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* onvif.h:2219 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* onvif.h:2222 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* onvif.h:2225 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* onvif.h:2228 */
class wsnt__UnableToGetMessagesFaultType;	/* onvif.h:2231 */
class wsnt__UnableToDestroyPullPointFaultType;	/* onvif.h:2234 */
class wsnt__UnableToCreatePullPointFaultType;	/* onvif.h:2237 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* onvif.h:2240 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* onvif.h:2243 */
class wsnt__PauseFailedFaultType;	/* onvif.h:2246 */
class wsnt__ResumeFailedFaultType;	/* onvif.h:2249 */
class _wstop__TopicNamespaceType_Topic;	/* onvif.h:32359 */
class wstop__TopicNamespaceType;	/* onvif.h:2330 */
class wstop__TopicType;	/* onvif.h:2333 */
class wstop__TopicSetType;	/* onvif.h:2336 */
class tt__OSDReference;	/* onvif.h:2045 */
struct __tdn__Hello;	/* onvif.h:33300 */
struct __tdn__Bye;	/* onvif.h:33366 */
struct __tdn__Probe;	/* onvif.h:33432 */
struct __tds__GetServices;	/* onvif.h:33517 */
struct __tds__GetServiceCapabilities;	/* onvif.h:33585 */
struct __tds__GetDeviceInformation;	/* onvif.h:33652 */
struct __tds__SetSystemDateAndTime;	/* onvif.h:33724 */
struct __tds__GetSystemDateAndTime;	/* onvif.h:33796 */
struct __tds__SetSystemFactoryDefault;	/* onvif.h:33863 */
struct __tds__UpgradeSystemFirmware;	/* onvif.h:33936 */
struct __tds__SystemReboot;	/* onvif.h:34003 */
struct __tds__RestoreSystem;	/* onvif.h:34078 */
struct __tds__GetSystemBackup;	/* onvif.h:34152 */
struct __tds__GetSystemLog;	/* onvif.h:34220 */
struct __tds__GetSystemSupportInformation;	/* onvif.h:34287 */
struct __tds__GetScopes;	/* onvif.h:34358 */
struct __tds__SetScopes;	/* onvif.h:34433 */
struct __tds__AddScopes;	/* onvif.h:34504 */
struct __tds__RemoveScopes;	/* onvif.h:34577 */
struct __tds__GetDiscoveryMode;	/* onvif.h:34648 */
struct __tds__SetDiscoveryMode;	/* onvif.h:34720 */
struct __tds__GetRemoteDiscoveryMode;	/* onvif.h:34793 */
struct __tds__SetRemoteDiscoveryMode;	/* onvif.h:34866 */
struct __tds__GetDPAddresses;	/* onvif.h:34937 */
struct __tds__GetEndpointReference;	/* onvif.h:35010 */
struct __tds__GetRemoteUser;	/* onvif.h:35081 */
struct __tds__SetRemoteUser;	/* onvif.h:35151 */
struct __tds__GetUsers;	/* onvif.h:35222 */
struct __tds__CreateUsers;	/* onvif.h:35295 */
struct __tds__DeleteUsers;	/* onvif.h:35369 */
struct __tds__SetUser;	/* onvif.h:35441 */
struct __tds__GetWsdlUrl;	/* onvif.h:35515 */
struct __tds__GetCapabilities;	/* onvif.h:35591 */
struct __tds__SetDPAddresses;	/* onvif.h:35663 */
struct __tds__GetHostname;	/* onvif.h:35733 */
struct __tds__SetHostname;	/* onvif.h:35802 */
struct __tds__SetHostnameFromDHCP;	/* onvif.h:35869 */
struct __tds__GetDNS;	/* onvif.h:35938 */
struct __tds__SetDNS;	/* onvif.h:36007 */
struct __tds__GetNTP;	/* onvif.h:36077 */
struct __tds__SetNTP;	/* onvif.h:36147 */
struct __tds__GetDynamicDNS;	/* onvif.h:36218 */
struct __tds__SetDynamicDNS;	/* onvif.h:36289 */
struct __tds__GetNetworkInterfaces;	/* onvif.h:36360 */
struct __tds__SetNetworkInterfaces;	/* onvif.h:36431 */
struct __tds__GetNetworkProtocols;	/* onvif.h:36501 */
struct __tds__SetNetworkProtocols;	/* onvif.h:36571 */
struct __tds__GetNetworkDefaultGateway;	/* onvif.h:36641 */
struct __tds__SetNetworkDefaultGateway;	/* onvif.h:36710 */
struct __tds__GetZeroConfiguration;	/* onvif.h:36782 */
struct __tds__SetZeroConfiguration;	/* onvif.h:36850 */
struct __tds__GetIPAddressFilter;	/* onvif.h:36921 */
struct __tds__SetIPAddressFilter;	/* onvif.h:36994 */
struct __tds__AddIPAddressFilter;	/* onvif.h:37066 */
struct __tds__RemoveIPAddressFilter;	/* onvif.h:37138 */
struct __tds__GetAccessPolicy;	/* onvif.h:37219 */
struct __tds__SetAccessPolicy;	/* onvif.h:37291 */
struct __tds__CreateCertificate;	/* onvif.h:37362 */
struct __tds__GetCertificates;	/* onvif.h:37441 */
struct __tds__GetCertificatesStatus;	/* onvif.h:37511 */
struct __tds__SetCertificatesStatus;	/* onvif.h:37583 */
struct __tds__DeleteCertificates;	/* onvif.h:37658 */
struct __tds__GetPkcs10Request;	/* onvif.h:37735 */
struct __tds__LoadCertificates;	/* onvif.h:37816 */
struct __tds__GetClientCertificateMode;	/* onvif.h:37886 */
struct __tds__SetClientCertificateMode;	/* onvif.h:37956 */
struct __tds__GetRelayOutputs;	/* onvif.h:38023 */
struct __tds__SetRelayOutputSettings;	/* onvif.h:38091 */
struct __tds__SetRelayOutputState;	/* onvif.h:38159 */
struct __tds__SendAuxiliaryCommand;	/* onvif.h:38229 */
struct __tds__GetCACertificates;	/* onvif.h:38307 */
struct __tds__LoadCertificateWithPrivateKey;	/* onvif.h:38384 */
struct __tds__GetCertificateInformation;	/* onvif.h:38459 */
struct __tds__LoadCACertificates;	/* onvif.h:38531 */
struct __tds__CreateDot1XConfiguration;	/* onvif.h:38606 */
struct __tds__SetDot1XConfiguration;	/* onvif.h:38677 */
struct __tds__GetDot1XConfiguration;	/* onvif.h:38746 */
struct __tds__GetDot1XConfigurations;	/* onvif.h:38818 */
struct __tds__DeleteDot1XConfiguration;	/* onvif.h:38890 */
struct __tds__GetDot11Capabilities;	/* onvif.h:38958 */
struct __tds__GetDot11Status;	/* onvif.h:39027 */
struct __tds__ScanAvailableDot11Networks;	/* onvif.h:39096 */
struct __tds__GetSystemUris;	/* onvif.h:39165 */
struct __tds__StartFirmwareUpgrade;	/* onvif.h:39242 */
struct __tds__StartSystemRestore;	/* onvif.h:39319 */
struct __tds__GetStorageConfigurations;	/* onvif.h:39389 */
struct __tds__CreateStorageConfiguration;	/* onvif.h:39460 */
struct __tds__GetStorageConfiguration;	/* onvif.h:39530 */
struct __tds__SetStorageConfiguration;	/* onvif.h:39599 */
struct __tds__DeleteStorageConfiguration;	/* onvif.h:39669 */
struct __tds__GetGeoLocation;	/* onvif.h:39739 */
struct __tds__SetGeoLocation;	/* onvif.h:39809 */
struct __tds__DeleteGeoLocation;	/* onvif.h:39878 */
struct __trt__GetServiceCapabilities;	/* onvif.h:39964 */
struct __trt__GetVideoSources;	/* onvif.h:40031 */
struct __trt__GetAudioSources;	/* onvif.h:40098 */
struct __trt__GetAudioOutputs;	/* onvif.h:40165 */
struct __trt__CreateProfile;	/* onvif.h:40236 */
struct __trt__GetProfile;	/* onvif.h:40304 */
struct __trt__GetProfiles;	/* onvif.h:40376 */
struct __trt__AddVideoEncoderConfiguration;	/* onvif.h:40450 */
struct __trt__AddVideoSourceConfiguration;	/* onvif.h:40520 */
struct __trt__AddAudioEncoderConfiguration;	/* onvif.h:40594 */
struct __trt__AddAudioSourceConfiguration;	/* onvif.h:40664 */
struct __trt__AddPTZConfiguration;	/* onvif.h:40738 */
struct __trt__AddVideoAnalyticsConfiguration;	/* onvif.h:40815 */
struct __trt__AddMetadataConfiguration;	/* onvif.h:40886 */
struct __trt__AddAudioOutputConfiguration;	/* onvif.h:40955 */
struct __trt__AddAudioDecoderConfiguration;	/* onvif.h:41024 */
struct __trt__RemoveVideoEncoderConfiguration;	/* onvif.h:41094 */
struct __trt__RemoveVideoSourceConfiguration;	/* onvif.h:41166 */
struct __trt__RemoveAudioEncoderConfiguration;	/* onvif.h:41237 */
struct __trt__RemoveAudioSourceConfiguration;	/* onvif.h:41310 */
struct __trt__RemovePTZConfiguration;	/* onvif.h:41380 */
struct __trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:41450 */
struct __trt__RemoveMetadataConfiguration;	/* onvif.h:41519 */
struct __trt__RemoveAudioOutputConfiguration;	/* onvif.h:41588 */
struct __trt__RemoveAudioDecoderConfiguration;	/* onvif.h:41657 */
struct __trt__DeleteProfile;	/* onvif.h:41725 */
struct __trt__GetVideoSourceConfigurations;	/* onvif.h:41794 */
struct __trt__GetVideoEncoderConfigurations;	/* onvif.h:41864 */
struct __trt__GetAudioSourceConfigurations;	/* onvif.h:41934 */
struct __trt__GetAudioEncoderConfigurations;	/* onvif.h:42003 */
struct __trt__GetVideoAnalyticsConfigurations;	/* onvif.h:42072 */
struct __trt__GetMetadataConfigurations;	/* onvif.h:42140 */
struct __trt__GetAudioOutputConfigurations;	/* onvif.h:42208 */
struct __trt__GetAudioDecoderConfigurations;	/* onvif.h:42278 */
struct __trt__GetVideoSourceConfiguration;	/* onvif.h:42346 */
struct __trt__GetVideoEncoderConfiguration;	/* onvif.h:42414 */
struct __trt__GetAudioSourceConfiguration;	/* onvif.h:42482 */
struct __trt__GetAudioEncoderConfiguration;	/* onvif.h:42550 */
struct __trt__GetVideoAnalyticsConfiguration;	/* onvif.h:42618 */
struct __trt__GetMetadataConfiguration;	/* onvif.h:42686 */
struct __trt__GetAudioOutputConfiguration;	/* onvif.h:42754 */
struct __trt__GetAudioDecoderConfiguration;	/* onvif.h:42822 */
struct __trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:42893 */
struct __trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:42966 */
struct __trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:43037 */
struct __trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:43108 */
struct __trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:43179 */
struct __trt__GetCompatibleMetadataConfigurations;	/* onvif.h:43250 */
struct __trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:43320 */
struct __trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:43390 */
struct __trt__SetVideoSourceConfiguration;	/* onvif.h:43462 */
struct __trt__SetVideoEncoderConfiguration;	/* onvif.h:43535 */
struct __trt__SetAudioSourceConfiguration;	/* onvif.h:43609 */
struct __trt__SetAudioEncoderConfiguration;	/* onvif.h:43684 */
struct __trt__SetVideoAnalyticsConfiguration;	/* onvif.h:43761 */
struct __trt__SetMetadataConfiguration;	/* onvif.h:43837 */
struct __trt__SetAudioOutputConfiguration;	/* onvif.h:43906 */
struct __trt__SetAudioDecoderConfiguration;	/* onvif.h:43975 */
struct __trt__GetVideoSourceConfigurationOptions;	/* onvif.h:44048 */
struct __trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:44118 */
struct __trt__GetAudioSourceConfigurationOptions;	/* onvif.h:44191 */
struct __trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:44260 */
struct __trt__GetMetadataConfigurationOptions;	/* onvif.h:44328 */
struct __trt__GetAudioOutputConfigurationOptions;	/* onvif.h:44396 */
struct __trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:44465 */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:44534 */
struct __trt__GetStreamUri;	/* onvif.h:44607 */
struct __trt__StartMulticastStreaming;	/* onvif.h:44681 */
struct __trt__StopMulticastStreaming;	/* onvif.h:44748 */
struct __trt__SetSynchronizationPoint;	/* onvif.h:44832 */
struct __trt__GetSnapshotUri;	/* onvif.h:44909 */
struct __trt__GetVideoSourceModes;	/* onvif.h:44978 */
struct __trt__SetVideoSourceMode;	/* onvif.h:45048 */
struct __trt__GetOSDs;	/* onvif.h:45115 */
struct __trt__GetOSD;	/* onvif.h:45182 */
struct __trt__GetOSDOptions;	/* onvif.h:45249 */
struct __trt__SetOSD;	/* onvif.h:45316 */
struct __trt__CreateOSD;	/* onvif.h:45383 */
struct __trt__DeleteOSD;	/* onvif.h:45450 */

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (8)
/* wsu:Timestamp complex type: */
struct _wsu__Timestamp
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Created;	/* optional element of XSD type xsd:string */
	char *Expires;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 8; } /* = unique type id SOAP_TYPE__wsu__Timestamp */
	         _wsu__Timestamp();
	friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:114 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (10)
/* wsse:UsernameToken complex type: */
struct _wsse__UsernameToken
{
public:
	char *Username;	/* optional element of XSD type xsd:string */
	struct _wsse__Password *Password;	/* optional element of XSD type wsse:Password */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Created;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 10; } /* = unique type id SOAP_TYPE__wsse__UsernameToken */
	         _wsse__UsernameToken();
	friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:125 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (13)
/* wsse:BinarySecurityToken simple type: */
struct _wsse__BinarySecurityToken
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 13; } /* = unique type id SOAP_TYPE__wsse__BinarySecurityToken */
	         _wsse__BinarySecurityToken();
	friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:135 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (14)
/* wsse:Reference complex type: */
struct _wsse__Reference
{
public:
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__wsse__Reference */
	         _wsse__Reference();
	friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:143 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (15)
/* wsse:Embedded complex type: */
struct _wsse__Embedded
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__wsse__Embedded */
	         _wsse__Embedded();
	friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:152 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (16)
/* wsse:KeyIdentifier simple type: */
struct _wsse__KeyIdentifier
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__wsse__KeyIdentifier */
	         _wsse__KeyIdentifier();
	friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:162 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (17)
/* wsse:SecurityTokenReference complex type: */
struct _wsse__SecurityTokenReference
{
public:
	struct _wsse__Reference *Reference;	/* optional element of XSD type wsse:Reference */
	struct _wsse__KeyIdentifier *KeyIdentifier;	/* optional element of XSD type wsse:KeyIdentifier */
	struct _wsse__Embedded *Embedded;	/* optional element of XSD type wsse:Embedded */
	struct ds__X509DataType *ds__X509Data;	/* optional element of XSD type ds:X509DataType */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *wsc__Instance;	/* optional attribute of XSD type xsd:string */
	char *Usage;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__wsse__SecurityTokenReference */
	         _wsse__SecurityTokenReference();
	friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (23)
/* ds:SignatureType complex type: */
struct ds__SignatureType
{
public:
	struct ds__SignedInfoType *SignedInfo;	/* optional element of XSD type ds:SignedInfoType */
	char *SignatureValue;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *KeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_ds__SignatureType */
	         ds__SignatureType();
	friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (33)
/* c14n:InclusiveNamespaces complex type: */
struct _c14n__InclusiveNamespaces
{
public:
	char *PrefixList;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 33; } /* = unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
	         _c14n__InclusiveNamespaces();
	friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:74 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (34)
/* ds:TransformType complex type: */
struct ds__TransformType
{
public:
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
	char *__any;
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_ds__TransformType */
	         ds__TransformType();
	friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:49 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (26)
/* ds:KeyInfoType complex type: */
struct ds__KeyInfoType
{
public:
	char *KeyName;	/* optional element of XSD type xsd:string */
	struct ds__KeyValueType *KeyValue;	/* optional element of XSD type ds:KeyValueType */
	struct ds__RetrievalMethodType *RetrievalMethod;	/* optional element of XSD type ds:RetrievalMethodType */
	struct ds__X509DataType *X509Data;	/* optional element of XSD type ds:X509DataType */
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_ds__KeyInfoType */
	         ds__KeyInfoType();
	friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (24)
/* ds:SignedInfoType complex type: */
struct ds__SignedInfoType
{
public:
	struct ds__CanonicalizationMethodType *CanonicalizationMethod;	/* required element of XSD type ds:CanonicalizationMethodType */
	struct ds__SignatureMethodType *SignatureMethod;	/* required element of XSD type ds:SignatureMethodType */
	int __sizeReference;	/* sequence of elements <Reference> of XSD type ds:ReferenceType */
	struct ds__ReferenceType **Reference;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_ds__SignedInfoType */
	         ds__SignedInfoType();
	friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:60 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (29)
/* ds:CanonicalizationMethodType complex type: */
struct ds__CanonicalizationMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
public:
	int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
	         ds__CanonicalizationMethodType();
	friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:63 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (30)
/* ds:SignatureMethodType complex type: */
struct ds__SignatureMethodType
{
public:
	int *HMACOutputLength;	/* optional element of XSD type xsd:int */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_ds__SignatureMethodType */
	         ds__SignatureMethodType();
	friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:66 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (31)
/* ds:ReferenceType complex type: */
struct ds__ReferenceType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	struct ds__DigestMethodType *DigestMethod;	/* required element of XSD type ds:DigestMethodType */
	char *DigestValue;	/* required element of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_ds__ReferenceType */
	         ds__ReferenceType();
	friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:69 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (32)
/* ds:TransformsType complex type: */
struct ds__TransformsType
{
public:
	int __sizeTransform;	/* sequence of elements <Transform> of XSD type ds:TransformType */
	struct ds__TransformType *Transform;
public:
	int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_ds__TransformsType */
	         ds__TransformsType();
	friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:80 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (37)
/* ds:DigestMethodType complex type: */
struct ds__DigestMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_ds__DigestMethodType */
	         ds__DigestMethodType();
	friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:86 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (38)
/* ds:KeyValueType complex type: */
struct ds__KeyValueType
{
public:
	struct ds__DSAKeyValueType *DSAKeyValue;	/* optional element of XSD type ds:DSAKeyValueType */
	struct ds__RSAKeyValueType *RSAKeyValue;	/* optional element of XSD type ds:RSAKeyValueType */
public:
	int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_ds__KeyValueType */
	         ds__KeyValueType();
	friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:87 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (40)
/* ds:RetrievalMethodType complex type: */
struct ds__RetrievalMethodType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 40; } /* = unique type id SOAP_TYPE_ds__RetrievalMethodType */
	         ds__RetrievalMethodType();
	friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:165 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (21)
/* ds:X509DataType complex type: */
struct ds__X509DataType
{
public:
	struct ds__X509IssuerSerialType *X509IssuerSerial;	/* optional element of XSD type ds:X509IssuerSerialType */
	char *X509SKI;	/* optional element of XSD type xsd:string */
	char *X509SubjectName;	/* optional element of XSD type xsd:string */
	char *X509Certificate;	/* optional element of XSD type xsd:string */
	char *X509CRL;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 21; } /* = unique type id SOAP_TYPE_ds__X509DataType */
	         ds__X509DataType();
	friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:103 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (44)
/* ds:X509IssuerSerialType complex type: */
struct ds__X509IssuerSerialType
{
public:
	char *X509IssuerName;	/* required element of XSD type xsd:string */
	char *X509SerialNumber;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_ds__X509IssuerSerialType */
	         ds__X509IssuerSerialType();
	friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:124 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (45)
/* ds:DSAKeyValueType complex type: */
struct ds__DSAKeyValueType
{
public:
	char *G;	/* optional element of XSD type xsd:string */
	char *Y;	/* required element of XSD type xsd:string */
	char *J;	/* optional element of XSD type xsd:string */
	char *P;	/* required element of XSD type xsd:string */
	char *Q;	/* required element of XSD type xsd:string */
	char *Seed;	/* required element of XSD type xsd:string */
	char *PgenCounter;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ds__DSAKeyValueType */
	         ds__DSAKeyValueType();
	friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:127 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (46)
/* ds:RSAKeyValueType complex type: */
struct ds__RSAKeyValueType
{
public:
	char *Modulus;	/* required element of XSD type xsd:string */
	char *Exponent;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_ds__RSAKeyValueType */
	         ds__RSAKeyValueType();
	friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (68)
/* xenc:EncryptionPropertyType complex type: */
struct xenc__EncryptionPropertyType
{
public:
	char *Target;	/* optional attribute of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
	         xenc__EncryptionPropertyType();
	friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (58)
/* xenc:EncryptedType complex type: */
struct xenc__EncryptedType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_xenc__EncryptedType */
	         xenc__EncryptedType();
	friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (59)
/* xenc:EncryptionMethodType complex type: */
struct xenc__EncryptionMethodType
{
public:
	int *KeySize;	/* optional element of XSD type xsd:int */
	char *OAEPparams;	/* optional element of XSD type xsd:string */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct ds__DigestMethodType *ds__DigestMethod;	/* optional element of XSD type ds:DigestMethodType */
	char *__mixed;
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_xenc__EncryptionMethodType */
	         xenc__EncryptionMethodType();
	friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (60)
/* xenc:CipherDataType complex type: */
struct xenc__CipherDataType
{
public:
	char *CipherValue;	/* optional element of XSD type xsd:string */
	struct xenc__CipherReferenceType *CipherReference;	/* optional element of XSD type xenc:CipherReferenceType */
public:
	int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_xenc__CipherDataType */
	         xenc__CipherDataType();
	friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (61)
/* xenc:CipherReferenceType complex type: */
struct xenc__CipherReferenceType
{
public:
	struct xenc__TransformsType *Transforms;	/* optional element of XSD type xenc:TransformsType */
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_xenc__CipherReferenceType */
	         xenc__CipherReferenceType();
	friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (62)
/* xenc:TransformsType complex type: */
struct xenc__TransformsType
{
public:
	struct ds__TransformType ds__Transform;	/* required element of XSD type ds:Transform */
public:
	int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_xenc__TransformsType */
	         xenc__TransformsType();
	friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (65)
/* xenc:AgreementMethodType complex type: */
struct xenc__AgreementMethodType
{
public:
	char *KA_Nonce;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *OriginatorKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	struct ds__KeyInfoType *RecipientKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	char *__mixed;
public:
	int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_xenc__AgreementMethodType */
	         xenc__AgreementMethodType();
	friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (66)
/* xenc:ReferenceType complex type: */
struct xenc__ReferenceType
{
public:
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_xenc__ReferenceType */
	         xenc__ReferenceType();
	friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (67)
/* xenc:EncryptionPropertiesType complex type: */
struct xenc__EncryptionPropertiesType
{
public:
	int __sizeEncryptionProperty;	/* sequence of elements <EncryptionProperty> of XSD type xenc:EncryptionPropertyType */
	struct xenc__EncryptionPropertyType *EncryptionProperty;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
	         xenc__EncryptionPropertiesType();
	friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (77)
/* Operation wrapper: */
struct __xenc__union_ReferenceList
{
public:
	struct xenc__ReferenceType *DataReference;	/* optional element of XSD type xenc:ReferenceType */
	struct xenc__ReferenceType *KeyReference;	/* optional element of XSD type xenc:ReferenceType */
public:
	int soap_type() const { return 77; } /* = unique type id SOAP_TYPE___xenc__union_ReferenceList */
	         __xenc__union_ReferenceList();
	friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (69)
/* xenc:ReferenceList complex type: */
struct _xenc__ReferenceList
{
public:
	int __size_ReferenceList;	/* sequence of elements <-union-ReferenceList> of XSD type -xenc:union-ReferenceList */
	struct __xenc__union_ReferenceList *__union_ReferenceList;
public:
	int soap_type() const { return 69; } /* = unique type id SOAP_TYPE__xenc__ReferenceList */
	         _xenc__ReferenceList();
	friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (63)
/* xenc:EncryptedDataType complex type: */
struct xenc__EncryptedDataType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_xenc__EncryptedDataType */
	         xenc__EncryptedDataType();
	friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (64)
/* xenc:EncryptedKeyType complex type: */
struct xenc__EncryptedKeyType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
	struct _xenc__ReferenceList *ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	char *CarriedKeyName;	/* optional element of XSD type xsd:string */
	char *Recipient;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_xenc__EncryptedKeyType */
	         xenc__EncryptedKeyType();
	friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (83)
/* wsc:SecurityContextTokenType complex type: */
struct wsc__SecurityContextTokenType
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Identifier;	/* optional element of XSD type xsd:string */
	char *Instance;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
	         wsc__SecurityContextTokenType();
	friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (89)
/* xsd:choice complex type: */
union _wsc__union_DerivedKeyTokenType
{
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)
	ULONG64 Generation;
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)
	ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (87)
/* Operation wrapper: */
struct __wsc__DerivedKeyTokenType_sequence
{
public:
	int __union_DerivedKeyTokenType;	/* union discriminant (of union defined below) */
	union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
	ULONG64 *Length;	/* optional element of XSD type xsd:unsignedLong */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
	         __wsc__DerivedKeyTokenType_sequence();
	friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (84)
/* wsc:DerivedKeyTokenType complex type: */
struct wsc__DerivedKeyTokenType
{
public:
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	struct wsc__PropertiesType *Properties;	/* optional element of XSD type wsc:PropertiesType */
	struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
	char *Label;	/* optional element of XSD type xsd:string */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
	         wsc__DerivedKeyTokenType();
	friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (85)
/* wsc:PropertiesType complex type: */
struct wsc__PropertiesType
{
public:
	int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_wsc__PropertiesType */
	         wsc__PropertiesType();
	friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:177 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (92)
/* wsse:Security complex type: */
struct _wsse__Security
{
public:
	struct _wsu__Timestamp *wsu__Timestamp;	/* optional element of XSD type wsu:Timestamp */
	struct _wsse__UsernameToken *UsernameToken;	/* optional element of XSD type wsse:UsernameToken */
	struct _wsse__BinarySecurityToken *BinarySecurityToken;	/* optional element of XSD type wsse:BinarySecurityToken */
	struct xenc__EncryptedKeyType *xenc__EncryptedKey;	/* optional element of XSD type xenc:EncryptedKeyType */
	struct _xenc__ReferenceList *xenc__ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;	/* optional element of XSD type wsc:SecurityContextTokenType */
	struct ds__SignatureType *ds__Signature;	/* optional element of XSD type ds:SignatureType */
	char *SOAP_ENV__actor;	/* optional attribute of XSD type xsd:string */
	char *SOAP_ENV__role;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 92; } /* = unique type id SOAP_TYPE__wsse__Security */
	         _wsse__Security();
	friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:115 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (11)
/* wsse:Password simple type: */
struct _wsse__Password
{
public:
	char *__item;	/* mixed XML content */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__wsse__Password */
	         _wsse__Password();
	friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (99)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	struct _wsse__Security *wsse__Security;	/* mustUnderstand */
	char *wsa__MessageID;	/* optional element of XSD type wsa:MessageID */
	struct wsa__Relationship *wsa__RelatesTo;	/* optional element of XSD type wsa:RelatesTo */
	struct wsa__EndpointReferenceType *wsa__From;	/* optional element of XSD type wsa:From */
	struct wsa__EndpointReferenceType *wsa__ReplyTo;	/* mustUnderstand */
	struct wsa__EndpointReferenceType *wsa__FaultTo;	/* mustUnderstand */
	char *wsa__To;	/* mustUnderstand */
	char *wsa__Action;	/* mustUnderstand */
	struct wsdd__AppSequenceType *wsdd__AppSequence;	/* optional element of XSD type wsdd:AppSequenceType */
	char *wsa5__MessageID;	/* optional element of XSD type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of XSD type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of XSD type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct chan__ChannelInstanceType *chan__ChannelInstance;	/* optional element of XSD type chan:ChannelInstanceType */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:94 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (101)
/* wsa:EndpointReferenceType complex type: */
struct wsa__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa__ReferencePropertiesType *ReferenceProperties;	/* optional element of XSD type wsa:ReferencePropertiesType */
	struct wsa__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa:ReferenceParametersType */
	char **PortType;	/* optional element of XSD type xsd:QName */
	struct wsa__ServiceNameType *ServiceName;	/* optional element of XSD type wsa:ServiceNameType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 101; } /* = unique type id SOAP_TYPE_wsa__EndpointReferenceType */
	         wsa__EndpointReferenceType();
	friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:97 */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (102)
/* wsa:ReferencePropertiesType complex type: */
struct wsa__ReferencePropertiesType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 102; } /* = unique type id SOAP_TYPE_wsa__ReferencePropertiesType */
	         wsa__ReferencePropertiesType();
	friend SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:100 */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (103)
/* wsa:ReferenceParametersType complex type: */
struct wsa__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE_wsa__ReferenceParametersType */
	         wsa__ReferenceParametersType();
	friend SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:103 */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (104)
/* wsa:ServiceNameType simple type: */
struct wsa__ServiceNameType
{
public:
	char *__item;	/* mixed XML content */
	char *PortName;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 104; } /* = unique type id SOAP_TYPE_wsa__ServiceNameType */
	         wsa__ServiceNameType();
	friend SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:106 */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (105)
/* wsa:Relationship simple type: */
struct wsa__Relationship
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 105; } /* = unique type id SOAP_TYPE_wsa__Relationship */
	         wsa__Relationship();
	friend SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (127)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:267 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (129)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 129; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (131)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:273 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (135)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsdd10.h:57 */
#ifndef SOAP_TYPE_wsdd__HelloType
#define SOAP_TYPE_wsdd__HelloType (136)
/* wsdd:HelloType complex type: */
struct wsdd__HelloType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 136; } /* = unique type id SOAP_TYPE_wsdd__HelloType */
	         wsdd__HelloType();
	friend SOAP_FMAC1 wsdd__HelloType * SOAP_FMAC2 soap_instantiate_wsdd__HelloType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:60 */
#ifndef SOAP_TYPE_wsdd__ByeType
#define SOAP_TYPE_wsdd__ByeType (137)
/* wsdd:ByeType complex type: */
struct wsdd__ByeType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int *MetadataVersion;	/* optional element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 137; } /* = unique type id SOAP_TYPE_wsdd__ByeType */
	         wsdd__ByeType();
	friend SOAP_FMAC1 wsdd__ByeType * SOAP_FMAC2 soap_instantiate_wsdd__ByeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:63 */
#ifndef SOAP_TYPE_wsdd__ProbeType
#define SOAP_TYPE_wsdd__ProbeType (138)
/* wsdd:ProbeType complex type: */
struct wsdd__ProbeType
{
public:
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
public:
	int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_wsdd__ProbeType */
	         wsdd__ProbeType();
	friend SOAP_FMAC1 wsdd__ProbeType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:66 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchesType
#define SOAP_TYPE_wsdd__ProbeMatchesType (139)
/* wsdd:ProbeMatchesType complex type: */
struct wsdd__ProbeMatchesType
{
public:
	int __sizeProbeMatch;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ProbeMatch> of XSD type wsdd:ProbeMatchType */
	struct wsdd__ProbeMatchType *ProbeMatch;
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchesType */
	         wsdd__ProbeMatchesType();
	friend SOAP_FMAC1 wsdd__ProbeMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:69 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchType
#define SOAP_TYPE_wsdd__ProbeMatchType (140)
/* wsdd:ProbeMatchType complex type: */
struct wsdd__ProbeMatchType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 140; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchType */
	         wsdd__ProbeMatchType();
	friend SOAP_FMAC1 wsdd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:72 */
#ifndef SOAP_TYPE_wsdd__ResolveType
#define SOAP_TYPE_wsdd__ResolveType (141)
/* wsdd:ResolveType complex type: */
struct wsdd__ResolveType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa:EndpointReference */
public:
	int soap_type() const { return 141; } /* = unique type id SOAP_TYPE_wsdd__ResolveType */
	         wsdd__ResolveType();
	friend SOAP_FMAC1 wsdd__ResolveType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:75 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchesType
#define SOAP_TYPE_wsdd__ResolveMatchesType (142)
/* wsdd:ResolveMatchesType complex type: */
struct wsdd__ResolveMatchesType
{
public:
	struct wsdd__ResolveMatchType *ResolveMatch;	/* optional element of XSD type wsdd:ResolveMatchType */
public:
	int soap_type() const { return 142; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchesType */
	         wsdd__ResolveMatchesType();
	friend SOAP_FMAC1 wsdd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:78 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchType
#define SOAP_TYPE_wsdd__ResolveMatchType (143)
/* wsdd:ResolveMatchType complex type: */
struct wsdd__ResolveMatchType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchType */
	         wsdd__ResolveMatchType();
	friend SOAP_FMAC1 wsdd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:84 */
#ifndef SOAP_TYPE_wsdd__SecurityType
#define SOAP_TYPE_wsdd__SecurityType (145)
/* wsdd:SecurityType complex type: */
struct wsdd__SecurityType
{
public:
	struct wsdd__SigType *Sig;	/* optional element of XSD type wsdd:SigType */
public:
	int soap_type() const { return 145; } /* = unique type id SOAP_TYPE_wsdd__SecurityType */
	         wsdd__SecurityType();
	friend SOAP_FMAC1 wsdd__SecurityType * SOAP_FMAC2 soap_instantiate_wsdd__SecurityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:87 */
#ifndef SOAP_TYPE_wsdd__SigType
#define SOAP_TYPE_wsdd__SigType (146)
/* wsdd:SigType complex type: */
struct wsdd__SigType
{
public:
	char *Scheme;	/* required attribute of XSD type xsd:string */
	char *KeyId;	/* optional attribute of XSD type xsd:string */
	char *Refs;	/* required attribute of XSD type xsd:string */
	char *Sig;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 146; } /* = unique type id SOAP_TYPE_wsdd__SigType */
	         wsdd__SigType();
	friend SOAP_FMAC1 wsdd__SigType * SOAP_FMAC2 soap_instantiate_wsdd__SigType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:81 */
#ifndef SOAP_TYPE_wsdd__ScopesType
#define SOAP_TYPE_wsdd__ScopesType (144)
/* wsdd:ScopesType simple type: */
struct wsdd__ScopesType
{
public:
	char *__item;	/* mixed XML content */
	char *MatchBy;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 144; } /* = unique type id SOAP_TYPE_wsdd__ScopesType */
	         wsdd__ScopesType();
	friend SOAP_FMAC1 wsdd__ScopesType * SOAP_FMAC2 soap_instantiate_wsdd__ScopesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:90 */
#ifndef SOAP_TYPE_wsdd__AppSequenceType
#define SOAP_TYPE_wsdd__AppSequenceType (147)
/* wsdd:AppSequenceType complex type: */
struct wsdd__AppSequenceType
{
public:
	unsigned int InstanceId;	/* required attribute of XSD type xsd:unsignedInt */
	char *SequenceId;	/* optional attribute of XSD type xsd:string */
	unsigned int MessageNumber;	/* required attribute of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE_wsdd__AppSequenceType */
	         wsdd__AppSequenceType();
	friend SOAP_FMAC1 wsdd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsdd__AppSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:67 */
#ifndef SOAP_TYPE___wsdd__Hello
#define SOAP_TYPE___wsdd__Hello (160)
/* Operation wrapper: */
struct __wsdd__Hello
{
public:
	struct wsdd__HelloType *wsdd__Hello;	/* optional element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 160; } /* = unique type id SOAP_TYPE___wsdd__Hello */
	         __wsdd__Hello();
	friend SOAP_FMAC1 __wsdd__Hello * SOAP_FMAC2 soap_instantiate___wsdd__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:76 */
#ifndef SOAP_TYPE___wsdd__Bye
#define SOAP_TYPE___wsdd__Bye (163)
/* Operation wrapper: */
struct __wsdd__Bye
{
public:
	struct wsdd__ByeType *wsdd__Bye;	/* optional element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 163; } /* = unique type id SOAP_TYPE___wsdd__Bye */
	         __wsdd__Bye();
	friend SOAP_FMAC1 __wsdd__Bye * SOAP_FMAC2 soap_instantiate___wsdd__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:85 */
#ifndef SOAP_TYPE___wsdd__Probe
#define SOAP_TYPE___wsdd__Probe (166)
/* Operation wrapper: */
struct __wsdd__Probe
{
public:
	struct wsdd__ProbeType *wsdd__Probe;	/* optional element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 166; } /* = unique type id SOAP_TYPE___wsdd__Probe */
	         __wsdd__Probe();
	friend SOAP_FMAC1 __wsdd__Probe * SOAP_FMAC2 soap_instantiate___wsdd__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:94 */
#ifndef SOAP_TYPE___wsdd__ProbeMatches
#define SOAP_TYPE___wsdd__ProbeMatches (169)
/* Operation wrapper: */
struct __wsdd__ProbeMatches
{
public:
	struct wsdd__ProbeMatchesType *wsdd__ProbeMatches;	/* optional element of XSD type wsdd:ProbeMatchesType */
public:
	int soap_type() const { return 169; } /* = unique type id SOAP_TYPE___wsdd__ProbeMatches */
	         __wsdd__ProbeMatches();
	friend SOAP_FMAC1 __wsdd__ProbeMatches * SOAP_FMAC2 soap_instantiate___wsdd__ProbeMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:103 */
#ifndef SOAP_TYPE___wsdd__Resolve
#define SOAP_TYPE___wsdd__Resolve (172)
/* Operation wrapper: */
struct __wsdd__Resolve
{
public:
	struct wsdd__ResolveType *wsdd__Resolve;	/* optional element of XSD type wsdd:ResolveType */
public:
	int soap_type() const { return 172; } /* = unique type id SOAP_TYPE___wsdd__Resolve */
	         __wsdd__Resolve();
	friend SOAP_FMAC1 __wsdd__Resolve * SOAP_FMAC2 soap_instantiate___wsdd__Resolve(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:112 */
#ifndef SOAP_TYPE___wsdd__ResolveMatches
#define SOAP_TYPE___wsdd__ResolveMatches (175)
/* Operation wrapper: */
struct __wsdd__ResolveMatches
{
public:
	struct wsdd__ResolveMatchesType *wsdd__ResolveMatches;	/* optional element of XSD type wsdd:ResolveMatchesType */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE___wsdd__ResolveMatches */
	         __wsdd__ResolveMatches();
	friend SOAP_FMAC1 __wsdd__ResolveMatches * SOAP_FMAC2 soap_instantiate___wsdd__ResolveMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xop.h:58 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (176)
/* base64Binary schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 176; } /* = unique type id SOAP_TYPE__xop__Include */
	         _xop__Include();
	friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:63 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (179)
/* wsa5:EndpointReferenceType complex type: */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of XSD type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 179; } /* = unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
	         wsa5__EndpointReferenceType();
	friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:66 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (180)
/* wsa5:ReferenceParametersType complex type: */
struct wsa5__ReferenceParametersType
{
public:
	int *chan__ChannelInstance;	/* optional element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 180; } /* = unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
	         wsa5__ReferenceParametersType();
	friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:69 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (181)
/* wsa5:MetadataType complex type: */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 181; } /* = unique type id SOAP_TYPE_wsa5__MetadataType */
	         wsa5__MetadataType();
	friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:84 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (183)
/* wsa5:ProblemActionType complex type: */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of XSD type xsd:string */
	char *SoapAction;	/* optional element of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 183; } /* = unique type id SOAP_TYPE_wsa5__ProblemActionType */
	         wsa5__ProblemActionType();
	friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:72 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (182)
/* wsa5:RelatesToType simple type: */
struct wsa5__RelatesToType
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 182; } /* = unique type id SOAP_TYPE_wsa5__RelatesToType */
	         wsa5__RelatesToType();
	friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:258 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (205)
/* chan:ChannelInstanceType simple type: */
struct chan__ChannelInstanceType
{
public:
	int __item;	/* mixed XML content */
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/* optional attribute of XSD type wsa5:IsReferenceParameter */
public:
	int soap_type() const { return 205; } /* = unique type id SOAP_TYPE_chan__ChannelInstanceType */
	         chan__ChannelInstanceType();
	friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:288 */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_alex
#define SOAP_TYPE_SOAP_ENV__Fault_alex (212)
/* SOAP-ENV:Fault-alex complex type: */
struct SOAP_ENV__Fault_alex
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 212; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault_alex */
	         SOAP_ENV__Fault_alex();
	friend SOAP_FMAC1 SOAP_ENV__Fault_alex * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault_alex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:170 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (213)
/* xsd:anyType simple type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyType (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
	virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
	friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:173 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (215)
/* SOAP-ENV:Envelope complex type: */
struct SOAP_ENV__Envelope
{
public:
	struct SOAP_ENV__Header *SOAP_ENV__Header;	/* optional element of XSD type SOAP-ENV:Header */
	char *SOAP_ENV__Body;	/* optional element of XSD type xsd:anyType */
public:
	int soap_type() const { return 215; } /* = unique type id SOAP_TYPE_SOAP_ENV__Envelope */
	         SOAP_ENV__Envelope();
	friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:176 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (217)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (217)
	virtual int soap_type(void) const { return 217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:187 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (222)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary (222)
	virtual int soap_type(void) const { return 222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
	virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
	friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4018 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1200)
/* tds:Service-Capabilities complex type: */
class SOAP_CMAC _tds__Service_Capabilities
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__Service_Capabilities (1200)
	virtual int soap_type(void) const { return 1200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
	virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__Service_Capabilities); }
	         _tds__Service_Capabilities() { _tds__Service_Capabilities::soap_default(NULL); }
	virtual ~_tds__Service_Capabilities() { }
	friend SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:221 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (230)
/* tds:Service complex type: */
class SOAP_CMAC tds__Service
{
public:
	char *Namespace;	/* required element of XSD type xsd:anyURI */
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	_tds__Service_Capabilities *Capabilities;	/* optional element of XSD type tds:Service-Capabilities */
	tt__OnvifVersion *Version;	/* required element of XSD type tt:OnvifVersion */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__Service (230)
	virtual int soap_type(void) const { return 230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__Service, default initialized and not managed by a soap context
	virtual tds__Service *soap_alloc(void) const { return SOAP_NEW(tds__Service); }
	         tds__Service() { tds__Service::soap_default(NULL); }
	virtual ~tds__Service() { }
	friend SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:224 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (231)
/* tds:DeviceServiceCapabilities complex type: */
class SOAP_CMAC tds__DeviceServiceCapabilities
{
public:
	tds__NetworkCapabilities *Network;	/* required element of XSD type tds:NetworkCapabilities */
	tds__SecurityCapabilities *Security;	/* required element of XSD type tds:SecurityCapabilities */
	tds__SystemCapabilities *System;	/* required element of XSD type tds:SystemCapabilities */
	tds__MiscCapabilities *Misc;	/* optional element of XSD type tds:MiscCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__DeviceServiceCapabilities (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
	virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__DeviceServiceCapabilities); }
	         tds__DeviceServiceCapabilities() { tds__DeviceServiceCapabilities::soap_default(NULL); }
	virtual ~tds__DeviceServiceCapabilities() { }
	friend SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:227 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (232)
/* tds:NetworkCapabilities complex type: */
class SOAP_CMAC tds__NetworkCapabilities
{
public:
	bool *IPFilter;	/* optional attribute of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional attribute of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional attribute of XSD type xsd:boolean */
	bool *DynDNS;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot11Configuration;	/* optional attribute of XSD type xsd:boolean */
	int *Dot1XConfigurations;	/* optional attribute of XSD type xsd:int */
	bool *HostnameFromDHCP;	/* optional attribute of XSD type xsd:boolean */
	int *NTP;	/* optional attribute of XSD type xsd:int */
	bool *DHCPv6;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__NetworkCapabilities (232)
	virtual int soap_type(void) const { return 232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__NetworkCapabilities); }
	         tds__NetworkCapabilities() { tds__NetworkCapabilities::soap_default(NULL); }
	virtual ~tds__NetworkCapabilities() { }
	friend SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:230 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (233)
/* tds:SecurityCapabilities complex type: */
class SOAP_CMAC tds__SecurityCapabilities
{
public:
	bool *TLS1_x002e0;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e1;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e2;	/* optional attribute of XSD type xsd:boolean */
	bool *OnboardKeyGeneration;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessPolicyConfig;	/* optional attribute of XSD type xsd:boolean */
	bool *DefaultAccessPolicy;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot1X;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteUserHandling;	/* optional attribute of XSD type xsd:boolean */
	bool *X_x002e509Token;	/* optional attribute of XSD type xsd:boolean */
	bool *SAMLToken;	/* optional attribute of XSD type xsd:boolean */
	bool *KerberosToken;	/* optional attribute of XSD type xsd:boolean */
	bool *UsernameToken;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpDigest;	/* optional attribute of XSD type xsd:boolean */
	bool *RELToken;	/* optional attribute of XSD type xsd:boolean */
	char *SupportedEAPMethods;	/* optional attribute of XSD type tds:EAPMethodTypes */
	int *MaxUsers;	/* optional attribute of XSD type xsd:int */
	int *MaxUserNameLength;	/* optional attribute of XSD type xsd:int */
	int *MaxPasswordLength;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SecurityCapabilities (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SecurityCapabilities); }
	         tds__SecurityCapabilities() { tds__SecurityCapabilities::soap_default(NULL); }
	virtual ~tds__SecurityCapabilities() { }
	friend SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:233 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (234)
/* tds:SystemCapabilities complex type: */
class SOAP_CMAC tds__SystemCapabilities
{
public:
	bool *DiscoveryResolve;	/* optional attribute of XSD type xsd:boolean */
	bool *DiscoveryBye;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteDiscovery;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *FirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpFirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional attribute of XSD type xsd:boolean */
	bool *StorageConfiguration;	/* optional attribute of XSD type xsd:boolean */
	int *MaxStorageConfigurations;	/* optional attribute of XSD type xsd:int */
	int *GeoLocationEntries;	/* optional attribute of XSD type xsd:int */
	char *AutoGeo;	/* optional attribute of XSD type tt:StringAttrList */
	char *StorageTypesSupported;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SystemCapabilities (234)
	virtual int soap_type(void) const { return 234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
	virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SystemCapabilities); }
	         tds__SystemCapabilities() { tds__SystemCapabilities::soap_default(NULL); }
	virtual ~tds__SystemCapabilities() { }
	friend SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:236 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (235)
/* tds:MiscCapabilities complex type: */
class SOAP_CMAC tds__MiscCapabilities
{
public:
	char *AuxiliaryCommands;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__MiscCapabilities (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
	virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__MiscCapabilities); }
	         tds__MiscCapabilities() { tds__MiscCapabilities::soap_default(NULL); }
	virtual ~tds__MiscCapabilities() { }
	friend SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4426 */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1209)
/* tds:UserCredential-Extension complex type: */
class SOAP_CMAC _tds__UserCredential_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UserCredential_Extension (1209)
	virtual int soap_type(void) const { return 1209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UserCredential_Extension, default initialized and not managed by a soap context
	virtual _tds__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__UserCredential_Extension); }
	         _tds__UserCredential_Extension() { _tds__UserCredential_Extension::soap_default(NULL); }
	virtual ~_tds__UserCredential_Extension() { }
	friend SOAP_FMAC1 _tds__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__tds__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:239 */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (236)
/* tds:UserCredential complex type: */
class SOAP_CMAC tds__UserCredential
{
public:
	char *UserName;	/* required element of XSD type xsd:string */
	char *Password;	/* optional element of XSD type xsd:string */
	_tds__UserCredential_Extension *Extension;	/* optional element of XSD type tds:UserCredential-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__UserCredential (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__UserCredential, default initialized and not managed by a soap context
	virtual tds__UserCredential *soap_alloc(void) const { return SOAP_NEW(tds__UserCredential); }
	         tds__UserCredential() { tds__UserCredential::soap_default(NULL); }
	virtual ~tds__UserCredential() { }
	friend SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4478 */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1212)
/* tds:StorageConfigurationData-Extension complex type: */
class SOAP_CMAC _tds__StorageConfigurationData_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StorageConfigurationData_Extension (1212)
	virtual int soap_type(void) const { return 1212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StorageConfigurationData_Extension, default initialized and not managed by a soap context
	virtual _tds__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__StorageConfigurationData_Extension); }
	         _tds__StorageConfigurationData_Extension() { _tds__StorageConfigurationData_Extension::soap_default(NULL); }
	virtual ~_tds__StorageConfigurationData_Extension() { }
	friend SOAP_FMAC1 _tds__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__tds__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:242 */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (237)
/* tds:StorageConfigurationData complex type: */
class SOAP_CMAC tds__StorageConfigurationData
{
public:
	char *LocalPath;	/* optional element of XSD type xsd:anyURI */
	char *StorageUri;	/* optional element of XSD type xsd:anyURI */
	tds__UserCredential *User;	/* optional element of XSD type tds:UserCredential */
	_tds__StorageConfigurationData_Extension *Extension;	/* optional element of XSD type tds:StorageConfigurationData-Extension */
	char *type;	/* required attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfigurationData (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfigurationData, default initialized and not managed by a soap context
	virtual tds__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfigurationData); }
	         tds__StorageConfigurationData() { tds__StorageConfigurationData::soap_default(NULL); }
	virtual ~tds__StorageConfigurationData() { }
	friend SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:248 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (239)
/* tds:GetServices complex type: */
class SOAP_CMAC _tds__GetServices
{
public:
	bool IncludeCapability;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServices (239)
	virtual int soap_type(void) const { return 239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
	virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW(_tds__GetServices); }
	         _tds__GetServices() { _tds__GetServices::soap_default(NULL); }
	virtual ~_tds__GetServices() { }
	friend SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:251 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (240)
/* tds:GetServicesResponse complex type: */
class SOAP_CMAC _tds__GetServicesResponse
{
public:
	int __sizeService;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Service> of XSD type tds:Service */
	tds__Service **Service;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServicesResponse (240)
	virtual int soap_type(void) const { return 240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServicesResponse); }
	         _tds__GetServicesResponse() { _tds__GetServicesResponse::soap_default(NULL); }
	virtual ~_tds__GetServicesResponse() { }
	friend SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:254 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (241)
/* tds:GetServiceCapabilities complex type: */
class SOAP_CMAC _tds__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilities (241)
	virtual int soap_type(void) const { return 241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilities); }
	         _tds__GetServiceCapabilities() { _tds__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:257 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (242)
/* tds:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse
{
public:
	tds__DeviceServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:DeviceServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilitiesResponse (242)
	virtual int soap_type(void) const { return 242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilitiesResponse); }
	         _tds__GetServiceCapabilitiesResponse() { _tds__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:260 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (243)
/* tds:GetDeviceInformation complex type: */
class SOAP_CMAC _tds__GetDeviceInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformation (243)
	virtual int soap_type(void) const { return 243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformation); }
	         _tds__GetDeviceInformation() { _tds__GetDeviceInformation::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformation() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:263 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (244)
/* tds:GetDeviceInformationResponse complex type: */
class SOAP_CMAC _tds__GetDeviceInformationResponse
{
public:
	char *Manufacturer;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	char *Model;	/* required element of XSD type xsd:string */
	char *FirmwareVersion;	/* required element of XSD type xsd:string */
	char *SerialNumber;	/* required element of XSD type xsd:string */
	char *HardwareId;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformationResponse (244)
	virtual int soap_type(void) const { return 244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformationResponse); }
	         _tds__GetDeviceInformationResponse() { _tds__GetDeviceInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:266 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (245)
/* tds:SetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTime (245)
	virtual int soap_type(void) const { return 245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTime); }
	         _tds__SetSystemDateAndTime() { _tds__SetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:269 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (246)
/* tds:SetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTimeResponse (246)
	virtual int soap_type(void) const { return 246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTimeResponse); }
	         _tds__SetSystemDateAndTimeResponse() { _tds__SetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:272 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (247)
/* tds:GetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTime
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTime (247)
	virtual int soap_type(void) const { return 247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTime); }
	         _tds__GetSystemDateAndTime() { _tds__GetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:275 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (248)
/* tds:GetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse
{
public:
	tt__SystemDateTime *SystemDateAndTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemDateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTimeResponse (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTimeResponse); }
	         _tds__GetSystemDateAndTimeResponse() { _tds__GetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:278 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (249)
/* tds:SetSystemFactoryDefault complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefault
{
public:
	enum tt__FactoryDefaultType FactoryDefault;	/* required element of XSD type tt:FactoryDefaultType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefault (249)
	virtual int soap_type(void) const { return 249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefault); }
	         _tds__SetSystemFactoryDefault() { _tds__SetSystemFactoryDefault::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefault() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:281 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (250)
/* tds:SetSystemFactoryDefaultResponse complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (250)
	virtual int soap_type(void) const { return 250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefaultResponse); }
	         _tds__SetSystemFactoryDefaultResponse() { _tds__SetSystemFactoryDefaultResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefaultResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:284 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (251)
/* tds:UpgradeSystemFirmware complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmware
{
public:
	tt__AttachmentData *Firmware;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmware (251)
	virtual int soap_type(void) const { return 251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmware); }
	         _tds__UpgradeSystemFirmware() { _tds__UpgradeSystemFirmware::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmware() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:287 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (252)
/* tds:UpgradeSystemFirmwareResponse complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse
{
public:
	char *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (252)
	virtual int soap_type(void) const { return 252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmwareResponse); }
	         _tds__UpgradeSystemFirmwareResponse() { _tds__UpgradeSystemFirmwareResponse::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmwareResponse() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:290 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (253)
/* tds:SystemReboot complex type: */
class SOAP_CMAC _tds__SystemReboot
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemReboot (253)
	virtual int soap_type(void) const { return 253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
	virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW(_tds__SystemReboot); }
	         _tds__SystemReboot() { _tds__SystemReboot::soap_default(NULL); }
	virtual ~_tds__SystemReboot() { }
	friend SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:293 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (254)
/* tds:SystemRebootResponse complex type: */
class SOAP_CMAC _tds__SystemRebootResponse
{
public:
	char *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemRebootResponse (254)
	virtual int soap_type(void) const { return 254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
	virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SystemRebootResponse); }
	         _tds__SystemRebootResponse() { _tds__SystemRebootResponse::soap_default(NULL); }
	virtual ~_tds__SystemRebootResponse() { }
	friend SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:296 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (255)
/* tds:RestoreSystem complex type: */
class SOAP_CMAC _tds__RestoreSystem
{
public:
	int __sizeBackupFiles;	/* sequence of elements <BackupFiles> of XSD type tt:BackupFile */
	tt__BackupFile **BackupFiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystem (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
	virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystem); }
	         _tds__RestoreSystem() { _tds__RestoreSystem::soap_default(NULL); }
	virtual ~_tds__RestoreSystem() { }
	friend SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:299 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (256)
/* tds:RestoreSystemResponse complex type: */
class SOAP_CMAC _tds__RestoreSystemResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystemResponse (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
	virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystemResponse); }
	         _tds__RestoreSystemResponse() { _tds__RestoreSystemResponse::soap_default(NULL); }
	virtual ~_tds__RestoreSystemResponse() { }
	friend SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:302 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (257)
/* tds:GetSystemBackup complex type: */
class SOAP_CMAC _tds__GetSystemBackup
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackup (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackup); }
	         _tds__GetSystemBackup() { _tds__GetSystemBackup::soap_default(NULL); }
	virtual ~_tds__GetSystemBackup() { }
	friend SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:305 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (258)
/* tds:GetSystemBackupResponse complex type: */
class SOAP_CMAC _tds__GetSystemBackupResponse
{
public:
	int __sizeBackupFiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <BackupFiles> of XSD type tt:BackupFile */
	tt__BackupFile **BackupFiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackupResponse (258)
	virtual int soap_type(void) const { return 258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackupResponse); }
	         _tds__GetSystemBackupResponse() { _tds__GetSystemBackupResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemBackupResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:308 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (259)
/* tds:GetSystemSupportInformation complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformation (259)
	virtual int soap_type(void) const { return 259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformation); }
	         _tds__GetSystemSupportInformation() { _tds__GetSystemSupportInformation::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformation() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:311 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (260)
/* tds:GetSystemSupportInformationResponse complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse
{
public:
	tt__SupportInformation *SupportInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformationResponse (260)
	virtual int soap_type(void) const { return 260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformationResponse); }
	         _tds__GetSystemSupportInformationResponse() { _tds__GetSystemSupportInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:314 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (261)
/* tds:GetSystemLog complex type: */
class SOAP_CMAC _tds__GetSystemLog
{
public:
	enum tt__SystemLogType LogType;	/* required element of XSD type tt:SystemLogType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLog (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
	virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLog); }
	         _tds__GetSystemLog() { _tds__GetSystemLog::soap_default(NULL); }
	virtual ~_tds__GetSystemLog() { }
	friend SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:317 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (262)
/* tds:GetSystemLogResponse complex type: */
class SOAP_CMAC _tds__GetSystemLogResponse
{
public:
	tt__SystemLog *SystemLog;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemLog */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLogResponse (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLogResponse); }
	         _tds__GetSystemLogResponse() { _tds__GetSystemLogResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemLogResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:320 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (263)
/* tds:GetScopes complex type: */
class SOAP_CMAC _tds__GetScopes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopes (263)
	virtual int soap_type(void) const { return 263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
	virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopes); }
	         _tds__GetScopes() { _tds__GetScopes::soap_default(NULL); }
	virtual ~_tds__GetScopes() { }
	friend SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:323 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (264)
/* tds:GetScopesResponse complex type: */
class SOAP_CMAC _tds__GetScopesResponse
{
public:
	int __sizeScopes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Scopes> of XSD type tt:Scope */
	tt__Scope **Scopes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopesResponse (264)
	virtual int soap_type(void) const { return 264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopesResponse); }
	         _tds__GetScopesResponse() { _tds__GetScopesResponse::soap_default(NULL); }
	virtual ~_tds__GetScopesResponse() { }
	friend SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:326 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (265)
/* tds:SetScopes complex type: */
class SOAP_CMAC _tds__SetScopes
{
public:
	int __sizeScopes;	/* sequence of elements <Scopes> of XSD type xsd:anyURI */
	char **Scopes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopes (265)
	virtual int soap_type(void) const { return 265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
	virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopes); }
	         _tds__SetScopes() { _tds__SetScopes::soap_default(NULL); }
	virtual ~_tds__SetScopes() { }
	friend SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:329 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (266)
/* tds:SetScopesResponse complex type: */
class SOAP_CMAC _tds__SetScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopesResponse (266)
	virtual int soap_type(void) const { return 266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopesResponse); }
	         _tds__SetScopesResponse() { _tds__SetScopesResponse::soap_default(NULL); }
	virtual ~_tds__SetScopesResponse() { }
	friend SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:332 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (267)
/* tds:AddScopes complex type: */
class SOAP_CMAC _tds__AddScopes
{
public:
	int __sizeScopeItem;	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopes (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
	virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopes); }
	         _tds__AddScopes() { _tds__AddScopes::soap_default(NULL); }
	virtual ~_tds__AddScopes() { }
	friend SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:335 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (268)
/* tds:AddScopesResponse complex type: */
class SOAP_CMAC _tds__AddScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopesResponse (268)
	virtual int soap_type(void) const { return 268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
	virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopesResponse); }
	         _tds__AddScopesResponse() { _tds__AddScopesResponse::soap_default(NULL); }
	virtual ~_tds__AddScopesResponse() { }
	friend SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:338 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (269)
/* tds:RemoveScopes complex type: */
class SOAP_CMAC _tds__RemoveScopes
{
public:
	int __sizeScopeItem;	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopes (269)
	virtual int soap_type(void) const { return 269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
	virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopes); }
	         _tds__RemoveScopes() { _tds__RemoveScopes::soap_default(NULL); }
	virtual ~_tds__RemoveScopes() { }
	friend SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:341 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (270)
/* tds:RemoveScopesResponse complex type: */
class SOAP_CMAC _tds__RemoveScopesResponse
{
public:
	int __sizeScopeItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopesResponse (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopesResponse); }
	         _tds__RemoveScopesResponse() { _tds__RemoveScopesResponse::soap_default(NULL); }
	virtual ~_tds__RemoveScopesResponse() { }
	friend SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:344 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (271)
/* tds:GetDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryMode (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryMode); }
	         _tds__GetDiscoveryMode() { _tds__GetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:347 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (272)
/* tds:GetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryModeResponse (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryModeResponse); }
	         _tds__GetDiscoveryModeResponse() { _tds__GetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:350 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (273)
/* tds:SetDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetDiscoveryMode
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryMode (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryMode); }
	         _tds__SetDiscoveryMode() { _tds__SetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:353 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (274)
/* tds:SetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryModeResponse (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryModeResponse); }
	         _tds__SetDiscoveryModeResponse() { _tds__SetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:356 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (275)
/* tds:GetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryMode (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryMode); }
	         _tds__GetRemoteDiscoveryMode() { _tds__GetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:359 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (276)
/* tds:GetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryModeResponse); }
	         _tds__GetRemoteDiscoveryModeResponse() { _tds__GetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:362 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (277)
/* tds:SetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryMode (277)
	virtual int soap_type(void) const { return 277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryMode); }
	         _tds__SetRemoteDiscoveryMode() { _tds__SetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:365 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (278)
/* tds:SetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryModeResponse); }
	         _tds__SetRemoteDiscoveryModeResponse() { _tds__SetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:368 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (279)
/* tds:GetDPAddresses complex type: */
class SOAP_CMAC _tds__GetDPAddresses
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddresses (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddresses); }
	         _tds__GetDPAddresses() { _tds__GetDPAddresses::soap_default(NULL); }
	virtual ~_tds__GetDPAddresses() { }
	friend SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:371 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (280)
/* tds:GetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__GetDPAddressesResponse
{
public:
	int __sizeDPAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <DPAddress> of XSD type tt:NetworkHost */
	tt__NetworkHost **DPAddress;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddressesResponse (280)
	virtual int soap_type(void) const { return 280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddressesResponse); }
	         _tds__GetDPAddressesResponse() { _tds__GetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__GetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:374 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (281)
/* tds:SetDPAddresses complex type: */
class SOAP_CMAC _tds__SetDPAddresses
{
public:
	int __sizeDPAddress;	/* sequence of elements <DPAddress> of XSD type tt:NetworkHost */
	tt__NetworkHost **DPAddress;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddresses (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddresses); }
	         _tds__SetDPAddresses() { _tds__SetDPAddresses::soap_default(NULL); }
	virtual ~_tds__SetDPAddresses() { }
	friend SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:377 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (282)
/* tds:SetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__SetDPAddressesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddressesResponse (282)
	virtual int soap_type(void) const { return 282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddressesResponse); }
	         _tds__SetDPAddressesResponse() { _tds__SetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__SetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:380 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (283)
/* tds:GetEndpointReference complex type: */
class SOAP_CMAC _tds__GetEndpointReference
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReference (283)
	virtual int soap_type(void) const { return 283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReference); }
	         _tds__GetEndpointReference() { _tds__GetEndpointReference::soap_default(NULL); }
	virtual ~_tds__GetEndpointReference() { }
	friend SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:383 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (284)
/* tds:GetEndpointReferenceResponse complex type: */
class SOAP_CMAC _tds__GetEndpointReferenceResponse
{
public:
	char *GUID;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReferenceResponse (284)
	virtual int soap_type(void) const { return 284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReferenceResponse); }
	         _tds__GetEndpointReferenceResponse() { _tds__GetEndpointReferenceResponse::soap_default(NULL); }
	virtual ~_tds__GetEndpointReferenceResponse() { }
	friend SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:386 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (285)
/* tds:GetRemoteUser complex type: */
class SOAP_CMAC _tds__GetRemoteUser
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUser (285)
	virtual int soap_type(void) const { return 285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUser); }
	         _tds__GetRemoteUser() { _tds__GetRemoteUser::soap_default(NULL); }
	virtual ~_tds__GetRemoteUser() { }
	friend SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:389 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (286)
/* tds:GetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__GetRemoteUserResponse
{
public:
	tt__RemoteUser *RemoteUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUserResponse (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUserResponse); }
	         _tds__GetRemoteUserResponse() { _tds__GetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:392 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (287)
/* tds:SetRemoteUser complex type: */
class SOAP_CMAC _tds__SetRemoteUser
{
public:
	tt__RemoteUser *RemoteUser;	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUser (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUser); }
	         _tds__SetRemoteUser() { _tds__SetRemoteUser::soap_default(NULL); }
	virtual ~_tds__SetRemoteUser() { }
	friend SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:395 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (288)
/* tds:SetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__SetRemoteUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUserResponse (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUserResponse); }
	         _tds__SetRemoteUserResponse() { _tds__SetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:398 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (289)
/* tds:GetUsers complex type: */
class SOAP_CMAC _tds__GetUsers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsers (289)
	virtual int soap_type(void) const { return 289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
	virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsers); }
	         _tds__GetUsers() { _tds__GetUsers::soap_default(NULL); }
	virtual ~_tds__GetUsers() { }
	friend SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:401 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (290)
/* tds:GetUsersResponse complex type: */
class SOAP_CMAC _tds__GetUsersResponse
{
public:
	int __sizeUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsersResponse (290)
	virtual int soap_type(void) const { return 290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
	virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsersResponse); }
	         _tds__GetUsersResponse() { _tds__GetUsersResponse::soap_default(NULL); }
	virtual ~_tds__GetUsersResponse() { }
	friend SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:404 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (291)
/* tds:CreateUsers complex type: */
class SOAP_CMAC _tds__CreateUsers
{
public:
	int __sizeUser;	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsers (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
	virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsers); }
	         _tds__CreateUsers() { _tds__CreateUsers::soap_default(NULL); }
	virtual ~_tds__CreateUsers() { }
	friend SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:407 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (292)
/* tds:CreateUsersResponse complex type: */
class SOAP_CMAC _tds__CreateUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsersResponse (292)
	virtual int soap_type(void) const { return 292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
	virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsersResponse); }
	         _tds__CreateUsersResponse() { _tds__CreateUsersResponse::soap_default(NULL); }
	virtual ~_tds__CreateUsersResponse() { }
	friend SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:410 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (293)
/* tds:DeleteUsers complex type: */
class SOAP_CMAC _tds__DeleteUsers
{
public:
	int __sizeUsername;	/* sequence of elements <Username> of XSD type xsd:string */
	char **Username;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsers (293)
	virtual int soap_type(void) const { return 293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
	virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsers); }
	         _tds__DeleteUsers() { _tds__DeleteUsers::soap_default(NULL); }
	virtual ~_tds__DeleteUsers() { }
	friend SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:413 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (294)
/* tds:DeleteUsersResponse complex type: */
class SOAP_CMAC _tds__DeleteUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsersResponse (294)
	virtual int soap_type(void) const { return 294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsersResponse); }
	         _tds__DeleteUsersResponse() { _tds__DeleteUsersResponse::soap_default(NULL); }
	virtual ~_tds__DeleteUsersResponse() { }
	friend SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:416 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (295)
/* tds:SetUser complex type: */
class SOAP_CMAC _tds__SetUser
{
public:
	int __sizeUser;	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUser (295)
	virtual int soap_type(void) const { return 295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
	virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetUser); }
	         _tds__SetUser() { _tds__SetUser::soap_default(NULL); }
	virtual ~_tds__SetUser() { }
	friend SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:419 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (296)
/* tds:SetUserResponse complex type: */
class SOAP_CMAC _tds__SetUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUserResponse (296)
	virtual int soap_type(void) const { return 296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetUserResponse); }
	         _tds__SetUserResponse() { _tds__SetUserResponse::soap_default(NULL); }
	virtual ~_tds__SetUserResponse() { }
	friend SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:422 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (297)
/* tds:GetWsdlUrl complex type: */
class SOAP_CMAC _tds__GetWsdlUrl
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrl (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrl); }
	         _tds__GetWsdlUrl() { _tds__GetWsdlUrl::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrl() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:425 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (298)
/* tds:GetWsdlUrlResponse complex type: */
class SOAP_CMAC _tds__GetWsdlUrlResponse
{
public:
	char *WsdlUrl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrlResponse (298)
	virtual int soap_type(void) const { return 298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrlResponse); }
	         _tds__GetWsdlUrlResponse() { _tds__GetWsdlUrlResponse::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrlResponse() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:428 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (299)
/* tds:GetCapabilities complex type: */
class SOAP_CMAC _tds__GetCapabilities
{
public:
	int __sizeCategory;	/* sequence of elements <Category> of XSD type tt:CapabilityCategory */
	enum tt__CapabilityCategory *Category;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilities (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilities); }
	         _tds__GetCapabilities() { _tds__GetCapabilities::soap_default(NULL); }
	virtual ~_tds__GetCapabilities() { }
	friend SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:431 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (300)
/* tds:GetCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetCapabilitiesResponse
{
public:
	tt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilitiesResponse (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilitiesResponse); }
	         _tds__GetCapabilitiesResponse() { _tds__GetCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:434 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (301)
/* tds:GetHostname complex type: */
class SOAP_CMAC _tds__GetHostname
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostname (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
	virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostname); }
	         _tds__GetHostname() { _tds__GetHostname::soap_default(NULL); }
	virtual ~_tds__GetHostname() { }
	friend SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:437 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (302)
/* tds:GetHostnameResponse complex type: */
class SOAP_CMAC _tds__GetHostnameResponse
{
public:
	tt__HostnameInformation *HostnameInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:HostnameInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostnameResponse (302)
	virtual int soap_type(void) const { return 302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostnameResponse); }
	         _tds__GetHostnameResponse() { _tds__GetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__GetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:440 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (303)
/* tds:SetHostname complex type: */
class SOAP_CMAC _tds__SetHostname
{
public:
	char *Name;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostname (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
	virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostname); }
	         _tds__SetHostname() { _tds__SetHostname::soap_default(NULL); }
	virtual ~_tds__SetHostname() { }
	friend SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:443 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (304)
/* tds:SetHostnameResponse complex type: */
class SOAP_CMAC _tds__SetHostnameResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameResponse (304)
	virtual int soap_type(void) const { return 304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameResponse); }
	         _tds__SetHostnameResponse() { _tds__SetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:446 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (305)
/* tds:SetHostnameFromDHCP complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCP (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCP); }
	         _tds__SetHostnameFromDHCP() { _tds__SetHostnameFromDHCP::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCP() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:449 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (306)
/* tds:SetHostnameFromDHCPResponse complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCPResponse (306)
	virtual int soap_type(void) const { return 306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCPResponse); }
	         _tds__SetHostnameFromDHCPResponse() { _tds__SetHostnameFromDHCPResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCPResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:452 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (307)
/* tds:GetDNS complex type: */
class SOAP_CMAC _tds__GetDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNS (307)
	virtual int soap_type(void) const { return 307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
	virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNS); }
	         _tds__GetDNS() { _tds__GetDNS::soap_default(NULL); }
	virtual ~_tds__GetDNS() { }
	friend SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:455 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (308)
/* tds:GetDNSResponse complex type: */
class SOAP_CMAC _tds__GetDNSResponse
{
public:
	tt__DNSInformation *DNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNSResponse (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNSResponse); }
	         _tds__GetDNSResponse() { _tds__GetDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:458 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (309)
/* tds:SetDNS complex type: */
class SOAP_CMAC _tds__SetDNS
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeSearchDomain;	/* sequence of elements <SearchDomain> of XSD type xsd:token */
	char **SearchDomain;
	int __sizeDNSManual;	/* sequence of elements <DNSManual> of XSD type tt:IPAddress */
	tt__IPAddress **DNSManual;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNS (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
	virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNS); }
	         _tds__SetDNS() { _tds__SetDNS::soap_default(NULL); }
	virtual ~_tds__SetDNS() { }
	friend SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:461 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (310)
/* tds:SetDNSResponse complex type: */
class SOAP_CMAC _tds__SetDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNSResponse (310)
	virtual int soap_type(void) const { return 310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNSResponse); }
	         _tds__SetDNSResponse() { _tds__SetDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:464 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (311)
/* tds:GetNTP complex type: */
class SOAP_CMAC _tds__GetNTP
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTP (311)
	virtual int soap_type(void) const { return 311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
	virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTP); }
	         _tds__GetNTP() { _tds__GetNTP::soap_default(NULL); }
	virtual ~_tds__GetNTP() { }
	friend SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:467 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (312)
/* tds:GetNTPResponse complex type: */
class SOAP_CMAC _tds__GetNTPResponse
{
public:
	tt__NTPInformation *NTPInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NTPInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTPResponse (312)
	virtual int soap_type(void) const { return 312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTPResponse); }
	         _tds__GetNTPResponse() { _tds__GetNTPResponse::soap_default(NULL); }
	virtual ~_tds__GetNTPResponse() { }
	friend SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:470 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (313)
/* tds:SetNTP complex type: */
class SOAP_CMAC _tds__SetNTP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeNTPManual;	/* sequence of elements <NTPManual> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPManual;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTP (313)
	virtual int soap_type(void) const { return 313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
	virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTP); }
	         _tds__SetNTP() { _tds__SetNTP::soap_default(NULL); }
	virtual ~_tds__SetNTP() { }
	friend SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:473 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (314)
/* tds:SetNTPResponse complex type: */
class SOAP_CMAC _tds__SetNTPResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTPResponse (314)
	virtual int soap_type(void) const { return 314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTPResponse); }
	         _tds__SetNTPResponse() { _tds__SetNTPResponse::soap_default(NULL); }
	virtual ~_tds__SetNTPResponse() { }
	friend SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:476 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (315)
/* tds:GetDynamicDNS complex type: */
class SOAP_CMAC _tds__GetDynamicDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNS (315)
	virtual int soap_type(void) const { return 315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNS); }
	         _tds__GetDynamicDNS() { _tds__GetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:479 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (316)
/* tds:GetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__GetDynamicDNSResponse
{
public:
	tt__DynamicDNSInformation *DynamicDNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DynamicDNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNSResponse (316)
	virtual int soap_type(void) const { return 316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNSResponse); }
	         _tds__GetDynamicDNSResponse() { _tds__GetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:482 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (317)
/* tds:SetDynamicDNS complex type: */
class SOAP_CMAC _tds__SetDynamicDNS
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	char *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNS (317)
	virtual int soap_type(void) const { return 317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNS); }
	         _tds__SetDynamicDNS() { _tds__SetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:485 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (318)
/* tds:SetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__SetDynamicDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNSResponse (318)
	virtual int soap_type(void) const { return 318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNSResponse); }
	         _tds__SetDynamicDNSResponse() { _tds__SetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:488 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (319)
/* tds:GetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__GetNetworkInterfaces
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfaces (319)
	virtual int soap_type(void) const { return 319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfaces); }
	         _tds__GetNetworkInterfaces() { _tds__GetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:491 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (320)
/* tds:GetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse
{
public:
	int __sizeNetworkInterfaces;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NetworkInterfaces> of XSD type tt:NetworkInterface */
	tt__NetworkInterface **NetworkInterfaces;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfacesResponse (320)
	virtual int soap_type(void) const { return 320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfacesResponse); }
	         _tds__GetNetworkInterfacesResponse() { _tds__GetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:494 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (321)
/* tds:SetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__SetNetworkInterfaces
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__NetworkInterfaceSetConfiguration *NetworkInterface;	/* required element of XSD type tt:NetworkInterfaceSetConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfaces (321)
	virtual int soap_type(void) const { return 321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfaces); }
	         _tds__SetNetworkInterfaces() { _tds__SetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:497 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (322)
/* tds:SetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfacesResponse (322)
	virtual int soap_type(void) const { return 322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfacesResponse); }
	         _tds__SetNetworkInterfacesResponse() { _tds__SetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:500 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (323)
/* tds:GetNetworkProtocols complex type: */
class SOAP_CMAC _tds__GetNetworkProtocols
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocols (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocols); }
	         _tds__GetNetworkProtocols() { _tds__GetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:503 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (324)
/* tds:GetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse
{
public:
	int __sizeNetworkProtocols;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NetworkProtocols> of XSD type tt:NetworkProtocol */
	tt__NetworkProtocol **NetworkProtocols;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocolsResponse (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocolsResponse); }
	         _tds__GetNetworkProtocolsResponse() { _tds__GetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:506 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (325)
/* tds:SetNetworkProtocols complex type: */
class SOAP_CMAC _tds__SetNetworkProtocols
{
public:
	int __sizeNetworkProtocols;	/* sequence of elements <NetworkProtocols> of XSD type tt:NetworkProtocol */
	tt__NetworkProtocol **NetworkProtocols;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocols (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocols); }
	         _tds__SetNetworkProtocols() { _tds__SetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:509 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (326)
/* tds:SetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocolsResponse (326)
	virtual int soap_type(void) const { return 326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocolsResponse); }
	         _tds__SetNetworkProtocolsResponse() { _tds__SetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:512 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (327)
/* tds:GetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGateway
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGateway (327)
	virtual int soap_type(void) const { return 327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGateway); }
	         _tds__GetNetworkDefaultGateway() { _tds__GetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:515 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (328)
/* tds:GetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse
{
public:
	tt__NetworkGateway *NetworkGateway;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkGateway */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGatewayResponse); }
	         _tds__GetNetworkDefaultGatewayResponse() { _tds__GetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:518 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (329)
/* tds:SetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGateway
{
public:
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:IPv4Address */
	char **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:IPv6Address */
	char **IPv6Address;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGateway (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGateway); }
	         _tds__SetNetworkDefaultGateway() { _tds__SetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:521 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (330)
/* tds:SetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGatewayResponse); }
	         _tds__SetNetworkDefaultGatewayResponse() { _tds__SetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:524 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (331)
/* tds:GetZeroConfiguration complex type: */
class SOAP_CMAC _tds__GetZeroConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfiguration (331)
	virtual int soap_type(void) const { return 331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfiguration); }
	         _tds__GetZeroConfiguration() { _tds__GetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__GetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:527 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (332)
/* tds:GetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetZeroConfigurationResponse
{
public:
	tt__NetworkZeroConfiguration *ZeroConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkZeroConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfigurationResponse (332)
	virtual int soap_type(void) const { return 332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfigurationResponse); }
	         _tds__GetZeroConfigurationResponse() { _tds__GetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:530 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (333)
/* tds:SetZeroConfiguration complex type: */
class SOAP_CMAC _tds__SetZeroConfiguration
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfiguration (333)
	virtual int soap_type(void) const { return 333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfiguration); }
	         _tds__SetZeroConfiguration() { _tds__SetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__SetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:533 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (334)
/* tds:SetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetZeroConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfigurationResponse (334)
	virtual int soap_type(void) const { return 334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfigurationResponse); }
	         _tds__SetZeroConfigurationResponse() { _tds__SetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:536 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (335)
/* tds:GetIPAddressFilter complex type: */
class SOAP_CMAC _tds__GetIPAddressFilter
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilter (335)
	virtual int soap_type(void) const { return 335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilter); }
	         _tds__GetIPAddressFilter() { _tds__GetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:539 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (336)
/* tds:GetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__GetIPAddressFilterResponse
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilterResponse (336)
	virtual int soap_type(void) const { return 336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilterResponse); }
	         _tds__GetIPAddressFilterResponse() { _tds__GetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:542 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (337)
/* tds:SetIPAddressFilter complex type: */
class SOAP_CMAC _tds__SetIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilter (337)
	virtual int soap_type(void) const { return 337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilter); }
	         _tds__SetIPAddressFilter() { _tds__SetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:545 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (338)
/* tds:SetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__SetIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilterResponse (338)
	virtual int soap_type(void) const { return 338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilterResponse); }
	         _tds__SetIPAddressFilterResponse() { _tds__SetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:548 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (339)
/* tds:AddIPAddressFilter complex type: */
class SOAP_CMAC _tds__AddIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilter (339)
	virtual int soap_type(void) const { return 339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilter); }
	         _tds__AddIPAddressFilter() { _tds__AddIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:551 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (340)
/* tds:AddIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__AddIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilterResponse (340)
	virtual int soap_type(void) const { return 340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilterResponse); }
	         _tds__AddIPAddressFilterResponse() { _tds__AddIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:554 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (341)
/* tds:RemoveIPAddressFilter complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilter (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilter); }
	         _tds__RemoveIPAddressFilter() { _tds__RemoveIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:557 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (342)
/* tds:RemoveIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilterResponse (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilterResponse); }
	         _tds__RemoveIPAddressFilterResponse() { _tds__RemoveIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:560 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (343)
/* tds:GetAccessPolicy complex type: */
class SOAP_CMAC _tds__GetAccessPolicy
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicy (343)
	virtual int soap_type(void) const { return 343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicy); }
	         _tds__GetAccessPolicy() { _tds__GetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:563 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (344)
/* tds:GetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__GetAccessPolicyResponse
{
public:
	tt__BinaryData *PolicyFile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicyResponse (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicyResponse); }
	         _tds__GetAccessPolicyResponse() { _tds__GetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:566 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (345)
/* tds:SetAccessPolicy complex type: */
class SOAP_CMAC _tds__SetAccessPolicy
{
public:
	tt__BinaryData *PolicyFile;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicy (345)
	virtual int soap_type(void) const { return 345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicy); }
	         _tds__SetAccessPolicy() { _tds__SetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:569 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (346)
/* tds:SetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__SetAccessPolicyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicyResponse (346)
	virtual int soap_type(void) const { return 346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicyResponse); }
	         _tds__SetAccessPolicyResponse() { _tds__SetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:572 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (347)
/* tds:CreateCertificate complex type: */
class SOAP_CMAC _tds__CreateCertificate
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	time_t *ValidNotBefore;	/* optional element of XSD type xsd:dateTime */
	time_t *ValidNotAfter;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificate (347)
	virtual int soap_type(void) const { return 347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
	virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificate); }
	         _tds__CreateCertificate() { _tds__CreateCertificate::soap_default(NULL); }
	virtual ~_tds__CreateCertificate() { }
	friend SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:575 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (348)
/* tds:CreateCertificateResponse complex type: */
class SOAP_CMAC _tds__CreateCertificateResponse
{
public:
	tt__Certificate *NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificateResponse (348)
	virtual int soap_type(void) const { return 348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
	virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificateResponse); }
	         _tds__CreateCertificateResponse() { _tds__CreateCertificateResponse::soap_default(NULL); }
	virtual ~_tds__CreateCertificateResponse() { }
	friend SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:578 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (349)
/* tds:GetCertificates complex type: */
class SOAP_CMAC _tds__GetCertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificates (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
	virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificates); }
	         _tds__GetCertificates() { _tds__GetCertificates::soap_default(NULL); }
	virtual ~_tds__GetCertificates() { }
	friend SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:581 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (350)
/* tds:GetCertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesResponse
{
public:
	int __sizeNvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NvtCertificate> of XSD type tt:Certificate */
	tt__Certificate **NvtCertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesResponse (350)
	virtual int soap_type(void) const { return 350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesResponse); }
	         _tds__GetCertificatesResponse() { _tds__GetCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:584 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (351)
/* tds:GetCertificatesStatus complex type: */
class SOAP_CMAC _tds__GetCertificatesStatus
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatus (351)
	virtual int soap_type(void) const { return 351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatus); }
	         _tds__GetCertificatesStatus() { _tds__GetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:587 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (352)
/* tds:GetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesStatusResponse
{
public:
	int __sizeCertificateStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <CertificateStatus> of XSD type tt:CertificateStatus */
	tt__CertificateStatus **CertificateStatus;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatusResponse (352)
	virtual int soap_type(void) const { return 352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatusResponse); }
	         _tds__GetCertificatesStatusResponse() { _tds__GetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:590 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (353)
/* tds:SetCertificatesStatus complex type: */
class SOAP_CMAC _tds__SetCertificatesStatus
{
public:
	int __sizeCertificateStatus;	/* sequence of elements <CertificateStatus> of XSD type tt:CertificateStatus */
	tt__CertificateStatus **CertificateStatus;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatus (353)
	virtual int soap_type(void) const { return 353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatus); }
	         _tds__SetCertificatesStatus() { _tds__SetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:593 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (354)
/* tds:SetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__SetCertificatesStatusResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatusResponse (354)
	virtual int soap_type(void) const { return 354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatusResponse); }
	         _tds__SetCertificatesStatusResponse() { _tds__SetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:596 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (355)
/* tds:DeleteCertificates complex type: */
class SOAP_CMAC _tds__DeleteCertificates
{
public:
	int __sizeCertificateID;	/* sequence of elements <CertificateID> of XSD type xsd:token */
	char **CertificateID;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificates (355)
	virtual int soap_type(void) const { return 355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificates); }
	         _tds__DeleteCertificates() { _tds__DeleteCertificates::soap_default(NULL); }
	virtual ~_tds__DeleteCertificates() { }
	friend SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:599 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (356)
/* tds:DeleteCertificatesResponse complex type: */
class SOAP_CMAC _tds__DeleteCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificatesResponse (356)
	virtual int soap_type(void) const { return 356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificatesResponse); }
	         _tds__DeleteCertificatesResponse() { _tds__DeleteCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__DeleteCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:602 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (357)
/* tds:GetPkcs10Request complex type: */
class SOAP_CMAC _tds__GetPkcs10Request
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	tt__BinaryData *Attributes;	/* optional element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10Request (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10Request); }
	         _tds__GetPkcs10Request() { _tds__GetPkcs10Request::soap_default(NULL); }
	virtual ~_tds__GetPkcs10Request() { }
	friend SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:605 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (358)
/* tds:GetPkcs10RequestResponse complex type: */
class SOAP_CMAC _tds__GetPkcs10RequestResponse
{
public:
	tt__BinaryData *Pkcs10Request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10RequestResponse (358)
	virtual int soap_type(void) const { return 358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10RequestResponse); }
	         _tds__GetPkcs10RequestResponse() { _tds__GetPkcs10RequestResponse::soap_default(NULL); }
	virtual ~_tds__GetPkcs10RequestResponse() { }
	friend SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:608 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (359)
/* tds:LoadCertificates complex type: */
class SOAP_CMAC _tds__LoadCertificates
{
public:
	int __sizeNVTCertificate;	/* sequence of elements <NVTCertificate> of XSD type tt:Certificate */
	tt__Certificate **NVTCertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificates (359)
	virtual int soap_type(void) const { return 359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificates); }
	         _tds__LoadCertificates() { _tds__LoadCertificates::soap_default(NULL); }
	virtual ~_tds__LoadCertificates() { }
	friend SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:611 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (360)
/* tds:LoadCertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificatesResponse (360)
	virtual int soap_type(void) const { return 360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificatesResponse); }
	         _tds__LoadCertificatesResponse() { _tds__LoadCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:614 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (361)
/* tds:GetClientCertificateMode complex type: */
class SOAP_CMAC _tds__GetClientCertificateMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateMode (361)
	virtual int soap_type(void) const { return 361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateMode); }
	         _tds__GetClientCertificateMode() { _tds__GetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:617 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (362)
/* tds:GetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__GetClientCertificateModeResponse
{
public:
	bool Enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateModeResponse (362)
	virtual int soap_type(void) const { return 362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateModeResponse); }
	         _tds__GetClientCertificateModeResponse() { _tds__GetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:620 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (363)
/* tds:SetClientCertificateMode complex type: */
class SOAP_CMAC _tds__SetClientCertificateMode
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateMode (363)
	virtual int soap_type(void) const { return 363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateMode); }
	         _tds__SetClientCertificateMode() { _tds__SetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:623 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (364)
/* tds:SetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__SetClientCertificateModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateModeResponse (364)
	virtual int soap_type(void) const { return 364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateModeResponse); }
	         _tds__SetClientCertificateModeResponse() { _tds__SetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:626 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (365)
/* tds:GetCACertificates complex type: */
class SOAP_CMAC _tds__GetCACertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificates (365)
	virtual int soap_type(void) const { return 365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
	virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificates); }
	         _tds__GetCACertificates() { _tds__GetCACertificates::soap_default(NULL); }
	virtual ~_tds__GetCACertificates() { }
	friend SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:629 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (366)
/* tds:GetCACertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCACertificatesResponse
{
public:
	int __sizeCACertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <CACertificate> of XSD type tt:Certificate */
	tt__Certificate **CACertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificatesResponse (366)
	virtual int soap_type(void) const { return 366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificatesResponse); }
	         _tds__GetCACertificatesResponse() { _tds__GetCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:632 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (367)
/* tds:LoadCertificateWithPrivateKey complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey
{
public:
	int __sizeCertificateWithPrivateKey;	/* sequence of elements <CertificateWithPrivateKey> of XSD type tt:CertificateWithPrivateKey */
	tt__CertificateWithPrivateKey **CertificateWithPrivateKey;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKey (367)
	virtual int soap_type(void) const { return 367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKey); }
	         _tds__LoadCertificateWithPrivateKey() { _tds__LoadCertificateWithPrivateKey::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKey() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:635 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (368)
/* tds:LoadCertificateWithPrivateKeyResponse complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (368)
	virtual int soap_type(void) const { return 368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKeyResponse); }
	         _tds__LoadCertificateWithPrivateKeyResponse() { _tds__LoadCertificateWithPrivateKeyResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:638 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (369)
/* tds:GetCertificateInformation complex type: */
class SOAP_CMAC _tds__GetCertificateInformation
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformation (369)
	virtual int soap_type(void) const { return 369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformation); }
	         _tds__GetCertificateInformation() { _tds__GetCertificateInformation::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformation() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:641 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (370)
/* tds:GetCertificateInformationResponse complex type: */
class SOAP_CMAC _tds__GetCertificateInformationResponse
{
public:
	tt__CertificateInformation *CertificateInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:CertificateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformationResponse (370)
	virtual int soap_type(void) const { return 370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformationResponse); }
	         _tds__GetCertificateInformationResponse() { _tds__GetCertificateInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:644 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (371)
/* tds:LoadCACertificates complex type: */
class SOAP_CMAC _tds__LoadCACertificates
{
public:
	int __sizeCACertificate;	/* sequence of elements <CACertificate> of XSD type tt:Certificate */
	tt__Certificate **CACertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificates (371)
	virtual int soap_type(void) const { return 371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificates); }
	         _tds__LoadCACertificates() { _tds__LoadCACertificates::soap_default(NULL); }
	virtual ~_tds__LoadCACertificates() { }
	friend SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:647 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (372)
/* tds:LoadCACertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCACertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificatesResponse (372)
	virtual int soap_type(void) const { return 372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificatesResponse); }
	         _tds__LoadCACertificatesResponse() { _tds__LoadCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:650 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (373)
/* tds:CreateDot1XConfiguration complex type: */
class SOAP_CMAC _tds__CreateDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfiguration (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfiguration); }
	         _tds__CreateDot1XConfiguration() { _tds__CreateDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:653 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (374)
/* tds:CreateDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfigurationResponse (374)
	virtual int soap_type(void) const { return 374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfigurationResponse); }
	         _tds__CreateDot1XConfigurationResponse() { _tds__CreateDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:656 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (375)
/* tds:SetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__SetDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfiguration (375)
	virtual int soap_type(void) const { return 375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfiguration); }
	         _tds__SetDot1XConfiguration() { _tds__SetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:659 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (376)
/* tds:SetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfigurationResponse (376)
	virtual int soap_type(void) const { return 376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfigurationResponse); }
	         _tds__SetDot1XConfigurationResponse() { _tds__SetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:662 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (377)
/* tds:GetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__GetDot1XConfiguration
{
public:
	char *Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfiguration (377)
	virtual int soap_type(void) const { return 377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfiguration); }
	         _tds__GetDot1XConfiguration() { _tds__GetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:665 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (378)
/* tds:GetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationResponse (378)
	virtual int soap_type(void) const { return 378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationResponse); }
	         _tds__GetDot1XConfigurationResponse() { _tds__GetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:668 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (379)
/* tds:GetDot1XConfigurations complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurations (379)
	virtual int soap_type(void) const { return 379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurations); }
	         _tds__GetDot1XConfigurations() { _tds__GetDot1XConfigurations::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurations() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:671 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (380)
/* tds:GetDot1XConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse
{
public:
	int __sizeDot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Dot1XConfiguration> of XSD type tt:Dot1XConfiguration */
	tt__Dot1XConfiguration **Dot1XConfiguration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationsResponse (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationsResponse); }
	         _tds__GetDot1XConfigurationsResponse() { _tds__GetDot1XConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationsResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:674 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (381)
/* tds:DeleteDot1XConfiguration complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfiguration
{
public:
	int __sizeDot1XConfigurationToken;	/* sequence of elements <Dot1XConfigurationToken> of XSD type tt:ReferenceToken */
	char **Dot1XConfigurationToken;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfiguration (381)
	virtual int soap_type(void) const { return 381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfiguration); }
	         _tds__DeleteDot1XConfiguration() { _tds__DeleteDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:677 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (382)
/* tds:DeleteDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (382)
	virtual int soap_type(void) const { return 382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfigurationResponse); }
	         _tds__DeleteDot1XConfigurationResponse() { _tds__DeleteDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:680 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (383)
/* tds:GetRelayOutputs complex type: */
class SOAP_CMAC _tds__GetRelayOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputs (383)
	virtual int soap_type(void) const { return 383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputs); }
	         _tds__GetRelayOutputs() { _tds__GetRelayOutputs::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputs() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:683 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (384)
/* tds:GetRelayOutputsResponse complex type: */
class SOAP_CMAC _tds__GetRelayOutputsResponse
{
public:
	int __sizeRelayOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <RelayOutputs> of XSD type tt:RelayOutput */
	tt__RelayOutput **RelayOutputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputsResponse (384)
	virtual int soap_type(void) const { return 384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputsResponse); }
	         _tds__GetRelayOutputsResponse() { _tds__GetRelayOutputsResponse::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputsResponse() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:686 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (385)
/* tds:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettings
{
public:
	char *RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettings (385)
	virtual int soap_type(void) const { return 385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettings); }
	         _tds__SetRelayOutputSettings() { _tds__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettings() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:689 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (386)
/* tds:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettingsResponse (386)
	virtual int soap_type(void) const { return 386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettingsResponse); }
	         _tds__SetRelayOutputSettingsResponse() { _tds__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettingsResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:692 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (387)
/* tds:SetRelayOutputState complex type: */
class SOAP_CMAC _tds__SetRelayOutputState
{
public:
	char *RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__RelayLogicalState LogicalState;	/* required element of XSD type tt:RelayLogicalState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputState (387)
	virtual int soap_type(void) const { return 387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputState); }
	         _tds__SetRelayOutputState() { _tds__SetRelayOutputState::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputState() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:695 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (388)
/* tds:SetRelayOutputStateResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputStateResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputStateResponse (388)
	virtual int soap_type(void) const { return 388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputStateResponse); }
	         _tds__SetRelayOutputStateResponse() { _tds__SetRelayOutputStateResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputStateResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:698 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (389)
/* tds:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommand
{
public:
	char *AuxiliaryCommand;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommand (389)
	virtual int soap_type(void) const { return 389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommand); }
	         _tds__SendAuxiliaryCommand() { _tds__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommand() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:701 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (390)
/* tds:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse
{
public:
	char *AuxiliaryCommandResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommandResponse (390)
	virtual int soap_type(void) const { return 390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommandResponse); }
	         _tds__SendAuxiliaryCommandResponse() { _tds__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommandResponse() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:704 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (391)
/* tds:GetDot11Capabilities complex type: */
class SOAP_CMAC _tds__GetDot11Capabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Capabilities (391)
	virtual int soap_type(void) const { return 391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
	virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Capabilities); }
	         _tds__GetDot11Capabilities() { _tds__GetDot11Capabilities::soap_default(NULL); }
	virtual ~_tds__GetDot11Capabilities() { }
	friend SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:707 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (392)
/* tds:GetDot11CapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse
{
public:
	tt__Dot11Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11CapabilitiesResponse (392)
	virtual int soap_type(void) const { return 392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11CapabilitiesResponse); }
	         _tds__GetDot11CapabilitiesResponse() { _tds__GetDot11CapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11CapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:710 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (393)
/* tds:GetDot11Status complex type: */
class SOAP_CMAC _tds__GetDot11Status
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Status (393)
	virtual int soap_type(void) const { return 393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
	virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Status); }
	         _tds__GetDot11Status() { _tds__GetDot11Status::soap_default(NULL); }
	virtual ~_tds__GetDot11Status() { }
	friend SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:713 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (394)
/* tds:GetDot11StatusResponse complex type: */
class SOAP_CMAC _tds__GetDot11StatusResponse
{
public:
	tt__Dot11Status *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Status */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11StatusResponse (394)
	virtual int soap_type(void) const { return 394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11StatusResponse); }
	         _tds__GetDot11StatusResponse() { _tds__GetDot11StatusResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11StatusResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:716 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (395)
/* tds:ScanAvailableDot11Networks complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11Networks
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11Networks (395)
	virtual int soap_type(void) const { return 395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11Networks); }
	         _tds__ScanAvailableDot11Networks() { _tds__ScanAvailableDot11Networks::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11Networks() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:719 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (396)
/* tds:ScanAvailableDot11NetworksResponse complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse
{
public:
	int __sizeNetworks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Networks> of XSD type tt:Dot11AvailableNetworks */
	tt__Dot11AvailableNetworks **Networks;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11NetworksResponse); }
	         _tds__ScanAvailableDot11NetworksResponse() { _tds__ScanAvailableDot11NetworksResponse::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:722 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (397)
/* tds:GetSystemUris complex type: */
class SOAP_CMAC _tds__GetSystemUris
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUris (397)
	virtual int soap_type(void) const { return 397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
	virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUris); }
	         _tds__GetSystemUris() { _tds__GetSystemUris::soap_default(NULL); }
	virtual ~_tds__GetSystemUris() { }
	friend SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:8100 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1275)
/* tds:GetSystemUrisResponse-Extension complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1275)
	virtual int soap_type(void) const { return 1275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse_Extension); }
	         _tds__GetSystemUrisResponse_Extension() { _tds__GetSystemUrisResponse_Extension::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse_Extension() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:725 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (398)
/* tds:GetSystemUrisResponse complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse
{
public:
	tt__SystemLogUriList *SystemLogUris;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:SystemLogUriList */
	char *SupportInfoUri;	/* optional element of XSD type xsd:anyURI */
	char *SystemBackupUri;	/* optional element of XSD type xsd:anyURI */
	_tds__GetSystemUrisResponse_Extension *Extension;	/* optional element of XSD type tds:GetSystemUrisResponse-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse (398)
	virtual int soap_type(void) const { return 398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse); }
	         _tds__GetSystemUrisResponse() { _tds__GetSystemUrisResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:728 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (399)
/* tds:StartFirmwareUpgrade complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgrade
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgrade (399)
	virtual int soap_type(void) const { return 399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgrade); }
	         _tds__StartFirmwareUpgrade() { _tds__StartFirmwareUpgrade::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgrade() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:731 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (400)
/* tds:StartFirmwareUpgradeResponse complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse
{
public:
	char *UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 UploadDelay;	/* external (custom serializer) */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgradeResponse (400)
	virtual int soap_type(void) const { return 400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgradeResponse); }
	         _tds__StartFirmwareUpgradeResponse() { _tds__StartFirmwareUpgradeResponse::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgradeResponse() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:734 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (401)
/* tds:StartSystemRestore complex type: */
class SOAP_CMAC _tds__StartSystemRestore
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestore (401)
	virtual int soap_type(void) const { return 401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestore); }
	         _tds__StartSystemRestore() { _tds__StartSystemRestore::soap_default(NULL); }
	virtual ~_tds__StartSystemRestore() { }
	friend SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:737 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (402)
/* tds:StartSystemRestoreResponse complex type: */
class SOAP_CMAC _tds__StartSystemRestoreResponse
{
public:
	char *UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestoreResponse (402)
	virtual int soap_type(void) const { return 402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestoreResponse); }
	         _tds__StartSystemRestoreResponse() { _tds__StartSystemRestoreResponse::soap_default(NULL); }
	virtual ~_tds__StartSystemRestoreResponse() { }
	friend SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:740 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (403)
/* tds:GetStorageConfigurations complex type: */
class SOAP_CMAC _tds__GetStorageConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurations (403)
	virtual int soap_type(void) const { return 403; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurations); }
	         _tds__GetStorageConfigurations() { _tds__GetStorageConfigurations::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurations() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:743 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (404)
/* tds:GetStorageConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationsResponse
{
public:
	int __sizeStorageConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <StorageConfigurations> of XSD type tds:StorageConfiguration */
	tds__StorageConfiguration **StorageConfigurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationsResponse (404)
	virtual int soap_type(void) const { return 404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationsResponse); }
	         _tds__GetStorageConfigurationsResponse() { _tds__GetStorageConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationsResponse() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:746 */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (405)
/* tds:CreateStorageConfiguration complex type: */
class SOAP_CMAC _tds__CreateStorageConfiguration
{
public:
	tds__StorageConfigurationData *StorageConfiguration;	/* required element of XSD type tds:StorageConfigurationData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfiguration (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfiguration); }
	         _tds__CreateStorageConfiguration() { _tds__CreateStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:749 */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (406)
/* tds:CreateStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateStorageConfigurationResponse
{
public:
	char *Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfigurationResponse (406)
	virtual int soap_type(void) const { return 406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfigurationResponse); }
	         _tds__CreateStorageConfigurationResponse() { _tds__CreateStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:752 */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (407)
/* tds:GetStorageConfiguration complex type: */
class SOAP_CMAC _tds__GetStorageConfiguration
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfiguration (407)
	virtual int soap_type(void) const { return 407; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfiguration); }
	         _tds__GetStorageConfiguration() { _tds__GetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__GetStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:755 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (408)
/* tds:GetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationResponse
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationResponse (408)
	virtual int soap_type(void) const { return 408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationResponse); }
	         _tds__GetStorageConfigurationResponse() { _tds__GetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:758 */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (409)
/* tds:SetStorageConfiguration complex type: */
class SOAP_CMAC _tds__SetStorageConfiguration
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfiguration (409)
	virtual int soap_type(void) const { return 409; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfiguration); }
	         _tds__SetStorageConfiguration() { _tds__SetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__SetStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:761 */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (410)
/* tds:SetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfigurationResponse (410)
	virtual int soap_type(void) const { return 410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfigurationResponse); }
	         _tds__SetStorageConfigurationResponse() { _tds__SetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:764 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (411)
/* tds:DeleteStorageConfiguration complex type: */
class SOAP_CMAC _tds__DeleteStorageConfiguration
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfiguration (411)
	virtual int soap_type(void) const { return 411; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfiguration); }
	         _tds__DeleteStorageConfiguration() { _tds__DeleteStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:767 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (412)
/* tds:DeleteStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfigurationResponse (412)
	virtual int soap_type(void) const { return 412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfigurationResponse); }
	         _tds__DeleteStorageConfigurationResponse() { _tds__DeleteStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:770 */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (413)
/* tds:GetGeoLocation complex type: */
class SOAP_CMAC _tds__GetGeoLocation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetGeoLocation (413)
	virtual int soap_type(void) const { return 413; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetGeoLocation, default initialized and not managed by a soap context
	virtual _tds__GetGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__GetGeoLocation); }
	         _tds__GetGeoLocation() { _tds__GetGeoLocation::soap_default(NULL); }
	virtual ~_tds__GetGeoLocation() { }
	friend SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:773 */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (414)
/* tds:GetGeoLocationResponse complex type: */
class SOAP_CMAC _tds__GetGeoLocationResponse
{
public:
	int __sizeLocation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Location> of XSD type tt:LocationEntity */
	tt__LocationEntity **Location;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetGeoLocationResponse (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__GetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetGeoLocationResponse); }
	         _tds__GetGeoLocationResponse() { _tds__GetGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__GetGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:776 */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (415)
/* tds:SetGeoLocation complex type: */
class SOAP_CMAC _tds__SetGeoLocation
{
public:
	int __sizeLocation;	/* sequence of elements <Location> of XSD type tt:LocationEntity */
	tt__LocationEntity **Location;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetGeoLocation (415)
	virtual int soap_type(void) const { return 415; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetGeoLocation, default initialized and not managed by a soap context
	virtual _tds__SetGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__SetGeoLocation); }
	         _tds__SetGeoLocation() { _tds__SetGeoLocation::soap_default(NULL); }
	virtual ~_tds__SetGeoLocation() { }
	friend SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:779 */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (416)
/* tds:SetGeoLocationResponse complex type: */
class SOAP_CMAC _tds__SetGeoLocationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetGeoLocationResponse (416)
	virtual int soap_type(void) const { return 416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__SetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetGeoLocationResponse); }
	         _tds__SetGeoLocationResponse() { _tds__SetGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__SetGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:782 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (417)
/* tds:DeleteGeoLocation complex type: */
class SOAP_CMAC _tds__DeleteGeoLocation
{
public:
	int __sizeLocation;	/* sequence of elements <Location> of XSD type tt:LocationEntity */
	tt__LocationEntity **Location;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteGeoLocation (417)
	virtual int soap_type(void) const { return 417; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteGeoLocation, default initialized and not managed by a soap context
	virtual _tds__DeleteGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteGeoLocation); }
	         _tds__DeleteGeoLocation() { _tds__DeleteGeoLocation::soap_default(NULL); }
	virtual ~_tds__DeleteGeoLocation() { }
	friend SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:785 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (418)
/* tds:DeleteGeoLocationResponse complex type: */
class SOAP_CMAC _tds__DeleteGeoLocationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteGeoLocationResponse (418)
	virtual int soap_type(void) const { return 418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteGeoLocationResponse); }
	         _tds__DeleteGeoLocationResponse() { _tds__DeleteGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:788 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (419)
/* Type tt__DeviceEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceEntity complex type: */
class SOAP_CMAC tt__DeviceEntity
{
public:
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceEntity (419)
	virtual int soap_type(void) const { return 419; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
	virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW(tt__DeviceEntity); }
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
	friend SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:791 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (420)
/* tt:IntRectangle complex type: */
class SOAP_CMAC tt__IntRectangle
{
public:
	int x;	/* required attribute of XSD type xsd:int */
	int y;	/* required attribute of XSD type xsd:int */
	int width;	/* required attribute of XSD type xsd:int */
	int height;	/* required attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangle (420)
	virtual int soap_type(void) const { return 420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
	virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangle); }
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
	friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:794 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (421)
/* tt:IntRectangleRange complex type: */
class SOAP_CMAC tt__IntRectangleRange
{
public:
	tt__IntRange *XRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *YRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangleRange (421)
	virtual int soap_type(void) const { return 421; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
	virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangleRange); }
	         tt__IntRectangleRange() { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
	friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:797 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (422)
/* tt:IntRange complex type: */
class SOAP_CMAC tt__IntRange
{
public:
	int Min;	/* required element of XSD type xsd:int */
	int Max;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRange (422)
	virtual int soap_type(void) const { return 422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
	virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRange); }
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
	friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:800 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (423)
/* tt:FloatRange complex type: */
class SOAP_CMAC tt__FloatRange
{
public:
	float Min;	/* required element of XSD type xsd:float */
	float Max;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatRange (423)
	virtual int soap_type(void) const { return 423; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
	virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW(tt__FloatRange); }
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
	friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:803 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (424)
/* tt:DurationRange complex type: */
class SOAP_CMAC tt__DurationRange
{
public:
	LONG64 Min;	/* external (custom serializer) */
	LONG64 Max;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DurationRange (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
	virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW(tt__DurationRange); }
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
	friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:806 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (425)
/* tt:IntList complex type: */
class SOAP_CMAC tt__IntList
{
public:
	int __sizeItems;	/* sequence of elements <Items> of XSD type xsd:int */
	int *Items;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntList (425)
	virtual int soap_type(void) const { return 425; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntList, default initialized and not managed by a soap context
	virtual tt__IntList *soap_alloc(void) const { return SOAP_NEW(tt__IntList); }
	         tt__IntList() { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
	friend SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:809 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (426)
/* tt:FloatList complex type: */
class SOAP_CMAC tt__FloatList
{
public:
	int __sizeItems;	/* sequence of elements <Items> of XSD type xsd:float */
	float *Items;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatList (426)
	virtual int soap_type(void) const { return 426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatList, default initialized and not managed by a soap context
	virtual tt__FloatList *soap_alloc(void) const { return SOAP_NEW(tt__FloatList); }
	         tt__FloatList() { tt__FloatList::soap_default(NULL); }
	virtual ~tt__FloatList() { }
	friend SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:812 */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (427)
/* tt:AnyHolder complex type: */
class SOAP_CMAC tt__AnyHolder
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnyHolder (427)
	virtual int soap_type(void) const { return 427; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnyHolder, default initialized and not managed by a soap context
	virtual tt__AnyHolder *soap_alloc(void) const { return SOAP_NEW(tt__AnyHolder); }
	         tt__AnyHolder() { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
	friend SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:818 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (429)
/* tt:VideoSourceExtension complex type: */
class SOAP_CMAC tt__VideoSourceExtension
{
public:
	tt__ImagingSettings20 *Imaging;	/* optional element of XSD type tt:ImagingSettings20 */
	tt__VideoSourceExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension (429)
	virtual int soap_type(void) const { return 429; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension); }
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:821 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (430)
/* tt:VideoSourceExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension2 (430)
	virtual int soap_type(void) const { return 430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension2); }
	         tt__VideoSourceExtension2() { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:827 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (432)
/* tt:Profile complex type: */
class SOAP_CMAC tt__Profile
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of XSD type tt:VideoSourceConfiguration */
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of XSD type tt:AudioSourceConfiguration */
	tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of XSD type tt:VideoEncoderConfiguration */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZConfiguration;	/* optional element of XSD type tt:PTZConfiguration */
	tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of XSD type tt:MetadataConfiguration */
	tt__ProfileExtension *Extension;	/* optional element of XSD type tt:ProfileExtension */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Profile (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Profile, default initialized and not managed by a soap context
	virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW(tt__Profile); }
	         tt__Profile() { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
	friend SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:830 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (433)
/* tt:ProfileExtension complex type: */
class SOAP_CMAC tt__ProfileExtension
{
public:
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of XSD type tt:AudioOutputConfiguration */
	tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of XSD type tt:AudioDecoderConfiguration */
	tt__ProfileExtension2 *Extension;	/* optional element of XSD type tt:ProfileExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension (433)
	virtual int soap_type(void) const { return 433; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
	virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension); }
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
	friend SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:833 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (434)
/* tt:ProfileExtension2 complex type: */
class SOAP_CMAC tt__ProfileExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension2 (434)
	virtual int soap_type(void) const { return 434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
	virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension2); }
	         tt__ProfileExtension2() { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
	friend SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:836 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (435)
/* Type tt__ConfigurationEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigurationEntity complex type: */
class SOAP_CMAC tt__ConfigurationEntity
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	int UseCount;	/* required element of XSD type xsd:int */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigurationEntity (435)
	virtual int soap_type(void) const { return 435; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
	virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW(tt__ConfigurationEntity); }
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
	friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:842 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (437)
/* tt:VideoSourceConfigurationExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension
{
public:
	tt__Rotate *Rotate;	/* optional element of XSD type tt:Rotate */
	tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension (437)
	virtual int soap_type(void) const { return 437; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension); }
	         tt__VideoSourceConfigurationExtension() { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:845 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (438)
/* tt:VideoSourceConfigurationExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2
{
public:
	int __sizeLensDescription;	/* sequence of elements <LensDescription> of XSD type tt:LensDescription */
	tt__LensDescription **LensDescription;
	tt__SceneOrientation *SceneOrientation;	/* optional element of XSD type tt:SceneOrientation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (438)
	virtual int soap_type(void) const { return 438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension2); }
	         tt__VideoSourceConfigurationExtension2() { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:848 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (439)
/* tt:Rotate complex type: */
class SOAP_CMAC tt__Rotate
{
public:
	enum tt__RotateMode Mode;	/* required element of XSD type tt:RotateMode */
	int *Degree;	/* optional element of XSD type xsd:int */
	tt__RotateExtension *Extension;	/* optional element of XSD type tt:RotateExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rotate (439)
	virtual int soap_type(void) const { return 439; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
	virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW(tt__Rotate); }
	         tt__Rotate() { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
	friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:851 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (440)
/* tt:RotateExtension complex type: */
class SOAP_CMAC tt__RotateExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateExtension (440)
	virtual int soap_type(void) const { return 440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
	virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateExtension); }
	         tt__RotateExtension() { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
	friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:854 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (441)
/* tt:LensProjection complex type: */
class SOAP_CMAC tt__LensProjection
{
public:
	float Angle;	/* required element of XSD type xsd:float */
	float Radius;	/* required element of XSD type xsd:float */
	float *Transmittance;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensProjection (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
	virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW(tt__LensProjection); }
	         tt__LensProjection() { tt__LensProjection::soap_default(NULL); }
	virtual ~tt__LensProjection() { }
	friend SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:857 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (442)
/* tt:LensOffset complex type: */
class SOAP_CMAC tt__LensOffset
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensOffset (442)
	virtual int soap_type(void) const { return 442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
	virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW(tt__LensOffset); }
	         tt__LensOffset() { tt__LensOffset::soap_default(NULL); }
	virtual ~tt__LensOffset() { }
	friend SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:860 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (443)
/* tt:LensDescription complex type: */
class SOAP_CMAC tt__LensDescription
{
public:
	tt__LensOffset *Offset;	/* required element of XSD type tt:LensOffset */
	int __sizeProjection;	/* sequence of elements <Projection> of XSD type tt:LensProjection */
	tt__LensProjection **Projection;
	float XFactor;	/* required element of XSD type xsd:float */
	float *FocalLength;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensDescription (443)
	virtual int soap_type(void) const { return 443; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
	virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW(tt__LensDescription); }
	         tt__LensDescription() { tt__LensDescription::soap_default(NULL); }
	virtual ~tt__LensDescription() { }
	friend SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:863 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (444)
/* tt:VideoSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptions
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of XSD type tt:IntRectangleRange */
	int __sizeVideoSourceTokensAvailable;	/* sequence of elements <VideoSourceTokensAvailable> of XSD type tt:ReferenceToken */
	char **VideoSourceTokensAvailable;
	tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension */
	int *MaximumNumberOfProfiles;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptions (444)
	virtual int soap_type(void) const { return 444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptions); }
	         tt__VideoSourceConfigurationOptions() { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:866 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (445)
/* tt:VideoSourceConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension
{
public:
	tt__RotateOptions *Rotate;	/* optional element of XSD type tt:RotateOptions */
	tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (445)
	virtual int soap_type(void) const { return 445; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension); }
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:869 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (446)
/* tt:VideoSourceConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2
{
public:
	int __sizeSceneOrientationMode;	/* sequence of elements <SceneOrientationMode> of XSD type tt:SceneOrientationMode */
	enum tt__SceneOrientationMode *SceneOrientationMode;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension2); }
	         tt__VideoSourceConfigurationOptionsExtension2() { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:872 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (447)
/* tt:RotateOptions complex type: */
class SOAP_CMAC tt__RotateOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:RotateMode */
	enum tt__RotateMode *Mode;
	tt__IntList *DegreeList;	/* optional element of XSD type tt:IntList */
	tt__RotateOptionsExtension *Extension;	/* optional element of XSD type tt:RotateOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptions (447)
	virtual int soap_type(void) const { return 447; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
	virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptions); }
	         tt__RotateOptions() { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
	friend SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:875 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (448)
/* tt:RotateOptionsExtension complex type: */
class SOAP_CMAC tt__RotateOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptionsExtension (448)
	virtual int soap_type(void) const { return 448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
	virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptionsExtension); }
	         tt__RotateOptionsExtension() { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
	friend SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:878 */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (449)
/* tt:SceneOrientation complex type: */
class SOAP_CMAC tt__SceneOrientation
{
public:
	enum tt__SceneOrientationMode Mode;	/* required element of XSD type tt:SceneOrientationMode */
	char *Orientation;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SceneOrientation (449)
	virtual int soap_type(void) const { return 449; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SceneOrientation, default initialized and not managed by a soap context
	virtual tt__SceneOrientation *soap_alloc(void) const { return SOAP_NEW(tt__SceneOrientation); }
	         tt__SceneOrientation() { tt__SceneOrientation::soap_default(NULL); }
	virtual ~tt__SceneOrientation() { }
	friend SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:884 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (451)
/* tt:VideoResolution complex type: */
class SOAP_CMAC tt__VideoResolution
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution (451)
	virtual int soap_type(void) const { return 451; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
	virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution); }
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
	friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:887 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (452)
/* tt:VideoRateControl complex type: */
class SOAP_CMAC tt__VideoRateControl
{
public:
	int FrameRateLimit;	/* required element of XSD type xsd:int */
	int EncodingInterval;	/* required element of XSD type xsd:int */
	int BitrateLimit;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl (452)
	virtual int soap_type(void) const { return 452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
	virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl); }
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
	friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:890 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (453)
/* tt:Mpeg4Configuration complex type: */
class SOAP_CMAC tt__Mpeg4Configuration
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of XSD type tt:Mpeg4Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Configuration (453)
	virtual int soap_type(void) const { return 453; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
	virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Configuration); }
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
	friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:893 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (454)
/* tt:H264Configuration complex type: */
class SOAP_CMAC tt__H264Configuration
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of XSD type tt:H264Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Configuration (454)
	virtual int soap_type(void) const { return 454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
	virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW(tt__H264Configuration); }
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
	friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:896 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (455)
/* tt:VideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions
{
public:
	tt__IntRange *QualityRange;	/* required element of XSD type tt:IntRange */
	tt__JpegOptions *JPEG;	/* optional element of XSD type tt:JpegOptions */
	tt__Mpeg4Options *MPEG4;	/* optional element of XSD type tt:Mpeg4Options */
	tt__H264Options *H264;	/* optional element of XSD type tt:H264Options */
	tt__VideoEncoderOptionsExtension *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfigurationOptions (455)
	virtual int soap_type(void) const { return 455; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfigurationOptions); }
	         tt__VideoEncoderConfigurationOptions() { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:899 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (456)
/* tt:VideoEncoderOptionsExtension complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension
{
public:
	tt__JpegOptions2 *JPEG;	/* optional element of XSD type tt:JpegOptions2 */
	tt__Mpeg4Options2 *MPEG4;	/* optional element of XSD type tt:Mpeg4Options2 */
	tt__H264Options2 *H264;	/* optional element of XSD type tt:H264Options2 */
	tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension (456)
	virtual int soap_type(void) const { return 456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension); }
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:902 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (457)
/* tt:VideoEncoderOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (457)
	virtual int soap_type(void) const { return 457; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension2); }
	         tt__VideoEncoderOptionsExtension2() { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:905 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (458)
/* Type tt__JpegOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions complex type: */
class SOAP_CMAC tt__JpegOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions (458)
	virtual int soap_type(void) const { return 458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
	virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions); }
	         tt__JpegOptions() { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
	friend SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:911 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (460)
/* Type tt__Mpeg4Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options complex type: */
class SOAP_CMAC tt__Mpeg4Options
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	int __sizeMpeg4ProfilesSupported;	/* sequence of elements <Mpeg4ProfilesSupported> of XSD type tt:Mpeg4Profile */
	enum tt__Mpeg4Profile *Mpeg4ProfilesSupported;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options (460)
	virtual int soap_type(void) const { return 460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options); }
	         tt__Mpeg4Options() { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
	friend SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:917 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (462)
/* Type tt__H264Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options complex type: */
class SOAP_CMAC tt__H264Options
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	int __sizeH264ProfilesSupported;	/* sequence of elements <H264ProfilesSupported> of XSD type tt:H264Profile */
	enum tt__H264Profile *H264ProfilesSupported;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options (462)
	virtual int soap_type(void) const { return 462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
	virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW(tt__H264Options); }
	         tt__H264Options() { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
	friend SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:926 */
#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (465)
/* tt:VideoResolution2 complex type: */
class SOAP_CMAC tt__VideoResolution2
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution2 (465)
	virtual int soap_type(void) const { return 465; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution2, default initialized and not managed by a soap context
	virtual tt__VideoResolution2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution2); }
	         tt__VideoResolution2() { tt__VideoResolution2::soap_default(NULL); }
	virtual ~tt__VideoResolution2() { }
	friend SOAP_FMAC1 tt__VideoResolution2 * SOAP_FMAC2 soap_instantiate_tt__VideoResolution2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:929 */
#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (466)
/* tt:VideoRateControl2 complex type: */
class SOAP_CMAC tt__VideoRateControl2
{
public:
	float FrameRateLimit;	/* required element of XSD type xsd:float */
	int BitrateLimit;	/* required element of XSD type xsd:int */
	bool *ConstantBitRate;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl2 (466)
	virtual int soap_type(void) const { return 466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl2, default initialized and not managed by a soap context
	virtual tt__VideoRateControl2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl2); }
	         tt__VideoRateControl2() { tt__VideoRateControl2::soap_default(NULL); }
	virtual ~tt__VideoRateControl2() { }
	friend SOAP_FMAC1 tt__VideoRateControl2 * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:932 */
#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (467)
/* tt:VideoEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoder2ConfigurationOptions
{
public:
	char *Encoding;	/* required element of XSD type xsd:string */
	tt__FloatRange *QualityRange;	/* required element of XSD type tt:FloatRange */
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution2 */
	tt__VideoResolution2 **ResolutionsAvailable;
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	char *GovLengthRange;	/* optional attribute of XSD type tt:IntAttrList */
	char *FrameRatesSupported;	/* optional attribute of XSD type tt:FloatAttrList */
	char *ProfilesSupported;	/* optional attribute of XSD type tt:StringAttrList */
	bool *ConstantBitRateSupported;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (467)
	virtual int soap_type(void) const { return 467; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2ConfigurationOptions); }
	         tt__VideoEncoder2ConfigurationOptions() { tt__VideoEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoder2ConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:938 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (469)
/* tt:AudioSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioSourceConfigurationOptions
{
public:
	int __sizeInputTokensAvailable;	/* sequence of elements <InputTokensAvailable> of XSD type tt:ReferenceToken */
	char **InputTokensAvailable;
	tt__AudioSourceOptionsExtension *Extension;	/* optional element of XSD type tt:AudioSourceOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfigurationOptions (469)
	virtual int soap_type(void) const { return 469; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfigurationOptions); }
	         tt__AudioSourceConfigurationOptions() { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:941 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (470)
/* tt:AudioSourceOptionsExtension complex type: */
class SOAP_CMAC tt__AudioSourceOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceOptionsExtension (470)
	virtual int soap_type(void) const { return 470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceOptionsExtension); }
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:947 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (472)
/* tt:AudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions
{
public:
	int __sizeOptions;	/* sequence of elements <Options> of XSD type tt:AudioEncoderConfigurationOption */
	tt__AudioEncoderConfigurationOption **Options;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOptions (472)
	virtual int soap_type(void) const { return 472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOptions); }
	         tt__AudioEncoderConfigurationOptions() { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:950 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (473)
/* tt:AudioEncoderConfigurationOption complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOption
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOption (473)
	virtual int soap_type(void) const { return 473; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOption); }
	         tt__AudioEncoderConfigurationOption() { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:956 */
#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (475)
/* tt:AudioEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoder2ConfigurationOptions
{
public:
	char *Encoding;	/* required element of XSD type xsd:string */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (475)
	virtual int soap_type(void) const { return 475; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2ConfigurationOptions); }
	         tt__AudioEncoder2ConfigurationOptions() { tt__AudioEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoder2ConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:965 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (478)
/* tt:MetadataConfigurationExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationExtension (478)
	virtual int soap_type(void) const { return 478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationExtension); }
	         tt__MetadataConfigurationExtension() { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:968 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (479)
/* tt:PTZFilter complex type: */
class SOAP_CMAC tt__PTZFilter
{
public:
	bool Status;	/* required element of XSD type xsd:boolean */
	bool Position;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZFilter (479)
	virtual int soap_type(void) const { return 479; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
	virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZFilter); }
	         tt__PTZFilter() { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
	friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:10238 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1334)
/* tt:EventSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	/// Return the unique type ID value SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1334)
	virtual int soap_type(void) const { return 1334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy); }
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:971 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (480)
/* tt:EventSubscription complex type: */
class SOAP_CMAC tt__EventSubscription
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tt:EventSubscription-SubscriptionPolicy */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventSubscription (480)
	virtual int soap_type(void) const { return 480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
	virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW(tt__EventSubscription); }
	         tt__EventSubscription() { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
	friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:974 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (481)
/* tt:MetadataConfigurationOptions complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptions
{
public:
	tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of XSD type tt:PTZStatusFilterOptions */
	tt__MetadataConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension */
	bool *GeoLocation;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptions (481)
	virtual int soap_type(void) const { return 481; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptions); }
	         tt__MetadataConfigurationOptions() { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:977 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (482)
/* tt:MetadataConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension
{
public:
	int __sizeCompressionType;	/* sequence of elements <CompressionType> of XSD type xsd:string */
	char **CompressionType;
	tt__MetadataConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (482)
	virtual int soap_type(void) const { return 482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension); }
	         tt__MetadataConfigurationOptionsExtension() { tt__MetadataConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:980 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (483)
/* tt:MetadataConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (483)
	virtual int soap_type(void) const { return 483; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension2); }
	         tt__MetadataConfigurationOptionsExtension2() { tt__MetadataConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension2() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:983 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (484)
/* tt:PTZStatusFilterOptions complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptions
{
public:
	bool PanTiltStatusSupported;	/* required element of XSD type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of XSD type xsd:boolean */
	bool *PanTiltPositionSupported;	/* optional element of XSD type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of XSD type xsd:boolean */
	tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of XSD type tt:PTZStatusFilterOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptions (484)
	virtual int soap_type(void) const { return 484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptions); }
	         tt__PTZStatusFilterOptions() { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:986 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (485)
/* tt:PTZStatusFilterOptionsExtension complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (485)
	virtual int soap_type(void) const { return 485; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptionsExtension); }
	         tt__PTZStatusFilterOptionsExtension() { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:992 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (487)
/* tt:VideoOutputExtension complex type: */
class SOAP_CMAC tt__VideoOutputExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputExtension (487)
	virtual int soap_type(void) const { return 487; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
	virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputExtension); }
	         tt__VideoOutputExtension() { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
	friend SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:998 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (489)
/* tt:VideoOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoOutputConfigurationOptions
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfigurationOptions (489)
	virtual int soap_type(void) const { return 489; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfigurationOptions); }
	         tt__VideoOutputConfigurationOptions() { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1001 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (490)
/* tt:VideoDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions
{
public:
	tt__JpegDecOptions *JpegDecOptions;	/* optional element of XSD type tt:JpegDecOptions */
	tt__H264DecOptions *H264DecOptions;	/* optional element of XSD type tt:H264DecOptions */
	tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of XSD type tt:Mpeg4DecOptions */
	tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoDecoderConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptions (490)
	virtual int soap_type(void) const { return 490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptions); }
	         tt__VideoDecoderConfigurationOptions() { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1004 */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (491)
/* tt:H264DecOptions complex type: */
class SOAP_CMAC tt__H264DecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	int __sizeSupportedH264Profiles;	/* sequence of elements <SupportedH264Profiles> of XSD type tt:H264Profile */
	enum tt__H264Profile *SupportedH264Profiles;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264DecOptions (491)
	virtual int soap_type(void) const { return 491; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264DecOptions, default initialized and not managed by a soap context
	virtual tt__H264DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__H264DecOptions); }
	         tt__H264DecOptions() { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
	friend SOAP_FMAC1 tt__H264DecOptions * SOAP_FMAC2 soap_instantiate_tt__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1007 */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (492)
/* tt:JpegDecOptions complex type: */
class SOAP_CMAC tt__JpegDecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegDecOptions (492)
	virtual int soap_type(void) const { return 492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegDecOptions, default initialized and not managed by a soap context
	virtual tt__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegDecOptions); }
	         tt__JpegDecOptions() { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
	friend SOAP_FMAC1 tt__JpegDecOptions * SOAP_FMAC2 soap_instantiate_tt__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1010 */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (493)
/* tt:Mpeg4DecOptions complex type: */
class SOAP_CMAC tt__Mpeg4DecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	int __sizeSupportedMpeg4Profiles;	/* sequence of elements <SupportedMpeg4Profiles> of XSD type tt:Mpeg4Profile */
	enum tt__Mpeg4Profile *SupportedMpeg4Profiles;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4DecOptions (493)
	virtual int soap_type(void) const { return 493; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4DecOptions, default initialized and not managed by a soap context
	virtual tt__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4DecOptions); }
	         tt__Mpeg4DecOptions() { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
	friend SOAP_FMAC1 tt__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_tt__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1013 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (494)
/* tt:VideoDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (494)
	virtual int soap_type(void) const { return 494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptionsExtension); }
	         tt__VideoDecoderConfigurationOptionsExtension() { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1022 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (497)
/* tt:AudioOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioOutputConfigurationOptions
{
public:
	int __sizeOutputTokensAvailable;	/* sequence of elements <OutputTokensAvailable> of XSD type tt:ReferenceToken */
	char **OutputTokensAvailable;
	int __sizeSendPrimacyOptions;	/* sequence of elements <SendPrimacyOptions> of XSD type xsd:anyURI */
	char **SendPrimacyOptions;
	tt__IntRange *OutputLevelRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfigurationOptions (497)
	virtual int soap_type(void) const { return 497; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfigurationOptions); }
	         tt__AudioOutputConfigurationOptions() { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1028 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (499)
/* tt:AudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions
{
public:
	tt__AACDecOptions *AACDecOptions;	/* optional element of XSD type tt:AACDecOptions */
	tt__G711DecOptions *G711DecOptions;	/* optional element of XSD type tt:G711DecOptions */
	tt__G726DecOptions *G726DecOptions;	/* optional element of XSD type tt:G726DecOptions */
	tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:AudioDecoderConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptions (499)
	virtual int soap_type(void) const { return 499; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptions); }
	         tt__AudioDecoderConfigurationOptions() { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1031 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (500)
/* tt:G711DecOptions complex type: */
class SOAP_CMAC tt__G711DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G711DecOptions (500)
	virtual int soap_type(void) const { return 500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
	virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G711DecOptions); }
	         tt__G711DecOptions() { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
	friend SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1034 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (501)
/* tt:AACDecOptions complex type: */
class SOAP_CMAC tt__AACDecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AACDecOptions (501)
	virtual int soap_type(void) const { return 501; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
	virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__AACDecOptions); }
	         tt__AACDecOptions() { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
	friend SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1037 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (502)
/* tt:G726DecOptions complex type: */
class SOAP_CMAC tt__G726DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G726DecOptions (502)
	virtual int soap_type(void) const { return 502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
	virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G726DecOptions); }
	         tt__G726DecOptions() { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
	friend SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1040 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (503)
/* tt:AudioDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (503)
	virtual int soap_type(void) const { return 503; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptionsExtension); }
	         tt__AudioDecoderConfigurationOptionsExtension() { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1043 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (504)
/* tt:MulticastConfiguration complex type: */
class SOAP_CMAC tt__MulticastConfiguration
{
public:
	tt__IPAddress *Address;	/* required element of XSD type tt:IPAddress */
	int Port;	/* required element of XSD type xsd:int */
	int TTL;	/* required element of XSD type xsd:int */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MulticastConfiguration (504)
	virtual int soap_type(void) const { return 504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
	virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MulticastConfiguration); }
	         tt__MulticastConfiguration() { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
	friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1046 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (505)
/* tt:StreamSetup complex type: */
class SOAP_CMAC tt__StreamSetup
{
public:
	enum tt__StreamType Stream;	/* required element of XSD type tt:StreamType */
	tt__Transport *Transport;	/* required element of XSD type tt:Transport */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamSetup (505)
	virtual int soap_type(void) const { return 505; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
	virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW(tt__StreamSetup); }
	         tt__StreamSetup() { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
	friend SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1049 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (506)
/* Type tt__Transport is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transport complex type: */
class SOAP_CMAC tt__Transport
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of XSD type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of XSD type tt:Transport */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transport (506)
	virtual int soap_type(void) const { return 506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transport, default initialized and not managed by a soap context
	virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW(tt__Transport); }
	         tt__Transport() { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
	friend SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1052 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (507)
/* tt:MediaUri complex type: */
class SOAP_CMAC tt__MediaUri
{
public:
	char *Uri;	/* required element of XSD type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of XSD type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of XSD type xsd:boolean */
	LONG64 Timeout;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaUri (507)
	virtual int soap_type(void) const { return 507; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
	virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW(tt__MediaUri); }
	         tt__MediaUri() { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
	friend SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1055 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (508)
/* tt:Scope complex type: */
class SOAP_CMAC tt__Scope
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of XSD type tt:ScopeDefinition */
	char *ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Scope (508)
	virtual int soap_type(void) const { return 508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Scope, default initialized and not managed by a soap context
	virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW(tt__Scope); }
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
	friend SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1061 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (510)
/* tt:NetworkInterfaceExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension
{
public:
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	int __sizeDot3;	/* sequence of elements <Dot3> of XSD type tt:Dot3Configuration */
	tt__Dot3Configuration **Dot3;
	int __sizeDot11;	/* sequence of elements <Dot11> of XSD type tt:Dot11Configuration */
	tt__Dot11Configuration **Dot11;
	tt__NetworkInterfaceExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension (510)
	virtual int soap_type(void) const { return 510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension); }
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1064 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (511)
/* tt:Dot3Configuration complex type: */
class SOAP_CMAC tt__Dot3Configuration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot3Configuration (511)
	virtual int soap_type(void) const { return 511; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
	virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot3Configuration); }
	         tt__Dot3Configuration() { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
	friend SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1067 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (512)
/* tt:NetworkInterfaceExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension2 (512)
	virtual int soap_type(void) const { return 512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension2); }
	         tt__NetworkInterfaceExtension2() { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1070 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (513)
/* tt:NetworkInterfaceLink complex type: */
class SOAP_CMAC tt__NetworkInterfaceLink
{
public:
	tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceLink (513)
	virtual int soap_type(void) const { return 513; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceLink); }
	         tt__NetworkInterfaceLink() { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1073 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (514)
/* tt:NetworkInterfaceConnectionSetting complex type: */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting
{
public:
	bool AutoNegotiation;	/* required element of XSD type xsd:boolean */
	int Speed;	/* required element of XSD type xsd:int */
	enum tt__Duplex Duplex;	/* required element of XSD type tt:Duplex */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (514)
	virtual int soap_type(void) const { return 514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConnectionSetting); }
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1076 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (515)
/* tt:NetworkInterfaceInfo complex type: */
class SOAP_CMAC tt__NetworkInterfaceInfo
{
public:
	char *Name;	/* optional element of XSD type xsd:string */
	char *HwAddress;	/* required element of XSD type tt:HwAddress */
	int *MTU;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceInfo (515)
	virtual int soap_type(void) const { return 515; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceInfo); }
	         tt__NetworkInterfaceInfo() { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1079 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (516)
/* tt:IPv6NetworkInterface complex type: */
class SOAP_CMAC tt__IPv6NetworkInterface
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv6Configuration *Config;	/* optional element of XSD type tt:IPv6Configuration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterface (516)
	virtual int soap_type(void) const { return 516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterface); }
	         tt__IPv6NetworkInterface() { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1082 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (517)
/* tt:IPv4NetworkInterface complex type: */
class SOAP_CMAC tt__IPv4NetworkInterface
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv4Configuration *Config;	/* required element of XSD type tt:IPv4Configuration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterface (517)
	virtual int soap_type(void) const { return 517; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterface); }
	         tt__IPv4NetworkInterface() { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1085 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (518)
/* tt:IPv4Configuration complex type: */
class SOAP_CMAC tt__IPv4Configuration
{
public:
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **Manual;
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Configuration (518)
	virtual int soap_type(void) const { return 518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
	virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Configuration); }
	         tt__IPv4Configuration() { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
	friend SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1088 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (519)
/* tt:IPv6Configuration complex type: */
class SOAP_CMAC tt__IPv6Configuration
{
public:
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of XSD type tt:IPv6DHCPConfiguration */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **Manual;
	int __sizeLinkLocal;	/* sequence of elements <LinkLocal> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **LinkLocal;
	int __sizeFromDHCP;	/* sequence of elements <FromDHCP> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **FromDHCP;
	int __sizeFromRA;	/* sequence of elements <FromRA> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **FromRA;
	tt__IPv6ConfigurationExtension *Extension;	/* optional element of XSD type tt:IPv6ConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Configuration (519)
	virtual int soap_type(void) const { return 519; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
	virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Configuration); }
	         tt__IPv6Configuration() { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
	friend SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1091 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (520)
/* tt:IPv6ConfigurationExtension complex type: */
class SOAP_CMAC tt__IPv6ConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6ConfigurationExtension (520)
	virtual int soap_type(void) const { return 520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPv6ConfigurationExtension); }
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
	friend SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1094 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (521)
/* tt:NetworkProtocol complex type: */
class SOAP_CMAC tt__NetworkProtocol
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of XSD type tt:NetworkProtocolType */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	int __sizePort;	/* sequence of elements <Port> of XSD type xsd:int */
	int *Port;
	tt__NetworkProtocolExtension *Extension;	/* optional element of XSD type tt:NetworkProtocolExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocol (521)
	virtual int soap_type(void) const { return 521; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
	virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocol); }
	         tt__NetworkProtocol() { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
	friend SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1097 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (522)
/* tt:NetworkProtocolExtension complex type: */
class SOAP_CMAC tt__NetworkProtocolExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolExtension (522)
	virtual int soap_type(void) const { return 522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolExtension); }
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
	friend SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1100 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (523)
/* tt:NetworkHost complex type: */
class SOAP_CMAC tt__NetworkHost
{
public:
	enum tt__NetworkHostType Type;	/* required element of XSD type tt:NetworkHostType */
	char *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	char *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	char *DNSname;	/* optional element of XSD type tt:DNSName */
	tt__NetworkHostExtension *Extension;	/* optional element of XSD type tt:NetworkHostExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHost (523)
	virtual int soap_type(void) const { return 523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
	virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHost); }
	         tt__NetworkHost() { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
	friend SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1103 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (524)
/* tt:NetworkHostExtension complex type: */
class SOAP_CMAC tt__NetworkHostExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostExtension (524)
	virtual int soap_type(void) const { return 524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
	virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostExtension); }
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
	friend SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1106 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (525)
/* tt:IPAddress complex type: */
class SOAP_CMAC tt__IPAddress
{
public:
	enum tt__IPType Type;	/* required element of XSD type tt:IPType */
	char *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	char *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddress (525)
	virtual int soap_type(void) const { return 525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
	virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW(tt__IPAddress); }
	         tt__IPAddress() { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
	friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1109 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (526)
/* tt:PrefixedIPv4Address complex type: */
class SOAP_CMAC tt__PrefixedIPv4Address
{
public:
	char *Address;	/* required element of XSD type tt:IPv4Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv4Address (526)
	virtual int soap_type(void) const { return 526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv4Address); }
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1112 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (527)
/* tt:PrefixedIPv6Address complex type: */
class SOAP_CMAC tt__PrefixedIPv6Address
{
public:
	char *Address;	/* required element of XSD type tt:IPv6Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv6Address (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv6Address); }
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1115 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (528)
/* tt:HostnameInformation complex type: */
class SOAP_CMAC tt__HostnameInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	char *Name;	/* optional element of XSD type xsd:token */
	tt__HostnameInformationExtension *Extension;	/* optional element of XSD type tt:HostnameInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformation (528)
	virtual int soap_type(void) const { return 528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
	virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformation); }
	         tt__HostnameInformation() { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
	friend SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1118 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (529)
/* tt:HostnameInformationExtension complex type: */
class SOAP_CMAC tt__HostnameInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformationExtension (529)
	virtual int soap_type(void) const { return 529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
	virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformationExtension); }
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
	friend SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1121 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (530)
/* tt:DNSInformation complex type: */
class SOAP_CMAC tt__DNSInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeSearchDomain;	/* sequence of elements <SearchDomain> of XSD type xsd:token */
	char **SearchDomain;
	int __sizeDNSFromDHCP;	/* sequence of elements <DNSFromDHCP> of XSD type tt:IPAddress */
	tt__IPAddress **DNSFromDHCP;
	int __sizeDNSManual;	/* sequence of elements <DNSManual> of XSD type tt:IPAddress */
	tt__IPAddress **DNSManual;
	tt__DNSInformationExtension *Extension;	/* optional element of XSD type tt:DNSInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformation (530)
	virtual int soap_type(void) const { return 530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
	virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformation); }
	         tt__DNSInformation() { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
	friend SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1124 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (531)
/* tt:DNSInformationExtension complex type: */
class SOAP_CMAC tt__DNSInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformationExtension (531)
	virtual int soap_type(void) const { return 531; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformationExtension); }
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1127 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (532)
/* tt:NTPInformation complex type: */
class SOAP_CMAC tt__NTPInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeNTPFromDHCP;	/* sequence of elements <NTPFromDHCP> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPFromDHCP;
	int __sizeNTPManual;	/* sequence of elements <NTPManual> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPManual;
	tt__NTPInformationExtension *Extension;	/* optional element of XSD type tt:NTPInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformation (532)
	virtual int soap_type(void) const { return 532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
	virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformation); }
	         tt__NTPInformation() { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
	friend SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1130 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (533)
/* tt:NTPInformationExtension complex type: */
class SOAP_CMAC tt__NTPInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformationExtension (533)
	virtual int soap_type(void) const { return 533; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
	virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformationExtension); }
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
	friend SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1133 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (534)
/* tt:DynamicDNSInformation complex type: */
class SOAP_CMAC tt__DynamicDNSInformation
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	char *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	tt__DynamicDNSInformationExtension *Extension;	/* optional element of XSD type tt:DynamicDNSInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformation (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformation); }
	         tt__DynamicDNSInformation() { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1136 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (535)
/* tt:DynamicDNSInformationExtension complex type: */
class SOAP_CMAC tt__DynamicDNSInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformationExtension (535)
	virtual int soap_type(void) const { return 535; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformationExtension); }
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1139 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (536)
/* tt:NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of XSD type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of XSD type xsd:int */
	tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterfaceSetConfiguration */
	tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterfaceSetConfiguration */
	tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (536)
	virtual int soap_type(void) const { return 536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfiguration); }
	         tt__NetworkInterfaceSetConfiguration() { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1142 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (537)
/* tt:NetworkInterfaceSetConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension
{
public:
	int __sizeDot3;	/* sequence of elements <Dot3> of XSD type tt:Dot3Configuration */
	tt__Dot3Configuration **Dot3;
	int __sizeDot11;	/* sequence of elements <Dot11> of XSD type tt:Dot11Configuration */
	tt__Dot11Configuration **Dot11;
	tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (537)
	virtual int soap_type(void) const { return 537; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension); }
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1145 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (538)
/* tt:IPv6NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **Manual;
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of XSD type tt:IPv6DHCPConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (538)
	virtual int soap_type(void) const { return 538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration); }
	         tt__IPv6NetworkInterfaceSetConfiguration() { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1148 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (539)
/* tt:IPv4NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **Manual;
	bool *DHCP;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (539)
	virtual int soap_type(void) const { return 539; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration); }
	         tt__IPv4NetworkInterfaceSetConfiguration() { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1151 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (540)
/* tt:NetworkGateway complex type: */
class SOAP_CMAC tt__NetworkGateway
{
public:
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:IPv4Address */
	char **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:IPv6Address */
	char **IPv6Address;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkGateway (540)
	virtual int soap_type(void) const { return 540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
	virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW(tt__NetworkGateway); }
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
	friend SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1154 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (541)
/* tt:NetworkZeroConfiguration complex type: */
class SOAP_CMAC tt__NetworkZeroConfiguration
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	int __sizeAddresses;	/* sequence of elements <Addresses> of XSD type tt:IPv4Address */
	char **Addresses;
	tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfiguration (541)
	virtual int soap_type(void) const { return 541; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfiguration); }
	         tt__NetworkZeroConfiguration() { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1157 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (542)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension
{
public:
	int __sizeAdditional;	/* sequence of elements <Additional> of XSD type tt:NetworkZeroConfiguration */
	tt__NetworkZeroConfiguration **Additional;
	tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension (542)
	virtual int soap_type(void) const { return 542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension); }
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1160 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (543)
/* tt:NetworkZeroConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (543)
	virtual int soap_type(void) const { return 543; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension2); }
	         tt__NetworkZeroConfigurationExtension2() { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1163 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (544)
/* tt:IPAddressFilter complex type: */
class SOAP_CMAC tt__IPAddressFilter
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of XSD type tt:IPAddressFilterType */
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **IPv6Address;
	tt__IPAddressFilterExtension *Extension;	/* optional element of XSD type tt:IPAddressFilterExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilter (544)
	virtual int soap_type(void) const { return 544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
	virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilter); }
	         tt__IPAddressFilter() { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
	friend SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1166 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (545)
/* tt:IPAddressFilterExtension complex type: */
class SOAP_CMAC tt__IPAddressFilterExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterExtension (545)
	virtual int soap_type(void) const { return 545; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterExtension); }
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
	friend SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1169 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (546)
/* tt:Dot11Configuration complex type: */
class SOAP_CMAC tt__Dot11Configuration
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of XSD type tt:Dot11StationMode */
	char *Alias;	/* required element of XSD type tt:Name */
	char *Priority;	/* required element of XSD type tt:NetworkInterfaceConfigPriority */
	tt__Dot11SecurityConfiguration *Security;	/* required element of XSD type tt:Dot11SecurityConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Configuration (546)
	virtual int soap_type(void) const { return 546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
	virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Configuration); }
	         tt__Dot11Configuration() { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
	friend SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1172 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (547)
/* tt:Dot11SecurityConfiguration complex type: */
class SOAP_CMAC tt__Dot11SecurityConfiguration
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of XSD type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of XSD type tt:Dot11Cipher */
	tt__Dot11PSKSet *PSK;	/* optional element of XSD type tt:Dot11PSKSet */
	char *Dot1X;	/* optional element of XSD type tt:ReferenceToken */
	tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot11SecurityConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfiguration (547)
	virtual int soap_type(void) const { return 547; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfiguration); }
	         tt__Dot11SecurityConfiguration() { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1175 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (548)
/* tt:Dot11SecurityConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (548)
	virtual int soap_type(void) const { return 548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfigurationExtension); }
	         tt__Dot11SecurityConfigurationExtension() { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1178 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (549)
/* tt:Dot11PSKSet complex type: */
class SOAP_CMAC tt__Dot11PSKSet
{
public:
	xsd__hexBinary *Key;	/* optional element of XSD type tt:Dot11PSK */
	char *Passphrase;	/* optional element of XSD type tt:Dot11PSKPassphrase */
	tt__Dot11PSKSetExtension *Extension;	/* optional element of XSD type tt:Dot11PSKSetExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSet (549)
	virtual int soap_type(void) const { return 549; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSet); }
	         tt__Dot11PSKSet() { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
	friend SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1181 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (550)
/* tt:Dot11PSKSetExtension complex type: */
class SOAP_CMAC tt__Dot11PSKSetExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSetExtension (550)
	virtual int soap_type(void) const { return 550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSetExtension); }
	         tt__Dot11PSKSetExtension() { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
	friend SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1184 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (551)
/* tt:NetworkInterfaceSetConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (551)
	virtual int soap_type(void) const { return 551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension2); }
	         tt__NetworkInterfaceSetConfigurationExtension2() { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1187 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (552)
/* tt:Dot11Capabilities complex type: */
class SOAP_CMAC tt__Dot11Capabilities
{
public:
	bool TKIP;	/* required element of XSD type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of XSD type xsd:boolean */
	bool MultipleConfiguration;	/* required element of XSD type xsd:boolean */
	bool AdHocStationMode;	/* required element of XSD type xsd:boolean */
	bool WEP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Capabilities (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
	virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Capabilities); }
	         tt__Dot11Capabilities() { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
	friend SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1190 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (553)
/* tt:Dot11Status complex type: */
class SOAP_CMAC tt__Dot11Status
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of XSD type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	char *ActiveConfigAlias;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Status (553)
	virtual int soap_type(void) const { return 553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
	virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Status); }
	         tt__Dot11Status() { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
	friend SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1193 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (554)
/* tt:Dot11AvailableNetworks complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworks
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of XSD type xsd:string */
	int __sizeAuthAndMangementSuite;	/* sequence of elements <AuthAndMangementSuite> of XSD type tt:Dot11AuthAndMangementSuite */
	enum tt__Dot11AuthAndMangementSuite *AuthAndMangementSuite;
	int __sizePairCipher;	/* sequence of elements <PairCipher> of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *PairCipher;
	int __sizeGroupCipher;	/* sequence of elements <GroupCipher> of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of XSD type tt:Dot11AvailableNetworksExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworks (554)
	virtual int soap_type(void) const { return 554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworks); }
	         tt__Dot11AvailableNetworks() { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1196 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (555)
/* tt:Dot11AvailableNetworksExtension complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworksExtension (555)
	virtual int soap_type(void) const { return 555; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworksExtension); }
	         tt__Dot11AvailableNetworksExtension() { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1199 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (556)
/* tt:Capabilities complex type: */
class SOAP_CMAC tt__Capabilities
{
public:
	tt__AnalyticsCapabilities *Analytics;	/* optional element of XSD type tt:AnalyticsCapabilities */
	tt__DeviceCapabilities *Device;	/* optional element of XSD type tt:DeviceCapabilities */
	tt__EventCapabilities *Events;	/* optional element of XSD type tt:EventCapabilities */
	tt__ImagingCapabilities *Imaging;	/* optional element of XSD type tt:ImagingCapabilities */
	tt__MediaCapabilities *Media;	/* optional element of XSD type tt:MediaCapabilities */
	tt__PTZCapabilities *PTZ;	/* optional element of XSD type tt:PTZCapabilities */
	tt__CapabilitiesExtension *Extension;	/* optional element of XSD type tt:CapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Capabilities (556)
	virtual int soap_type(void) const { return 556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
	virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Capabilities); }
	         tt__Capabilities() { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
	friend SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1202 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (557)
/* tt:CapabilitiesExtension complex type: */
class SOAP_CMAC tt__CapabilitiesExtension
{
public:
	tt__DeviceIOCapabilities *DeviceIO;	/* optional element of XSD type tt:DeviceIOCapabilities */
	tt__DisplayCapabilities *Display;	/* optional element of XSD type tt:DisplayCapabilities */
	tt__RecordingCapabilities *Recording;	/* optional element of XSD type tt:RecordingCapabilities */
	tt__SearchCapabilities *Search;	/* optional element of XSD type tt:SearchCapabilities */
	tt__ReplayCapabilities *Replay;	/* optional element of XSD type tt:ReplayCapabilities */
	tt__ReceiverCapabilities *Receiver;	/* optional element of XSD type tt:ReceiverCapabilities */
	tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of XSD type tt:AnalyticsDeviceCapabilities */
	tt__CapabilitiesExtension2 *Extensions;	/* optional element of XSD type tt:CapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension (557)
	virtual int soap_type(void) const { return 557; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension); }
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1205 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (558)
/* tt:CapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__CapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension2 (558)
	virtual int soap_type(void) const { return 558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension2); }
	         tt__CapabilitiesExtension2() { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1208 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (559)
/* tt:AnalyticsCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool RuleSupport;	/* required element of XSD type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsCapabilities (559)
	virtual int soap_type(void) const { return 559; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsCapabilities); }
	         tt__AnalyticsCapabilities() { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1211 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (560)
/* tt:DeviceCapabilities complex type: */
class SOAP_CMAC tt__DeviceCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	tt__NetworkCapabilities *Network;	/* optional element of XSD type tt:NetworkCapabilities */
	tt__SystemCapabilities *System;	/* optional element of XSD type tt:SystemCapabilities */
	tt__IOCapabilities *IO;	/* optional element of XSD type tt:IOCapabilities */
	tt__SecurityCapabilities *Security;	/* optional element of XSD type tt:SecurityCapabilities */
	tt__DeviceCapabilitiesExtension *Extension;	/* optional element of XSD type tt:DeviceCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilities (560)
	virtual int soap_type(void) const { return 560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilities); }
	         tt__DeviceCapabilities() { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1214 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (561)
/* tt:DeviceCapabilitiesExtension complex type: */
class SOAP_CMAC tt__DeviceCapabilitiesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilitiesExtension (561)
	virtual int soap_type(void) const { return 561; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilitiesExtension); }
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1217 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (562)
/* tt:EventCapabilities complex type: */
class SOAP_CMAC tt__EventCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of XSD type xsd:boolean */
	bool WSPullPointSupport;	/* required element of XSD type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventCapabilities (562)
	virtual int soap_type(void) const { return 562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
	virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__EventCapabilities); }
	         tt__EventCapabilities() { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
	friend SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1220 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (563)
/* tt:IOCapabilities complex type: */
class SOAP_CMAC tt__IOCapabilities
{
public:
	int *InputConnectors;	/* optional element of XSD type xsd:int */
	int *RelayOutputs;	/* optional element of XSD type xsd:int */
	tt__IOCapabilitiesExtension *Extension;	/* optional element of XSD type tt:IOCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilities (563)
	virtual int soap_type(void) const { return 563; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
	virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilities); }
	         tt__IOCapabilities() { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
	friend SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1223 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (564)
/* tt:IOCapabilitiesExtension complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension
{
public:
	bool *Auxiliary;	/* optional element of XSD type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> of XSD type tt:AuxiliaryData */
	char **AuxiliaryCommands;
	tt__IOCapabilitiesExtension2 *Extension;	/* required element of XSD type tt:IOCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension (564)
	virtual int soap_type(void) const { return 564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension); }
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1226 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (565)
/* tt:IOCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension2 (565)
	virtual int soap_type(void) const { return 565; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension2); }
	         tt__IOCapabilitiesExtension2() { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1229 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (566)
/* tt:MediaCapabilities complex type: */
class SOAP_CMAC tt__MediaCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of XSD type tt:RealTimeStreamingCapabilities */
	tt__MediaCapabilitiesExtension *Extension;	/* optional element of XSD type tt:MediaCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilities (566)
	virtual int soap_type(void) const { return 566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
	virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilities); }
	         tt__MediaCapabilities() { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
	friend SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1232 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (567)
/* tt:MediaCapabilitiesExtension complex type: */
class SOAP_CMAC tt__MediaCapabilitiesExtension
{
public:
	tt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type tt:ProfileCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilitiesExtension (567)
	virtual int soap_type(void) const { return 567; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilitiesExtension); }
	         tt__MediaCapabilitiesExtension() { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1235 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (568)
/* tt:RealTimeStreamingCapabilities complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilities
{
public:
	bool *RTPMulticast;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of XSD type tt:RealTimeStreamingCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilities (568)
	virtual int soap_type(void) const { return 568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilities); }
	         tt__RealTimeStreamingCapabilities() { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1238 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (569)
/* tt:RealTimeStreamingCapabilitiesExtension complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (569)
	virtual int soap_type(void) const { return 569; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension); }
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1241 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (570)
/* tt:ProfileCapabilities complex type: */
class SOAP_CMAC tt__ProfileCapabilities
{
public:
	int MaximumNumberOfProfiles;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileCapabilities (570)
	virtual int soap_type(void) const { return 570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ProfileCapabilities); }
	         tt__ProfileCapabilities() { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
	friend SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1244 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (571)
/* tt:NetworkCapabilities complex type: */
class SOAP_CMAC tt__NetworkCapabilities
{
public:
	bool *IPFilter;	/* optional element of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional element of XSD type xsd:boolean */
	bool *DynDNS;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilities (571)
	virtual int soap_type(void) const { return 571; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilities); }
	         tt__NetworkCapabilities() { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
	friend SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1247 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (572)
/* tt:NetworkCapabilitiesExtension complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension
{
public:
	bool *Dot11Configuration;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension (572)
	virtual int soap_type(void) const { return 572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension); }
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1250 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (573)
/* tt:NetworkCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (573)
	virtual int soap_type(void) const { return 573; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension2); }
	         tt__NetworkCapabilitiesExtension2() { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1253 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (574)
/* tt:SecurityCapabilities complex type: */
class SOAP_CMAC tt__SecurityCapabilities
{
public:
	bool TLS1_x002e1;	/* required element of XSD type xsd:boolean */
	bool TLS1_x002e2;	/* required element of XSD type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of XSD type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of XSD type xsd:boolean */
	bool X_x002e509Token;	/* required element of XSD type xsd:boolean */
	bool SAMLToken;	/* required element of XSD type xsd:boolean */
	bool KerberosToken;	/* required element of XSD type xsd:boolean */
	bool RELToken;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilities (574)
	virtual int soap_type(void) const { return 574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilities); }
	         tt__SecurityCapabilities() { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
	friend SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1256 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (575)
/* tt:SecurityCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension
{
public:
	bool TLS1_x002e0;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension (575)
	virtual int soap_type(void) const { return 575; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension); }
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1259 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (576)
/* tt:SecurityCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2
{
public:
	bool Dot1X;	/* required element of XSD type xsd:boolean */
	int __sizeSupportedEAPMethod;	/* sequence of elements <SupportedEAPMethod> of XSD type xsd:int */
	int *SupportedEAPMethod;
	bool RemoteUserHandling;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (576)
	virtual int soap_type(void) const { return 576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension2); }
	         tt__SecurityCapabilitiesExtension2() { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1262 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (577)
/* tt:SystemCapabilities complex type: */
class SOAP_CMAC tt__SystemCapabilities
{
public:
	bool DiscoveryResolve;	/* required element of XSD type xsd:boolean */
	bool DiscoveryBye;	/* required element of XSD type xsd:boolean */
	bool RemoteDiscovery;	/* required element of XSD type xsd:boolean */
	bool SystemBackup;	/* required element of XSD type xsd:boolean */
	bool SystemLogging;	/* required element of XSD type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of XSD type xsd:boolean */
	int __sizeSupportedVersions;	/* sequence of elements <SupportedVersions> of XSD type tt:OnvifVersion */
	tt__OnvifVersion **SupportedVersions;
	tt__SystemCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilities (577)
	virtual int soap_type(void) const { return 577; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
	virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilities); }
	         tt__SystemCapabilities() { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
	friend SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1265 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (578)
/* tt:SystemCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension
{
public:
	bool *HttpFirmwareUpgrade;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of XSD type xsd:boolean */
	tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension (578)
	virtual int soap_type(void) const { return 578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension); }
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1268 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (579)
/* tt:SystemCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension2 (579)
	virtual int soap_type(void) const { return 579; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension2); }
	         tt__SystemCapabilitiesExtension2() { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1271 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (580)
/* tt:OnvifVersion complex type: */
class SOAP_CMAC tt__OnvifVersion
{
public:
	int Major;	/* required element of XSD type xsd:int */
	int Minor;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OnvifVersion (580)
	virtual int soap_type(void) const { return 580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
	virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW(tt__OnvifVersion); }
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
	friend SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1274 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (581)
/* tt:ImagingCapabilities complex type: */
class SOAP_CMAC tt__ImagingCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingCapabilities (581)
	virtual int soap_type(void) const { return 581; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
	virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ImagingCapabilities); }
	         tt__ImagingCapabilities() { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
	friend SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1277 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (582)
/* tt:PTZCapabilities complex type: */
class SOAP_CMAC tt__PTZCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZCapabilities (582)
	virtual int soap_type(void) const { return 582; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
	virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__PTZCapabilities); }
	         tt__PTZCapabilities() { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
	friend SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1280 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (583)
/* tt:DeviceIOCapabilities complex type: */
class SOAP_CMAC tt__DeviceIOCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	int VideoSources;	/* required element of XSD type xsd:int */
	int VideoOutputs;	/* required element of XSD type xsd:int */
	int AudioSources;	/* required element of XSD type xsd:int */
	int AudioOutputs;	/* required element of XSD type xsd:int */
	int RelayOutputs;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceIOCapabilities (583)
	virtual int soap_type(void) const { return 583; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceIOCapabilities); }
	         tt__DeviceIOCapabilities() { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1283 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (584)
/* tt:DisplayCapabilities complex type: */
class SOAP_CMAC tt__DisplayCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool FixedLayout;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DisplayCapabilities (584)
	virtual int soap_type(void) const { return 584; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
	virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DisplayCapabilities); }
	         tt__DisplayCapabilities() { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
	friend SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1286 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (585)
/* tt:RecordingCapabilities complex type: */
class SOAP_CMAC tt__RecordingCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool ReceiverSource;	/* required element of XSD type xsd:boolean */
	bool MediaProfileSource;	/* required element of XSD type xsd:boolean */
	bool DynamicRecordings;	/* required element of XSD type xsd:boolean */
	bool DynamicTracks;	/* required element of XSD type xsd:boolean */
	int MaxStringLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingCapabilities (585)
	virtual int soap_type(void) const { return 585; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
	virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RecordingCapabilities); }
	         tt__RecordingCapabilities() { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
	friend SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1289 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (586)
/* tt:SearchCapabilities complex type: */
class SOAP_CMAC tt__SearchCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool MetadataSearch;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchCapabilities (586)
	virtual int soap_type(void) const { return 586; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
	virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SearchCapabilities); }
	         tt__SearchCapabilities() { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
	friend SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1292 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (587)
/* tt:ReplayCapabilities complex type: */
class SOAP_CMAC tt__ReplayCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayCapabilities (587)
	virtual int soap_type(void) const { return 587; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
	virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReplayCapabilities); }
	         tt__ReplayCapabilities() { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
	friend SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1295 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (588)
/* tt:ReceiverCapabilities complex type: */
class SOAP_CMAC tt__ReceiverCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of XSD type xsd:boolean */
	int SupportedReceivers;	/* required element of XSD type xsd:int */
	int MaximumRTSPURILength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverCapabilities (588)
	virtual int soap_type(void) const { return 588; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
	virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverCapabilities); }
	         tt__ReceiverCapabilities() { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
	friend SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1298 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (589)
/* tt:AnalyticsDeviceCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool *RuleSupport;	/* optional element of XSD type xsd:boolean */
	tt__AnalyticsDeviceExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceCapabilities (589)
	virtual int soap_type(void) const { return 589; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceCapabilities); }
	         tt__AnalyticsDeviceCapabilities() { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1301 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (590)
/* tt:AnalyticsDeviceExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceExtension (590)
	virtual int soap_type(void) const { return 590; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceExtension); }
	         tt__AnalyticsDeviceExtension() { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1304 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (591)
/* tt:SystemLog complex type: */
class SOAP_CMAC tt__SystemLog
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	char *String;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLog (591)
	virtual int soap_type(void) const { return 591; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
	virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW(tt__SystemLog); }
	         tt__SystemLog() { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
	friend SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1307 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (592)
/* tt:SupportInformation complex type: */
class SOAP_CMAC tt__SupportInformation
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	char *String;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportInformation (592)
	virtual int soap_type(void) const { return 592; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
	virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW(tt__SupportInformation); }
	         tt__SupportInformation() { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
	friend SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1310 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (593)
/* tt:BinaryData complex type: */
class SOAP_CMAC tt__BinaryData
{
public:
	xsd__base64Binary Data;	/* required element of XSD type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BinaryData (593)
	virtual int soap_type(void) const { return 593; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
	virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW(tt__BinaryData); }
	         tt__BinaryData() { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
	friend SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1313 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (594)
/* tt:AttachmentData complex type: */
class SOAP_CMAC tt__AttachmentData
{
public:
	struct _xop__Include xop__Include;	/* required element of XSD type xop:Include */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AttachmentData (594)
	virtual int soap_type(void) const { return 594; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
	virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW(tt__AttachmentData); }
	         tt__AttachmentData() { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
	friend SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1316 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (595)
/* tt:BackupFile complex type: */
class SOAP_CMAC tt__BackupFile
{
public:
	char *Name;	/* required element of XSD type xsd:string */
	tt__AttachmentData *Data;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BackupFile (595)
	virtual int soap_type(void) const { return 595; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
	virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW(tt__BackupFile); }
	         tt__BackupFile() { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
	friend SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1319 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (596)
/* tt:SystemLogUriList complex type: */
class SOAP_CMAC tt__SystemLogUriList
{
public:
	int __sizeSystemLog;	/* sequence of elements <SystemLog> of XSD type tt:SystemLogUri */
	tt__SystemLogUri **SystemLog;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUriList (596)
	virtual int soap_type(void) const { return 596; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
	virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUriList); }
	         tt__SystemLogUriList() { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
	friend SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1322 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (597)
/* tt:SystemLogUri complex type: */
class SOAP_CMAC tt__SystemLogUri
{
public:
	enum tt__SystemLogType Type;	/* required element of XSD type tt:SystemLogType */
	char *Uri;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUri (597)
	virtual int soap_type(void) const { return 597; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
	virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUri); }
	         tt__SystemLogUri() { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
	friend SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1325 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (598)
/* tt:SystemDateTime complex type: */
class SOAP_CMAC tt__SystemDateTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of XSD type tt:DateTime */
	tt__SystemDateTimeExtension *Extension;	/* optional element of XSD type tt:SystemDateTimeExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTime (598)
	virtual int soap_type(void) const { return 598; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
	virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTime); }
	         tt__SystemDateTime() { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
	friend SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1328 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (599)
/* tt:SystemDateTimeExtension complex type: */
class SOAP_CMAC tt__SystemDateTimeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTimeExtension (599)
	virtual int soap_type(void) const { return 599; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
	virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTimeExtension); }
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
	friend SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1331 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (600)
/* tt:DateTime complex type: */
class SOAP_CMAC tt__DateTime
{
public:
	tt__Time *Time;	/* required element of XSD type tt:Time */
	tt__Date *Date;	/* required element of XSD type tt:Date */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTime (600)
	virtual int soap_type(void) const { return 600; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
	virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW(tt__DateTime); }
	         tt__DateTime() { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
	friend SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1334 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (601)
/* tt:Date complex type: */
class SOAP_CMAC tt__Date
{
public:
	int Year;	/* required element of XSD type xsd:int */
	int Month;	/* required element of XSD type xsd:int */
	int Day;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Date (601)
	virtual int soap_type(void) const { return 601; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Date, default initialized and not managed by a soap context
	virtual tt__Date *soap_alloc(void) const { return SOAP_NEW(tt__Date); }
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
	friend SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1337 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (602)
/* tt:Time complex type: */
class SOAP_CMAC tt__Time
{
public:
	int Hour;	/* required element of XSD type xsd:int */
	int Minute;	/* required element of XSD type xsd:int */
	int Second;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Time (602)
	virtual int soap_type(void) const { return 602; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Time, default initialized and not managed by a soap context
	virtual tt__Time *soap_alloc(void) const { return SOAP_NEW(tt__Time); }
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
	friend SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1340 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (603)
/* tt:TimeZone complex type: */
class SOAP_CMAC tt__TimeZone
{
public:
	char *TZ;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TimeZone (603)
	virtual int soap_type(void) const { return 603; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
	virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW(tt__TimeZone); }
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
	friend SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1343 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (604)
/* tt:RemoteUser complex type: */
class SOAP_CMAC tt__RemoteUser
{
public:
	char *Username;	/* required element of XSD type xsd:string */
	char *Password;	/* optional element of XSD type xsd:string */
	bool UseDerivedPassword;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RemoteUser (604)
	virtual int soap_type(void) const { return 604; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
	virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW(tt__RemoteUser); }
	         tt__RemoteUser() { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
	friend SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1346 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (605)
/* tt:User complex type: */
class SOAP_CMAC tt__User
{
public:
	char *Username;	/* required element of XSD type xsd:string */
	char *Password;	/* optional element of XSD type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of XSD type tt:UserLevel */
	tt__UserExtension *Extension;	/* optional element of XSD type tt:UserExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__User (605)
	virtual int soap_type(void) const { return 605; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__User, default initialized and not managed by a soap context
	virtual tt__User *soap_alloc(void) const { return SOAP_NEW(tt__User); }
	         tt__User() { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
	friend SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1349 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (606)
/* tt:UserExtension complex type: */
class SOAP_CMAC tt__UserExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserExtension (606)
	virtual int soap_type(void) const { return 606; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
	virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW(tt__UserExtension); }
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
	friend SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1352 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (607)
/* tt:CertificateGenerationParameters complex type: */
class SOAP_CMAC tt__CertificateGenerationParameters
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	char *ValidNotBefore;	/* optional element of XSD type xsd:token */
	char *ValidNotAfter;	/* optional element of XSD type xsd:token */
	tt__CertificateGenerationParametersExtension *Extension;	/* optional element of XSD type tt:CertificateGenerationParametersExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParameters (607)
	virtual int soap_type(void) const { return 607; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParameters, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParameters); }
	         tt__CertificateGenerationParameters() { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1355 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (608)
/* tt:CertificateGenerationParametersExtension complex type: */
class SOAP_CMAC tt__CertificateGenerationParametersExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParametersExtension (608)
	virtual int soap_type(void) const { return 608; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParametersExtension); }
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1358 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (609)
/* tt:Certificate complex type: */
class SOAP_CMAC tt__Certificate
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Certificate (609)
	virtual int soap_type(void) const { return 609; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
	virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW(tt__Certificate); }
	         tt__Certificate() { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
	friend SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1361 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (610)
/* tt:CertificateStatus complex type: */
class SOAP_CMAC tt__CertificateStatus
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	bool Status;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateStatus (610)
	virtual int soap_type(void) const { return 610; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
	virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW(tt__CertificateStatus); }
	         tt__CertificateStatus() { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
	friend SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1364 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (611)
/* tt:CertificateWithPrivateKey complex type: */
class SOAP_CMAC tt__CertificateWithPrivateKey
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateWithPrivateKey (611)
	virtual int soap_type(void) const { return 611; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(tt__CertificateWithPrivateKey); }
	         tt__CertificateWithPrivateKey() { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
	friend SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1367 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (612)
/* tt:CertificateInformation complex type: */
class SOAP_CMAC tt__CertificateInformation
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	char *IssuerDN;	/* optional element of XSD type xsd:string */
	char *SubjectDN;	/* optional element of XSD type xsd:string */
	tt__CertificateUsage *KeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	int *KeyLength;	/* optional element of XSD type xsd:int */
	char *Version;	/* optional element of XSD type xsd:string */
	char *SerialNum;	/* optional element of XSD type xsd:string */
	char *SignatureAlgorithm;	/* optional element of XSD type xsd:string */
	tt__DateTimeRange *Validity;	/* optional element of XSD type tt:DateTimeRange */
	tt__CertificateInformationExtension *Extension;	/* optional element of XSD type tt:CertificateInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformation (612)
	virtual int soap_type(void) const { return 612; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
	virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformation); }
	         tt__CertificateInformation() { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
	friend SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1373 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (614)
/* tt:CertificateInformationExtension complex type: */
class SOAP_CMAC tt__CertificateInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformationExtension (614)
	virtual int soap_type(void) const { return 614; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
	virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformationExtension); }
	         tt__CertificateInformationExtension() { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
	friend SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1376 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (615)
/* tt:Dot1XConfiguration complex type: */
class SOAP_CMAC tt__Dot1XConfiguration
{
public:
	char *Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	char *Identity;	/* required element of XSD type xsd:string */
	char *AnonymousID;	/* optional element of XSD type xsd:string */
	int EAPMethod;	/* required element of XSD type xsd:int */
	int __sizeCACertificateID;	/* sequence of elements <CACertificateID> of XSD type xsd:token */
	char **CACertificateID;
	tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of XSD type tt:EAPMethodConfiguration */
	tt__Dot1XConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot1XConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfiguration (615)
	virtual int soap_type(void) const { return 615; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfiguration); }
	         tt__Dot1XConfiguration() { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
	friend SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1379 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (616)
/* tt:Dot1XConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot1XConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfigurationExtension (616)
	virtual int soap_type(void) const { return 616; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfigurationExtension); }
	         tt__Dot1XConfigurationExtension() { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1382 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (617)
/* tt:EAPMethodConfiguration complex type: */
class SOAP_CMAC tt__EAPMethodConfiguration
{
public:
	tt__TLSConfiguration *TLSConfiguration;	/* optional element of XSD type tt:TLSConfiguration */
	char *Password;	/* optional element of XSD type xsd:string */
	tt__EapMethodExtension *Extension;	/* optional element of XSD type tt:EapMethodExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EAPMethodConfiguration (617)
	virtual int soap_type(void) const { return 617; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
	virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EAPMethodConfiguration); }
	         tt__EAPMethodConfiguration() { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
	friend SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1385 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (618)
/* tt:EapMethodExtension complex type: */
class SOAP_CMAC tt__EapMethodExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EapMethodExtension (618)
	virtual int soap_type(void) const { return 618; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
	virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW(tt__EapMethodExtension); }
	         tt__EapMethodExtension() { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
	friend SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1388 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (619)
/* tt:TLSConfiguration complex type: */
class SOAP_CMAC tt__TLSConfiguration
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TLSConfiguration (619)
	virtual int soap_type(void) const { return 619; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
	virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TLSConfiguration); }
	         tt__TLSConfiguration() { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
	friend SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1391 */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (620)
/* tt:GenericEapPwdConfigurationExtension complex type: */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (620)
	virtual int soap_type(void) const { return 620; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__GenericEapPwdConfigurationExtension); }
	         tt__GenericEapPwdConfigurationExtension() { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
	friend SOAP_FMAC1 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1394 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (621)
/* tt:RelayOutputSettings complex type: */
class SOAP_CMAC tt__RelayOutputSettings
{
public:
	enum tt__RelayMode Mode;	/* required element of XSD type tt:RelayMode */
	LONG64 DelayTime;	/* external (custom serializer) */
	enum tt__RelayIdleState IdleState;	/* required element of XSD type tt:RelayIdleState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutputSettings (621)
	virtual int soap_type(void) const { return 621; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
	virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutputSettings); }
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
	friend SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1406 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (625)
/* tt:PTZNodeExtension complex type: */
class SOAP_CMAC tt__PTZNodeExtension
{
public:
	tt__PTZPresetTourSupported *SupportedPresetTour;	/* optional element of XSD type tt:PTZPresetTourSupported */
	tt__PTZNodeExtension2 *Extension;	/* optional element of XSD type tt:PTZNodeExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension (625)
	virtual int soap_type(void) const { return 625; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension); }
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1409 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (626)
/* tt:PTZNodeExtension2 complex type: */
class SOAP_CMAC tt__PTZNodeExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension2 (626)
	virtual int soap_type(void) const { return 626; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension2); }
	         tt__PTZNodeExtension2() { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1412 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (627)
/* tt:PTZPresetTourSupported complex type: */
class SOAP_CMAC tt__PTZPresetTourSupported
{
public:
	int MaximumNumberOfPresetTours;	/* required element of XSD type xsd:int */
	int __sizePTZPresetTourOperation;	/* sequence of elements <PTZPresetTourOperation> of XSD type tt:PTZPresetTourOperation */
	enum tt__PTZPresetTourOperation *PTZPresetTourOperation;
	tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSupportedExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupported (627)
	virtual int soap_type(void) const { return 627; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupported); }
	         tt__PTZPresetTourSupported() { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1415 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (628)
/* tt:PTZPresetTourSupportedExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupportedExtension (628)
	virtual int soap_type(void) const { return 628; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupportedExtension); }
	         tt__PTZPresetTourSupportedExtension() { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1421 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (630)
/* tt:PTZConfigurationExtension complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension
{
public:
	tt__PTControlDirection *PTControlDirection;	/* optional element of XSD type tt:PTControlDirection */
	tt__PTZConfigurationExtension2 *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension (630)
	virtual int soap_type(void) const { return 630; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension); }
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1424 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (631)
/* tt:PTZConfigurationExtension2 complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension2 (631)
	virtual int soap_type(void) const { return 631; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension2); }
	         tt__PTZConfigurationExtension2() { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1427 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (632)
/* tt:PTControlDirection complex type: */
class SOAP_CMAC tt__PTControlDirection
{
public:
	tt__EFlip *EFlip;	/* optional element of XSD type tt:EFlip */
	tt__Reverse *Reverse;	/* optional element of XSD type tt:Reverse */
	tt__PTControlDirectionExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirection (632)
	virtual int soap_type(void) const { return 632; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
	virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirection); }
	         tt__PTControlDirection() { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
	friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1430 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (633)
/* tt:PTControlDirectionExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionExtension (633)
	virtual int soap_type(void) const { return 633; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionExtension); }
	         tt__PTControlDirectionExtension() { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1433 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (634)
/* tt:EFlip complex type: */
class SOAP_CMAC tt__EFlip
{
public:
	enum tt__EFlipMode Mode;	/* required element of XSD type tt:EFlipMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlip (634)
	virtual int soap_type(void) const { return 634; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
	virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW(tt__EFlip); }
	         tt__EFlip() { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
	friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1436 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (635)
/* tt:Reverse complex type: */
class SOAP_CMAC tt__Reverse
{
public:
	enum tt__ReverseMode Mode;	/* required element of XSD type tt:ReverseMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Reverse (635)
	virtual int soap_type(void) const { return 635; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
	virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW(tt__Reverse); }
	         tt__Reverse() { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
	friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1439 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (636)
/* tt:PTZConfigurationOptions complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions
{
public:
	tt__PTZSpaces *Spaces;	/* required element of XSD type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of XSD type tt:DurationRange */
	tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of XSD type tt:PTControlDirectionOptions */
	tt__PTZConfigurationOptions2 *Extension;	/* optional element of XSD type tt:PTZConfigurationOptions2 */
	char *PTZRamps;	/* optional attribute of XSD type tt:IntAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions (636)
	virtual int soap_type(void) const { return 636; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions); }
	         tt__PTZConfigurationOptions() { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1442 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (637)
/* tt:PTZConfigurationOptions2 complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions2 (637)
	virtual int soap_type(void) const { return 637; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions2); }
	         tt__PTZConfigurationOptions2() { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1445 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (638)
/* tt:PTControlDirectionOptions complex type: */
class SOAP_CMAC tt__PTControlDirectionOptions
{
public:
	tt__EFlipOptions *EFlip;	/* optional element of XSD type tt:EFlipOptions */
	tt__ReverseOptions *Reverse;	/* optional element of XSD type tt:ReverseOptions */
	tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptions (638)
	virtual int soap_type(void) const { return 638; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptions); }
	         tt__PTControlDirectionOptions() { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1448 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (639)
/* tt:PTControlDirectionOptionsExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptionsExtension (639)
	virtual int soap_type(void) const { return 639; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptionsExtension); }
	         tt__PTControlDirectionOptionsExtension() { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1451 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (640)
/* tt:EFlipOptions complex type: */
class SOAP_CMAC tt__EFlipOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:EFlipMode */
	enum tt__EFlipMode *Mode;
	tt__EFlipOptionsExtension *Extension;	/* optional element of XSD type tt:EFlipOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptions (640)
	virtual int soap_type(void) const { return 640; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
	virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptions); }
	         tt__EFlipOptions() { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
	friend SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1454 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (641)
/* tt:EFlipOptionsExtension complex type: */
class SOAP_CMAC tt__EFlipOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptionsExtension (641)
	virtual int soap_type(void) const { return 641; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
	virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptionsExtension); }
	         tt__EFlipOptionsExtension() { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
	friend SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1457 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (642)
/* tt:ReverseOptions complex type: */
class SOAP_CMAC tt__ReverseOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ReverseMode */
	enum tt__ReverseMode *Mode;
	tt__ReverseOptionsExtension *Extension;	/* optional element of XSD type tt:ReverseOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptions (642)
	virtual int soap_type(void) const { return 642; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
	virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptions); }
	         tt__ReverseOptions() { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
	friend SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1460 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (643)
/* tt:ReverseOptionsExtension complex type: */
class SOAP_CMAC tt__ReverseOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptionsExtension (643)
	virtual int soap_type(void) const { return 643; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptionsExtension); }
	         tt__ReverseOptionsExtension() { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
	friend SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1463 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (644)
/* tt:PanTiltLimits complex type: */
class SOAP_CMAC tt__PanTiltLimits
{
public:
	tt__Space2DDescription *Range;	/* required element of XSD type tt:Space2DDescription */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PanTiltLimits (644)
	virtual int soap_type(void) const { return 644; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
	virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW(tt__PanTiltLimits); }
	         tt__PanTiltLimits() { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
	friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1466 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (645)
/* tt:ZoomLimits complex type: */
class SOAP_CMAC tt__ZoomLimits
{
public:
	tt__Space1DDescription *Range;	/* required element of XSD type tt:Space1DDescription */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ZoomLimits (645)
	virtual int soap_type(void) const { return 645; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
	virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW(tt__ZoomLimits); }
	         tt__ZoomLimits() { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
	friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1469 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (646)
/* tt:PTZSpaces complex type: */
class SOAP_CMAC tt__PTZSpaces
{
public:
	int __sizeAbsolutePanTiltPositionSpace;	/* sequence of elements <AbsolutePanTiltPositionSpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **AbsolutePanTiltPositionSpace;
	int __sizeAbsoluteZoomPositionSpace;	/* sequence of elements <AbsoluteZoomPositionSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **AbsoluteZoomPositionSpace;
	int __sizeRelativePanTiltTranslationSpace;	/* sequence of elements <RelativePanTiltTranslationSpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **RelativePanTiltTranslationSpace;
	int __sizeRelativeZoomTranslationSpace;	/* sequence of elements <RelativeZoomTranslationSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **RelativeZoomTranslationSpace;
	int __sizeContinuousPanTiltVelocitySpace;	/* sequence of elements <ContinuousPanTiltVelocitySpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **ContinuousPanTiltVelocitySpace;
	int __sizeContinuousZoomVelocitySpace;	/* sequence of elements <ContinuousZoomVelocitySpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **ContinuousZoomVelocitySpace;
	int __sizePanTiltSpeedSpace;	/* sequence of elements <PanTiltSpeedSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **PanTiltSpeedSpace;
	int __sizeZoomSpeedSpace;	/* sequence of elements <ZoomSpeedSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **ZoomSpeedSpace;
	tt__PTZSpacesExtension *Extension;	/* optional element of XSD type tt:PTZSpacesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpaces (646)
	virtual int soap_type(void) const { return 646; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
	virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpaces); }
	         tt__PTZSpaces() { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
	friend SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1472 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (647)
/* tt:PTZSpacesExtension complex type: */
class SOAP_CMAC tt__PTZSpacesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpacesExtension (647)
	virtual int soap_type(void) const { return 647; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
	virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpacesExtension); }
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
	friend SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1475 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (648)
/* tt:Space2DDescription complex type: */
class SOAP_CMAC tt__Space2DDescription
{
public:
	char *URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space2DDescription (648)
	virtual int soap_type(void) const { return 648; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
	virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space2DDescription); }
	         tt__Space2DDescription() { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
	friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1478 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (649)
/* tt:Space1DDescription complex type: */
class SOAP_CMAC tt__Space1DDescription
{
public:
	char *URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space1DDescription (649)
	virtual int soap_type(void) const { return 649; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
	virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space1DDescription); }
	         tt__Space1DDescription() { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
	friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1481 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (650)
/* tt:PTZSpeed complex type: */
class SOAP_CMAC tt__PTZSpeed
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpeed (650)
	virtual int soap_type(void) const { return 650; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
	virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpeed); }
	         tt__PTZSpeed() { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
	friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1484 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (651)
/* tt:PTZPreset complex type: */
class SOAP_CMAC tt__PTZPreset
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of XSD type tt:PTZVector */
	char *token;	/* optional attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPreset (651)
	virtual int soap_type(void) const { return 651; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
	virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW(tt__PTZPreset); }
	         tt__PTZPreset() { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
	friend SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1487 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (652)
/* tt:PresetTour complex type: */
class SOAP_CMAC tt__PresetTour
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZPresetTourStatus *Status;	/* required element of XSD type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingCondition */
	int __sizeTourSpot;	/* sequence of elements <TourSpot> of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourSpot **TourSpot;
	tt__PTZPresetTourExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourExtension */
	char *token;	/* optional attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PresetTour (652)
	virtual int soap_type(void) const { return 652; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
	virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW(tt__PresetTour); }
	         tt__PresetTour() { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
	friend SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1490 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (653)
/* tt:PTZPresetTourExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourExtension (653)
	virtual int soap_type(void) const { return 653; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourExtension); }
	         tt__PTZPresetTourExtension() { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1493 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (654)
/* tt:PTZPresetTourSpot complex type: */
class SOAP_CMAC tt__PTZPresetTourSpot
{
public:
	tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *StayTime;	/* optional element of XSD type xsd:duration */
	tt__PTZPresetTourSpotExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSpotExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpot (654)
	virtual int soap_type(void) const { return 654; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpot); }
	         tt__PTZPresetTourSpot() { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1496 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (655)
/* tt:PTZPresetTourSpotExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotExtension (655)
	virtual int soap_type(void) const { return 655; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotExtension); }
	         tt__PTZPresetTourSpotExtension() { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:15881 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1472)
/* xsd:choice complex type: */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	char *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvif.h:1499 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (656)
/* Choice: */
class SOAP_CMAC tt__PTZPresetTourPresetDetail
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetail (656)
	virtual int soap_type(void) const { return 656; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetail); }
	         tt__PTZPresetTourPresetDetail() { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1502 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (657)
/* tt:PTZPresetTourTypeExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourTypeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourTypeExtension (657)
	virtual int soap_type(void) const { return 657; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourTypeExtension); }
	         tt__PTZPresetTourTypeExtension() { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1505 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (658)
/* tt:PTZPresetTourStatus complex type: */
class SOAP_CMAC tt__PTZPresetTourStatus
{
public:
	enum tt__PTZPresetTourState State;	/* required element of XSD type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourStatusExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStatusExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatus (658)
	virtual int soap_type(void) const { return 658; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatus); }
	         tt__PTZPresetTourStatus() { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1508 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (659)
/* tt:PTZPresetTourStatusExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStatusExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatusExtension (659)
	virtual int soap_type(void) const { return 659; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatusExtension); }
	         tt__PTZPresetTourStatusExtension() { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1511 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (660)
/* tt:PTZPresetTourStartingCondition complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingCondition
{
public:
	int *RecurringTime;	/* optional element of XSD type xsd:int */
	LONG64 *RecurringDuration;	/* optional element of XSD type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionExtension */
	bool *RandomPresetOrder;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingCondition (660)
	virtual int soap_type(void) const { return 660; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingCondition); }
	         tt__PTZPresetTourStartingCondition() { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1514 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (661)
/* tt:PTZPresetTourStartingConditionExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (661)
	virtual int soap_type(void) const { return 661; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionExtension); }
	         tt__PTZPresetTourStartingConditionExtension() { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1517 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (662)
/* tt:PTZPresetTourOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourOptions
{
public:
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingConditionOptions */
	tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of XSD type tt:PTZPresetTourSpotOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOptions (662)
	virtual int soap_type(void) const { return 662; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOptions); }
	         tt__PTZPresetTourOptions() { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1520 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (663)
/* tt:PTZPresetTourSpotOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotOptions
{
public:
	tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of XSD type tt:DurationRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotOptions (663)
	virtual int soap_type(void) const { return 663; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotOptions); }
	         tt__PTZPresetTourSpotOptions() { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1523 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (664)
/* tt:PTZPresetTourPresetDetailOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions
{
public:
	int __sizePresetToken;	/* sequence of elements <PresetToken> of XSD type tt:ReferenceToken */
	char **PresetToken;
	bool *Home;	/* optional element of XSD type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourPresetDetailOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (664)
	virtual int soap_type(void) const { return 664; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptions); }
	         tt__PTZPresetTourPresetDetailOptions() { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1526 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (665)
/* tt:PTZPresetTourPresetDetailOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (665)
	virtual int soap_type(void) const { return 665; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptionsExtension); }
	         tt__PTZPresetTourPresetDetailOptionsExtension() { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1529 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (666)
/* tt:PTZPresetTourStartingConditionOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions
{
public:
	tt__IntRange *RecurringTime;	/* optional element of XSD type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of XSD type tt:DurationRange */
	int __sizeDirection;	/* sequence of elements <Direction> of XSD type tt:PTZPresetTourDirection */
	enum tt__PTZPresetTourDirection *Direction;
	tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (666)
	virtual int soap_type(void) const { return 666; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptions); }
	         tt__PTZPresetTourStartingConditionOptions() { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1532 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (667)
/* tt:PTZPresetTourStartingConditionOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (667)
	virtual int soap_type(void) const { return 667; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptionsExtension); }
	         tt__PTZPresetTourStartingConditionOptionsExtension() { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1535 */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (668)
/* tt:ImagingStatus complex type: */
class SOAP_CMAC tt__ImagingStatus
{
public:
	tt__FocusStatus *FocusStatus;	/* required element of XSD type tt:FocusStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus (668)
	virtual int soap_type(void) const { return 668; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus, default initialized and not managed by a soap context
	virtual tt__ImagingStatus *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus); }
	         tt__ImagingStatus() { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
	friend SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1538 */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (669)
/* tt:FocusStatus complex type: */
class SOAP_CMAC tt__FocusStatus
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	char *Error;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus (669)
	virtual int soap_type(void) const { return 669; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus, default initialized and not managed by a soap context
	virtual tt__FocusStatus *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus); }
	         tt__FocusStatus() { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
	friend SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1541 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (670)
/* tt:FocusConfiguration complex type: */
class SOAP_CMAC tt__FocusConfiguration
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of XSD type xsd:float */
	float NearLimit;	/* required element of XSD type xsd:float */
	float FarLimit;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration (670)
	virtual int soap_type(void) const { return 670; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration); }
	         tt__FocusConfiguration() { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
	friend SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1544 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (671)
/* tt:ImagingSettings complex type: */
class SOAP_CMAC tt__ImagingSettings
{
public:
	tt__BacklightCompensation *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure *Exposure;	/* optional element of XSD type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of XSD type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange */
	tt__WhiteBalance *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance */
	tt__ImagingSettingsExtension *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings (671)
	virtual int soap_type(void) const { return 671; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
	virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings); }
	         tt__ImagingSettings() { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
	friend SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1547 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (672)
/* tt:ImagingSettingsExtension complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension (672)
	virtual int soap_type(void) const { return 672; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension); }
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1550 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (673)
/* tt:Exposure complex type: */
class SOAP_CMAC tt__Exposure
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* required element of XSD type tt:Rectangle */
	float MinExposureTime;	/* required element of XSD type xsd:float */
	float MaxExposureTime;	/* required element of XSD type xsd:float */
	float MinGain;	/* required element of XSD type xsd:float */
	float MaxGain;	/* required element of XSD type xsd:float */
	float MinIris;	/* required element of XSD type xsd:float */
	float MaxIris;	/* required element of XSD type xsd:float */
	float ExposureTime;	/* required element of XSD type xsd:float */
	float Gain;	/* required element of XSD type xsd:float */
	float Iris;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure (673)
	virtual int soap_type(void) const { return 673; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
	virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW(tt__Exposure); }
	         tt__Exposure() { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
	friend SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1553 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (674)
/* tt:WideDynamicRange complex type: */
class SOAP_CMAC tt__WideDynamicRange
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange (674)
	virtual int soap_type(void) const { return 674; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange); }
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
	friend SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1556 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (675)
/* tt:BacklightCompensation complex type: */
class SOAP_CMAC tt__BacklightCompensation
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation (675)
	virtual int soap_type(void) const { return 675; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation); }
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
	friend SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1559 */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (676)
/* tt:ImagingOptions complex type: */
class SOAP_CMAC tt__ImagingOptions
{
public:
	tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of XSD type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of XSD type tt:FloatRange */
	tt__ExposureOptions *Exposure;	/* required element of XSD type tt:ExposureOptions */
	tt__FocusOptions *Focus;	/* required element of XSD type tt:FocusOptions */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> of XSD type tt:IrCutFilterMode */
	enum tt__IrCutFilterMode *IrCutFilterModes;
	tt__FloatRange *Sharpness;	/* required element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of XSD type tt:WideDynamicRangeOptions */
	tt__WhiteBalanceOptions *WhiteBalance;	/* required element of XSD type tt:WhiteBalanceOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions (676)
	virtual int soap_type(void) const { return 676; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions, default initialized and not managed by a soap context
	virtual tt__ImagingOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions); }
	         tt__ImagingOptions() { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
	friend SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1562 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (677)
/* tt:WideDynamicRangeOptions complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions (677)
	virtual int soap_type(void) const { return 677; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions); }
	         tt__WideDynamicRangeOptions() { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1565 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (678)
/* tt:BacklightCompensationOptions complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions (678)
	virtual int soap_type(void) const { return 678; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions); }
	         tt__BacklightCompensationOptions() { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1568 */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (679)
/* tt:FocusOptions complex type: */
class SOAP_CMAC tt__FocusOptions
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> of XSD type tt:AutoFocusMode */
	enum tt__AutoFocusMode *AutoFocusModes;
	tt__FloatRange *DefaultSpeed;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions (679)
	virtual int soap_type(void) const { return 679; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions, default initialized and not managed by a soap context
	virtual tt__FocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions); }
	         tt__FocusOptions() { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
	friend SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1571 */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (680)
/* tt:ExposureOptions complex type: */
class SOAP_CMAC tt__ExposureOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ExposureMode */
	enum tt__ExposureMode *Mode;
	int __sizePriority;	/* sequence of elements <Priority> of XSD type tt:ExposurePriority */
	enum tt__ExposurePriority *Priority;
	tt__FloatRange *MinExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions (680)
	virtual int soap_type(void) const { return 680; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions, default initialized and not managed by a soap context
	virtual tt__ExposureOptions *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions); }
	         tt__ExposureOptions() { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
	friend SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1574 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (681)
/* tt:WhiteBalanceOptions complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WhiteBalanceMode */
	enum tt__WhiteBalanceMode *Mode;
	tt__FloatRange *YrGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions (681)
	virtual int soap_type(void) const { return 681; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions); }
	         tt__WhiteBalanceOptions() { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1577 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (682)
/* tt:FocusMove complex type: */
class SOAP_CMAC tt__FocusMove
{
public:
	tt__AbsoluteFocus *Absolute;	/* optional element of XSD type tt:AbsoluteFocus */
	tt__RelativeFocus *Relative;	/* optional element of XSD type tt:RelativeFocus */
	tt__ContinuousFocus *Continuous;	/* optional element of XSD type tt:ContinuousFocus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusMove (682)
	virtual int soap_type(void) const { return 682; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
	virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW(tt__FocusMove); }
	         tt__FocusMove() { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
	friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1580 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (683)
/* tt:AbsoluteFocus complex type: */
class SOAP_CMAC tt__AbsoluteFocus
{
public:
	float Position;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocus (683)
	virtual int soap_type(void) const { return 683; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocus); }
	         tt__AbsoluteFocus() { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
	friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1583 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (684)
/* tt:RelativeFocus complex type: */
class SOAP_CMAC tt__RelativeFocus
{
public:
	float Distance;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocus (684)
	virtual int soap_type(void) const { return 684; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
	virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocus); }
	         tt__RelativeFocus() { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
	friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1586 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (685)
/* tt:ContinuousFocus complex type: */
class SOAP_CMAC tt__ContinuousFocus
{
public:
	float Speed;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocus (685)
	virtual int soap_type(void) const { return 685; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
	virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocus); }
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
	friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1589 */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (686)
/* tt:MoveOptions complex type: */
class SOAP_CMAC tt__MoveOptions
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions *Relative;	/* optional element of XSD type tt:RelativeFocusOptions */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions (686)
	virtual int soap_type(void) const { return 686; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions, default initialized and not managed by a soap context
	virtual tt__MoveOptions *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions); }
	         tt__MoveOptions() { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
	friend SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1592 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (687)
/* tt:AbsoluteFocusOptions complex type: */
class SOAP_CMAC tt__AbsoluteFocusOptions
{
public:
	tt__FloatRange *Position;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocusOptions (687)
	virtual int soap_type(void) const { return 687; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocusOptions); }
	         tt__AbsoluteFocusOptions() { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
	friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1595 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (688)
/* tt:RelativeFocusOptions complex type: */
class SOAP_CMAC tt__RelativeFocusOptions
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions (688)
	virtual int soap_type(void) const { return 688; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions); }
	         tt__RelativeFocusOptions() { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1598 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (689)
/* tt:ContinuousFocusOptions complex type: */
class SOAP_CMAC tt__ContinuousFocusOptions
{
public:
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocusOptions (689)
	virtual int soap_type(void) const { return 689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
	virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocusOptions); }
	         tt__ContinuousFocusOptions() { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
	friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1601 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (690)
/* tt:WhiteBalance complex type: */
class SOAP_CMAC tt__WhiteBalance
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float CrGain;	/* required element of XSD type xsd:float */
	float CbGain;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance (690)
	virtual int soap_type(void) const { return 690; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
	virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance); }
	         tt__WhiteBalance() { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
	friend SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1604 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (691)
/* tt:ImagingStatus20 complex type: */
class SOAP_CMAC tt__ImagingStatus20
{
public:
	tt__FocusStatus20 *FocusStatus20;	/* optional element of XSD type tt:FocusStatus20 */
	tt__ImagingStatus20Extension *Extension;	/* optional element of XSD type tt:ImagingStatus20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20 (691)
	virtual int soap_type(void) const { return 691; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20); }
	         tt__ImagingStatus20() { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
	friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1607 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (692)
/* tt:ImagingStatus20Extension complex type: */
class SOAP_CMAC tt__ImagingStatus20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20Extension (692)
	virtual int soap_type(void) const { return 692; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20Extension); }
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
	friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1610 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (693)
/* tt:FocusStatus20 complex type: */
class SOAP_CMAC tt__FocusStatus20
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	char *Error;	/* optional element of XSD type xsd:string */
	tt__FocusStatus20Extension *Extension;	/* optional element of XSD type tt:FocusStatus20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20 (693)
	virtual int soap_type(void) const { return 693; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
	virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20); }
	         tt__FocusStatus20() { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
	friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1613 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (694)
/* tt:FocusStatus20Extension complex type: */
class SOAP_CMAC tt__FocusStatus20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20Extension (694)
	virtual int soap_type(void) const { return 694; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
	virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20Extension); }
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
	friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1616 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (695)
/* tt:ImagingSettings20 complex type: */
class SOAP_CMAC tt__ImagingSettings20
{
public:
	tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure20 *Exposure;	/* optional element of XSD type tt:Exposure20 */
	tt__FocusConfiguration20 *Focus;	/* optional element of XSD type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange20 */
	tt__WhiteBalance20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance20 */
	tt__ImagingSettingsExtension20 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings20 (695)
	virtual int soap_type(void) const { return 695; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
	virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings20); }
	         tt__ImagingSettings20() { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
	friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1619 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (696)
/* tt:ImagingSettingsExtension20 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension20
{
public:
	tt__ImageStabilization *ImageStabilization;	/* optional element of XSD type tt:ImageStabilization */
	tt__ImagingSettingsExtension202 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension202 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension20 (696)
	virtual int soap_type(void) const { return 696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension20); }
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1622 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (697)
/* tt:ImagingSettingsExtension202 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension202
{
public:
	int __sizeIrCutFilterAutoAdjustment;	/* sequence of elements <IrCutFilterAutoAdjustment> of XSD type tt:IrCutFilterAutoAdjustment */
	tt__IrCutFilterAutoAdjustment **IrCutFilterAutoAdjustment;
	tt__ImagingSettingsExtension203 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension203 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension202 (697)
	virtual int soap_type(void) const { return 697; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension202); }
	         tt__ImagingSettingsExtension202() { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1625 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (698)
/* tt:ImagingSettingsExtension203 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension203
{
public:
	tt__ToneCompensation *ToneCompensation;	/* optional element of XSD type tt:ToneCompensation */
	tt__Defogging *Defogging;	/* optional element of XSD type tt:Defogging */
	tt__NoiseReduction *NoiseReduction;	/* optional element of XSD type tt:NoiseReduction */
	tt__ImagingSettingsExtension204 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension204 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension203 (698)
	virtual int soap_type(void) const { return 698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension203); }
	         tt__ImagingSettingsExtension203() { tt__ImagingSettingsExtension203::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension203() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1628 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (699)
/* tt:ImagingSettingsExtension204 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension204
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension204 (699)
	virtual int soap_type(void) const { return 699; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension204); }
	         tt__ImagingSettingsExtension204() { tt__ImagingSettingsExtension204::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension204() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1631 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (700)
/* tt:ImageStabilization complex type: */
class SOAP_CMAC tt__ImageStabilization
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ImageStabilizationExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilization (700)
	virtual int soap_type(void) const { return 700; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
	virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilization); }
	         tt__ImageStabilization() { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
	friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1634 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (701)
/* tt:ImageStabilizationExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationExtension (701)
	virtual int soap_type(void) const { return 701; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationExtension); }
	         tt__ImageStabilizationExtension() { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1637 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (702)
/* tt:IrCutFilterAutoAdjustment complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment
{
public:
	char *BoundaryType;	/* required element of XSD type xsd:string */
	float *BoundaryOffset;	/* optional element of XSD type xsd:float */
	LONG64 *ResponseTime;	/* optional element of XSD type xsd:duration */
	tt__IrCutFilterAutoAdjustmentExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustment (702)
	virtual int soap_type(void) const { return 702; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustment); }
	         tt__IrCutFilterAutoAdjustment() { tt__IrCutFilterAutoAdjustment::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustment() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1640 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (703)
/* tt:IrCutFilterAutoAdjustmentExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (703)
	virtual int soap_type(void) const { return 703; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentExtension); }
	         tt__IrCutFilterAutoAdjustmentExtension() { tt__IrCutFilterAutoAdjustmentExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1643 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (704)
/* tt:WideDynamicRange20 complex type: */
class SOAP_CMAC tt__WideDynamicRange20
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float *Level;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange20 (704)
	virtual int soap_type(void) const { return 704; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange20); }
	         tt__WideDynamicRange20() { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
	friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1646 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (705)
/* tt:BacklightCompensation20 complex type: */
class SOAP_CMAC tt__BacklightCompensation20
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation20 (705)
	virtual int soap_type(void) const { return 705; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation20); }
	         tt__BacklightCompensation20() { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
	friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1649 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (706)
/* tt:Exposure20 complex type: */
class SOAP_CMAC tt__Exposure20
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of XSD type tt:Rectangle */
	float *MinExposureTime;	/* optional element of XSD type xsd:float */
	float *MaxExposureTime;	/* optional element of XSD type xsd:float */
	float *MinGain;	/* optional element of XSD type xsd:float */
	float *MaxGain;	/* optional element of XSD type xsd:float */
	float *MinIris;	/* optional element of XSD type xsd:float */
	float *MaxIris;	/* optional element of XSD type xsd:float */
	float *ExposureTime;	/* optional element of XSD type xsd:float */
	float *Gain;	/* optional element of XSD type xsd:float */
	float *Iris;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure20 (706)
	virtual int soap_type(void) const { return 706; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
	virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW(tt__Exposure20); }
	         tt__Exposure20() { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
	friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1652 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (707)
/* tt:ToneCompensation complex type: */
class SOAP_CMAC tt__ToneCompensation
{
public:
	char *Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ToneCompensationExtension *Extension;	/* optional element of XSD type tt:ToneCompensationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensation (707)
	virtual int soap_type(void) const { return 707; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
	virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensation); }
	         tt__ToneCompensation() { tt__ToneCompensation::soap_default(NULL); }
	virtual ~tt__ToneCompensation() { }
	friend SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1655 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (708)
/* tt:ToneCompensationExtension complex type: */
class SOAP_CMAC tt__ToneCompensationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationExtension (708)
	virtual int soap_type(void) const { return 708; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
	virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationExtension); }
	         tt__ToneCompensationExtension() { tt__ToneCompensationExtension::soap_default(NULL); }
	virtual ~tt__ToneCompensationExtension() { }
	friend SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1658 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (709)
/* tt:Defogging complex type: */
class SOAP_CMAC tt__Defogging
{
public:
	char *Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__DefoggingExtension *Extension;	/* optional element of XSD type tt:DefoggingExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Defogging (709)
	virtual int soap_type(void) const { return 709; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
	virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW(tt__Defogging); }
	         tt__Defogging() { tt__Defogging::soap_default(NULL); }
	virtual ~tt__Defogging() { }
	friend SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1661 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (710)
/* tt:DefoggingExtension complex type: */
class SOAP_CMAC tt__DefoggingExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingExtension (710)
	virtual int soap_type(void) const { return 710; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
	virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingExtension); }
	         tt__DefoggingExtension() { tt__DefoggingExtension::soap_default(NULL); }
	virtual ~tt__DefoggingExtension() { }
	friend SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1664 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (711)
/* tt:NoiseReduction complex type: */
class SOAP_CMAC tt__NoiseReduction
{
public:
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReduction (711)
	virtual int soap_type(void) const { return 711; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
	virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReduction); }
	         tt__NoiseReduction() { tt__NoiseReduction::soap_default(NULL); }
	virtual ~tt__NoiseReduction() { }
	friend SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1667 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (712)
/* tt:ImagingOptions20 complex type: */
class SOAP_CMAC tt__ImagingOptions20
{
public:
	tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of XSD type tt:FloatRange */
	tt__ExposureOptions20 *Exposure;	/* optional element of XSD type tt:ExposureOptions20 */
	tt__FocusOptions20 *Focus;	/* optional element of XSD type tt:FocusOptions20 */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> of XSD type tt:IrCutFilterMode */
	enum tt__IrCutFilterMode *IrCutFilterModes;
	tt__FloatRange *Sharpness;	/* optional element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRangeOptions20 */
	tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalanceOptions20 */
	tt__ImagingOptions20Extension *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20 (712)
	virtual int soap_type(void) const { return 712; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20); }
	         tt__ImagingOptions20() { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
	friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1670 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (713)
/* tt:ImagingOptions20Extension complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension
{
public:
	tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of XSD type tt:ImageStabilizationOptions */
	tt__ImagingOptions20Extension2 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension (713)
	virtual int soap_type(void) const { return 713; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension); }
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1673 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (714)
/* tt:ImagingOptions20Extension2 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension2
{
public:
	tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptions */
	tt__ImagingOptions20Extension3 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension3 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension2 (714)
	virtual int soap_type(void) const { return 714; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension2); }
	         tt__ImagingOptions20Extension2() { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1676 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (715)
/* tt:ImagingOptions20Extension3 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension3
{
public:
	tt__ToneCompensationOptions *ToneCompensationOptions;	/* optional element of XSD type tt:ToneCompensationOptions */
	tt__DefoggingOptions *DefoggingOptions;	/* optional element of XSD type tt:DefoggingOptions */
	tt__NoiseReductionOptions *NoiseReductionOptions;	/* optional element of XSD type tt:NoiseReductionOptions */
	tt__ImagingOptions20Extension4 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension4 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension3 (715)
	virtual int soap_type(void) const { return 715; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension3); }
	         tt__ImagingOptions20Extension3() { tt__ImagingOptions20Extension3::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension3() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1679 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (716)
/* tt:ImagingOptions20Extension4 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension4
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension4 (716)
	virtual int soap_type(void) const { return 716; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension4); }
	         tt__ImagingOptions20Extension4() { tt__ImagingOptions20Extension4::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension4() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1682 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (717)
/* tt:ImageStabilizationOptions complex type: */
class SOAP_CMAC tt__ImageStabilizationOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ImageStabilizationMode */
	enum tt__ImageStabilizationMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptions (717)
	virtual int soap_type(void) const { return 717; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptions); }
	         tt__ImageStabilizationOptions() { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1685 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (718)
/* tt:ImageStabilizationOptionsExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptionsExtension (718)
	virtual int soap_type(void) const { return 718; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptionsExtension); }
	         tt__ImageStabilizationOptionsExtension() { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1688 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (719)
/* tt:IrCutFilterAutoAdjustmentOptions complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions
{
public:
	int __sizeBoundaryType;	/* sequence of elements <BoundaryType> of XSD type xsd:string */
	char **BoundaryType;
	bool *BoundaryOffset;	/* optional element of XSD type xsd:boolean */
	tt__DurationRange *ResponseTimeRange;	/* optional element of XSD type tt:DurationRange */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (719)
	virtual int soap_type(void) const { return 719; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptions); }
	         tt__IrCutFilterAutoAdjustmentOptions() { tt__IrCutFilterAutoAdjustmentOptions::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1691 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (720)
/* tt:IrCutFilterAutoAdjustmentOptionsExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (720)
	virtual int soap_type(void) const { return 720; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
	         tt__IrCutFilterAutoAdjustmentOptionsExtension() { tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1694 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (721)
/* tt:WideDynamicRangeOptions20 complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions20 (721)
	virtual int soap_type(void) const { return 721; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions20); }
	         tt__WideDynamicRangeOptions20() { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1697 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (722)
/* tt:BacklightCompensationOptions20 complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:BacklightCompensationMode */
	enum tt__BacklightCompensationMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions20 (722)
	virtual int soap_type(void) const { return 722; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions20); }
	         tt__BacklightCompensationOptions20() { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1700 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (723)
/* tt:ExposureOptions20 complex type: */
class SOAP_CMAC tt__ExposureOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ExposureMode */
	enum tt__ExposureMode *Mode;
	int __sizePriority;	/* sequence of elements <Priority> of XSD type tt:ExposurePriority */
	enum tt__ExposurePriority *Priority;
	tt__FloatRange *MinExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions20 (723)
	virtual int soap_type(void) const { return 723; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
	virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions20); }
	         tt__ExposureOptions20() { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
	friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1703 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (724)
/* tt:MoveOptions20 complex type: */
class SOAP_CMAC tt__MoveOptions20
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions20 *Relative;	/* optional element of XSD type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions20 (724)
	virtual int soap_type(void) const { return 724; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
	virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions20); }
	         tt__MoveOptions20() { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
	friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1706 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (725)
/* tt:RelativeFocusOptions20 complex type: */
class SOAP_CMAC tt__RelativeFocusOptions20
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions20 (725)
	virtual int soap_type(void) const { return 725; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions20); }
	         tt__RelativeFocusOptions20() { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1709 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (726)
/* tt:WhiteBalance20 complex type: */
class SOAP_CMAC tt__WhiteBalance20
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of XSD type xsd:float */
	float *CbGain;	/* optional element of XSD type xsd:float */
	tt__WhiteBalance20Extension *Extension;	/* optional element of XSD type tt:WhiteBalance20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20 (726)
	virtual int soap_type(void) const { return 726; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20); }
	         tt__WhiteBalance20() { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
	friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1712 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (727)
/* tt:WhiteBalance20Extension complex type: */
class SOAP_CMAC tt__WhiteBalance20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20Extension (727)
	virtual int soap_type(void) const { return 727; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20Extension); }
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1715 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (728)
/* tt:FocusConfiguration20 complex type: */
class SOAP_CMAC tt__FocusConfiguration20
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of XSD type xsd:float */
	float *NearLimit;	/* optional element of XSD type xsd:float */
	float *FarLimit;	/* optional element of XSD type xsd:float */
	tt__FocusConfiguration20Extension *Extension;	/* optional element of XSD type tt:FocusConfiguration20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20 (728)
	virtual int soap_type(void) const { return 728; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20); }
	         tt__FocusConfiguration20() { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1718 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (729)
/* tt:FocusConfiguration20Extension complex type: */
class SOAP_CMAC tt__FocusConfiguration20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20Extension (729)
	virtual int soap_type(void) const { return 729; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20Extension); }
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1721 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (730)
/* tt:WhiteBalanceOptions20 complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WhiteBalanceMode */
	enum tt__WhiteBalanceMode *Mode;
	tt__FloatRange *YrGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of XSD type tt:FloatRange */
	tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of XSD type tt:WhiteBalanceOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20 (730)
	virtual int soap_type(void) const { return 730; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20); }
	         tt__WhiteBalanceOptions20() { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1724 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (731)
/* tt:WhiteBalanceOptions20Extension complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20Extension (731)
	virtual int soap_type(void) const { return 731; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20Extension); }
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1727 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (732)
/* tt:FocusOptions20 complex type: */
class SOAP_CMAC tt__FocusOptions20
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> of XSD type tt:AutoFocusMode */
	enum tt__AutoFocusMode *AutoFocusModes;
	tt__FloatRange *DefaultSpeed;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FocusOptions20Extension *Extension;	/* optional element of XSD type tt:FocusOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20 (732)
	virtual int soap_type(void) const { return 732; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
	virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20); }
	         tt__FocusOptions20() { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
	friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1730 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (733)
/* tt:FocusOptions20Extension complex type: */
class SOAP_CMAC tt__FocusOptions20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20Extension (733)
	virtual int soap_type(void) const { return 733; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
	virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20Extension); }
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
	friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1733 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (734)
/* tt:ToneCompensationOptions complex type: */
class SOAP_CMAC tt__ToneCompensationOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type xsd:string */
	char **Mode;
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationOptions (734)
	virtual int soap_type(void) const { return 734; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
	virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationOptions); }
	         tt__ToneCompensationOptions() { tt__ToneCompensationOptions::soap_default(NULL); }
	virtual ~tt__ToneCompensationOptions() { }
	friend SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1736 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (735)
/* tt:DefoggingOptions complex type: */
class SOAP_CMAC tt__DefoggingOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type xsd:string */
	char **Mode;
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingOptions (735)
	virtual int soap_type(void) const { return 735; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
	virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingOptions); }
	         tt__DefoggingOptions() { tt__DefoggingOptions::soap_default(NULL); }
	virtual ~tt__DefoggingOptions() { }
	friend SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1739 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (736)
/* tt:NoiseReductionOptions complex type: */
class SOAP_CMAC tt__NoiseReductionOptions
{
public:
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReductionOptions (736)
	virtual int soap_type(void) const { return 736; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
	virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReductionOptions); }
	         tt__NoiseReductionOptions() { tt__NoiseReductionOptions::soap_default(NULL); }
	virtual ~tt__NoiseReductionOptions() { }
	friend SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1742 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (737)
/* tt:MessageExtension complex type: */
class SOAP_CMAC tt__MessageExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageExtension (737)
	virtual int soap_type(void) const { return 737; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
	virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageExtension); }
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
	friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:18744 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1551)
/* tt:ItemList-SimpleItem complex type: */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Value;	/* required attribute of XSD type xsd:anySimpleType */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_SimpleItem (1551)
	virtual int soap_type(void) const { return 1551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_SimpleItem); }
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
	friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:18772 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1553)
/* tt:ItemList-ElementItem complex type: */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_ElementItem (1553)
	virtual int soap_type(void) const { return 1553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_ElementItem); }
	         _tt__ItemList_ElementItem() { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
	friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1745 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (738)
/* tt:ItemList complex type: */
class SOAP_CMAC tt__ItemList
{
public:
	int __sizeSimpleItem;	/* sequence of elements <SimpleItem> of XSD type tt:ItemList-SimpleItem */
	_tt__ItemList_SimpleItem *SimpleItem;
	int __sizeElementItem;	/* sequence of elements <ElementItem> of XSD type tt:ItemList-ElementItem */
	_tt__ItemList_ElementItem *ElementItem;
	tt__ItemListExtension *Extension;	/* optional element of XSD type tt:ItemListExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemList (738)
	virtual int soap_type(void) const { return 738; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
	virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW(tt__ItemList); }
	         tt__ItemList() { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
	friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1748 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (739)
/* tt:ItemListExtension complex type: */
class SOAP_CMAC tt__ItemListExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListExtension (739)
	virtual int soap_type(void) const { return 739; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
	virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListExtension); }
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
	friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1751 */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (740)
/* tt:MessageDescription complex type: */
class SOAP_CMAC tt__MessageDescription
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescription (740)
	virtual int soap_type(void) const { return 740; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescription, default initialized and not managed by a soap context
	virtual tt__MessageDescription *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescription); }
	         tt__MessageDescription() { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
	friend SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1754 */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (741)
/* tt:MessageDescriptionExtension complex type: */
class SOAP_CMAC tt__MessageDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescriptionExtension (741)
	virtual int soap_type(void) const { return 741; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescriptionExtension); }
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
	friend SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:18925 */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1558)
/* tt:ItemListDescription-SimpleItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1558)
	virtual int soap_type(void) const { return 1558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription); }
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:18950 */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1560)
/* tt:ItemListDescription-ElementItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1560)
	virtual int soap_type(void) const { return 1560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_ElementItemDescription); }
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1757 */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (742)
/* tt:ItemListDescription complex type: */
class SOAP_CMAC tt__ItemListDescription
{
public:
	int __sizeSimpleItemDescription;	/* sequence of elements <SimpleItemDescription> of XSD type tt:ItemListDescription-SimpleItemDescription */
	_tt__ItemListDescription_SimpleItemDescription *SimpleItemDescription;
	int __sizeElementItemDescription;	/* sequence of elements <ElementItemDescription> of XSD type tt:ItemListDescription-ElementItemDescription */
	_tt__ItemListDescription_ElementItemDescription *ElementItemDescription;
	tt__ItemListDescriptionExtension *Extension;	/* optional element of XSD type tt:ItemListDescriptionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescription (742)
	virtual int soap_type(void) const { return 742; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescription, default initialized and not managed by a soap context
	virtual tt__ItemListDescription *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescription); }
	         tt__ItemListDescription() { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
	friend SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1760 */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (743)
/* tt:ItemListDescriptionExtension complex type: */
class SOAP_CMAC tt__ItemListDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescriptionExtension (743)
	virtual int soap_type(void) const { return 743; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescriptionExtension); }
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1763 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (744)
/* tt:Polyline complex type: */
class SOAP_CMAC tt__Polyline
{
public:
	int __sizePoint;	/* sequence of elements <Point> of XSD type tt:Vector */
	tt__Vector **Point;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polyline (744)
	virtual int soap_type(void) const { return 744; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
	virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW(tt__Polyline); }
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
	friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1766 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (745)
/* tt:AnalyticsEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfiguration
{
public:
	int __sizeAnalyticsModule;	/* sequence of elements <AnalyticsModule> of XSD type tt:Config */
	tt__Config **AnalyticsModule;
	tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfiguration (745)
	virtual int soap_type(void) const { return 745; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfiguration); }
	         tt__AnalyticsEngineConfiguration() { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1769 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (746)
/* tt:AnalyticsEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (746)
	virtual int soap_type(void) const { return 746; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfigurationExtension); }
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1772 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (747)
/* tt:RuleEngineConfiguration complex type: */
class SOAP_CMAC tt__RuleEngineConfiguration
{
public:
	int __sizeRule;	/* sequence of elements <Rule> of XSD type tt:Config */
	tt__Config **Rule;
	tt__RuleEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:RuleEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfiguration (747)
	virtual int soap_type(void) const { return 747; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfiguration); }
	         tt__RuleEngineConfiguration() { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
	friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1775 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (748)
/* tt:RuleEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__RuleEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfigurationExtension (748)
	virtual int soap_type(void) const { return 748; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfigurationExtension); }
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1778 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (749)
/* tt:Config complex type: */
class SOAP_CMAC tt__Config
{
public:
	tt__ItemList *Parameters;	/* required element of XSD type tt:ItemList */
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Config (749)
	virtual int soap_type(void) const { return 749; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Config, default initialized and not managed by a soap context
	virtual tt__Config *soap_alloc(void) const { return SOAP_NEW(tt__Config); }
	         tt__Config() { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
	friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:19198 */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1570)
/* tt:ConfigDescription-Messages complex type: */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	char *ParentTopic;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ConfigDescription_Messages (1570)
	virtual int soap_type(void) const { return 1570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ConfigDescription_Messages, default initialized and not managed by a soap context
	virtual _tt__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW(_tt__ConfigDescription_Messages); }
	         _tt__ConfigDescription_Messages() { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
	friend SOAP_FMAC1 _tt__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__tt__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1781 */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (750)
/* tt:ConfigDescription complex type: */
class SOAP_CMAC tt__ConfigDescription
{
public:
	tt__ItemListDescription *Parameters;	/* required element of XSD type tt:ItemListDescription */
	int __sizeMessages;	/* sequence of elements <Messages> of XSD type tt:ConfigDescription-Messages */
	_tt__ConfigDescription_Messages *Messages;
	tt__ConfigDescriptionExtension *Extension;	/* optional element of XSD type tt:ConfigDescriptionExtension */
	char *Name;	/* required attribute of XSD type xsd:QName */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	char *maxInstances;	/* optional attribute of XSD type xsd:integer */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescription (750)
	virtual int soap_type(void) const { return 750; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescription, default initialized and not managed by a soap context
	virtual tt__ConfigDescription *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescription); }
	         tt__ConfigDescription() { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
	friend SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1784 */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (751)
/* tt:ConfigDescriptionExtension complex type: */
class SOAP_CMAC tt__ConfigDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescriptionExtension (751)
	virtual int soap_type(void) const { return 751; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescriptionExtension); }
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1787 */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (752)
/* tt:SupportedRules complex type: */
class SOAP_CMAC tt__SupportedRules
{
public:
	int __sizeRuleContentSchemaLocation;	/* sequence of elements <RuleContentSchemaLocation> of XSD type xsd:anyURI */
	char **RuleContentSchemaLocation;
	int __sizeRuleDescription;	/* sequence of elements <RuleDescription> of XSD type tt:ConfigDescription */
	tt__ConfigDescription **RuleDescription;
	tt__SupportedRulesExtension *Extension;	/* optional element of XSD type tt:SupportedRulesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRules (752)
	virtual int soap_type(void) const { return 752; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRules, default initialized and not managed by a soap context
	virtual tt__SupportedRules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRules); }
	         tt__SupportedRules() { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
	friend SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1790 */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (753)
/* tt:SupportedRulesExtension complex type: */
class SOAP_CMAC tt__SupportedRulesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRulesExtension (753)
	virtual int soap_type(void) const { return 753; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRulesExtension); }
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1793 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (754)
/* tt:SupportedAnalyticsModules complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModules
{
public:
	int __sizeAnalyticsModuleContentSchemaLocation;	/* sequence of elements <AnalyticsModuleContentSchemaLocation> of XSD type xsd:anyURI */
	char **AnalyticsModuleContentSchemaLocation;
	int __sizeAnalyticsModuleDescription;	/* sequence of elements <AnalyticsModuleDescription> of XSD type tt:ConfigDescription */
	tt__ConfigDescription **AnalyticsModuleDescription;
	tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of XSD type tt:SupportedAnalyticsModulesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModules (754)
	virtual int soap_type(void) const { return 754; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModules, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModules); }
	         tt__SupportedAnalyticsModules() { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1796 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (755)
/* tt:SupportedAnalyticsModulesExtension complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (755)
	virtual int soap_type(void) const { return 755; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModulesExtension); }
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1799 */
#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (756)
/* tt:PolygonConfiguration complex type: */
class SOAP_CMAC tt__PolygonConfiguration
{
public:
	tt__Polygon *Polygon;	/* required element of XSD type tt:Polygon */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolygonConfiguration (756)
	virtual int soap_type(void) const { return 756; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolygonConfiguration, default initialized and not managed by a soap context
	virtual tt__PolygonConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolygonConfiguration); }
	         tt__PolygonConfiguration() { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
	friend SOAP_FMAC1 tt__PolygonConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolygonConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1802 */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (757)
/* tt:PolylineArray complex type: */
class SOAP_CMAC tt__PolylineArray
{
public:
	int __sizeSegment;	/* sequence of elements <Segment> of XSD type tt:Polyline */
	tt__Polyline **Segment;
	tt__PolylineArrayExtension *Extension;	/* optional element of XSD type tt:PolylineArrayExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArray (757)
	virtual int soap_type(void) const { return 757; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArray, default initialized and not managed by a soap context
	virtual tt__PolylineArray *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArray); }
	         tt__PolylineArray() { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
	friend SOAP_FMAC1 tt__PolylineArray * SOAP_FMAC2 soap_instantiate_tt__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1805 */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (758)
/* tt:PolylineArrayExtension complex type: */
class SOAP_CMAC tt__PolylineArrayExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayExtension (758)
	virtual int soap_type(void) const { return 758; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayExtension, default initialized and not managed by a soap context
	virtual tt__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayExtension); }
	         tt__PolylineArrayExtension() { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
	friend SOAP_FMAC1 tt__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1808 */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (759)
/* tt:PolylineArrayConfiguration complex type: */
class SOAP_CMAC tt__PolylineArrayConfiguration
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of XSD type tt:PolylineArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayConfiguration (759)
	virtual int soap_type(void) const { return 759; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayConfiguration, default initialized and not managed by a soap context
	virtual tt__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayConfiguration); }
	         tt__PolylineArrayConfiguration() { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
	friend SOAP_FMAC1 tt__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1811 */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (760)
/* tt:MotionExpression complex type: */
class SOAP_CMAC tt__MotionExpression
{
public:
	char *Expression;	/* required element of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpression (760)
	virtual int soap_type(void) const { return 760; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpression, default initialized and not managed by a soap context
	virtual tt__MotionExpression *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpression); }
	         tt__MotionExpression() { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
	friend SOAP_FMAC1 tt__MotionExpression * SOAP_FMAC2 soap_instantiate_tt__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1814 */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (761)
/* tt:MotionExpressionConfiguration complex type: */
class SOAP_CMAC tt__MotionExpressionConfiguration
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of XSD type tt:MotionExpression */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpressionConfiguration (761)
	virtual int soap_type(void) const { return 761; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpressionConfiguration, default initialized and not managed by a soap context
	virtual tt__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpressionConfiguration); }
	         tt__MotionExpressionConfiguration() { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
	friend SOAP_FMAC1 tt__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_tt__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1817 */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (762)
/* tt:CellLayout complex type: */
class SOAP_CMAC tt__CellLayout
{
public:
	tt__Transformation *Transformation;	/* required element of XSD type tt:Transformation */
	char *Columns;	/* required attribute of XSD type xsd:integer */
	char *Rows;	/* required attribute of XSD type xsd:integer */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CellLayout (762)
	virtual int soap_type(void) const { return 762; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CellLayout, default initialized and not managed by a soap context
	virtual tt__CellLayout *soap_alloc(void) const { return SOAP_NEW(tt__CellLayout); }
	         tt__CellLayout() { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
	friend SOAP_FMAC1 tt__CellLayout * SOAP_FMAC2 soap_instantiate_tt__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1820 */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (763)
/* tt:PaneConfiguration complex type: */
class SOAP_CMAC tt__PaneConfiguration
{
public:
	char *PaneName;	/* optional element of XSD type xsd:string */
	char *AudioOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	char *AudioSourceToken;	/* optional element of XSD type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	char *ReceiverToken;	/* optional element of XSD type tt:ReferenceToken */
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneConfiguration (763)
	virtual int soap_type(void) const { return 763; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneConfiguration, default initialized and not managed by a soap context
	virtual tt__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PaneConfiguration); }
	         tt__PaneConfiguration() { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
	friend SOAP_FMAC1 tt__PaneConfiguration * SOAP_FMAC2 soap_instantiate_tt__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1823 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (764)
/* tt:PaneLayout complex type: */
class SOAP_CMAC tt__PaneLayout
{
public:
	char *Pane;	/* required element of XSD type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of XSD type tt:Rectangle */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayout (764)
	virtual int soap_type(void) const { return 764; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
	virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayout); }
	         tt__PaneLayout() { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
	friend SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1826 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (765)
/* tt:Layout complex type: */
class SOAP_CMAC tt__Layout
{
public:
	int __sizePaneLayout;	/* sequence of elements <PaneLayout> of XSD type tt:PaneLayout */
	tt__PaneLayout **PaneLayout;
	tt__LayoutExtension *Extension;	/* optional element of XSD type tt:LayoutExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Layout (765)
	virtual int soap_type(void) const { return 765; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Layout, default initialized and not managed by a soap context
	virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW(tt__Layout); }
	         tt__Layout() { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
	friend SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1829 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (766)
/* tt:LayoutExtension complex type: */
class SOAP_CMAC tt__LayoutExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutExtension (766)
	virtual int soap_type(void) const { return 766; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
	virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutExtension); }
	         tt__LayoutExtension() { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
	friend SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1832 */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (767)
/* tt:CodingCapabilities complex type: */
class SOAP_CMAC tt__CodingCapabilities
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of XSD type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of XSD type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of XSD type tt:VideoDecoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CodingCapabilities (767)
	virtual int soap_type(void) const { return 767; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CodingCapabilities, default initialized and not managed by a soap context
	virtual tt__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__CodingCapabilities); }
	         tt__CodingCapabilities() { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
	friend SOAP_FMAC1 tt__CodingCapabilities * SOAP_FMAC2 soap_instantiate_tt__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1835 */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (768)
/* tt:LayoutOptions complex type: */
class SOAP_CMAC tt__LayoutOptions
{
public:
	int __sizePaneLayoutOptions;	/* sequence of elements <PaneLayoutOptions> of XSD type tt:PaneLayoutOptions */
	tt__PaneLayoutOptions **PaneLayoutOptions;
	tt__LayoutOptionsExtension *Extension;	/* optional element of XSD type tt:LayoutOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptions (768)
	virtual int soap_type(void) const { return 768; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptions, default initialized and not managed by a soap context
	virtual tt__LayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptions); }
	         tt__LayoutOptions() { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
	friend SOAP_FMAC1 tt__LayoutOptions * SOAP_FMAC2 soap_instantiate_tt__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1838 */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (769)
/* tt:LayoutOptionsExtension complex type: */
class SOAP_CMAC tt__LayoutOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptionsExtension (769)
	virtual int soap_type(void) const { return 769; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptionsExtension, default initialized and not managed by a soap context
	virtual tt__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptionsExtension); }
	         tt__LayoutOptionsExtension() { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
	friend SOAP_FMAC1 tt__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1841 */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (770)
/* tt:PaneLayoutOptions complex type: */
class SOAP_CMAC tt__PaneLayoutOptions
{
public:
	int __sizeArea;	/* sequence of elements <Area> of XSD type tt:Rectangle */
	tt__Rectangle **Area;
	tt__PaneOptionExtension *Extension;	/* optional element of XSD type tt:PaneOptionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayoutOptions (770)
	virtual int soap_type(void) const { return 770; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayoutOptions, default initialized and not managed by a soap context
	virtual tt__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayoutOptions); }
	         tt__PaneLayoutOptions() { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
	friend SOAP_FMAC1 tt__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_tt__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1844 */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (771)
/* tt:PaneOptionExtension complex type: */
class SOAP_CMAC tt__PaneOptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneOptionExtension (771)
	virtual int soap_type(void) const { return 771; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneOptionExtension, default initialized and not managed by a soap context
	virtual tt__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PaneOptionExtension); }
	         tt__PaneOptionExtension() { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
	friend SOAP_FMAC1 tt__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_tt__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1847 */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (772)
/* tt:Receiver complex type: */
class SOAP_CMAC tt__Receiver
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Receiver (772)
	virtual int soap_type(void) const { return 772; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Receiver, default initialized and not managed by a soap context
	virtual tt__Receiver *soap_alloc(void) const { return SOAP_NEW(tt__Receiver); }
	         tt__Receiver() { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
	friend SOAP_FMAC1 tt__Receiver * SOAP_FMAC2 soap_instantiate_tt__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1850 */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (773)
/* tt:ReceiverConfiguration complex type: */
class SOAP_CMAC tt__ReceiverConfiguration
{
public:
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	char *MediaUri;	/* required element of XSD type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverConfiguration (773)
	virtual int soap_type(void) const { return 773; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverConfiguration, default initialized and not managed by a soap context
	virtual tt__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverConfiguration); }
	         tt__ReceiverConfiguration() { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
	friend SOAP_FMAC1 tt__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1853 */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (774)
/* tt:ReceiverStateInformation complex type: */
class SOAP_CMAC tt__ReceiverStateInformation
{
public:
	enum tt__ReceiverState State;	/* required element of XSD type tt:ReceiverState */
	bool AutoCreated;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverStateInformation (774)
	virtual int soap_type(void) const { return 774; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverStateInformation, default initialized and not managed by a soap context
	virtual tt__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverStateInformation); }
	         tt__ReceiverStateInformation() { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
	friend SOAP_FMAC1 tt__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_tt__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1856 */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (775)
/* tt:SourceReference complex type: */
class SOAP_CMAC tt__SourceReference
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	char *Type;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceReference (775)
	virtual int soap_type(void) const { return 775; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceReference, default initialized and not managed by a soap context
	virtual tt__SourceReference *soap_alloc(void) const { return SOAP_NEW(tt__SourceReference); }
	         tt__SourceReference() { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
	friend SOAP_FMAC1 tt__SourceReference * SOAP_FMAC2 soap_instantiate_tt__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1859 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (776)
/* tt:DateTimeRange complex type: */
class SOAP_CMAC tt__DateTimeRange
{
public:
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTimeRange (776)
	virtual int soap_type(void) const { return 776; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
	virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW(tt__DateTimeRange); }
	         tt__DateTimeRange() { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
	friend SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1862 */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (777)
/* tt:RecordingSummary complex type: */
class SOAP_CMAC tt__RecordingSummary
{
public:
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataUntil;	/* required element of XSD type xsd:dateTime */
	int NumberRecordings;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSummary (777)
	virtual int soap_type(void) const { return 777; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSummary, default initialized and not managed by a soap context
	virtual tt__RecordingSummary *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSummary); }
	         tt__RecordingSummary() { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
	friend SOAP_FMAC1 tt__RecordingSummary * SOAP_FMAC2 soap_instantiate_tt__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1865 */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (778)
/* tt:SearchScope complex type: */
class SOAP_CMAC tt__SearchScope
{
public:
	int __sizeIncludedSources;	/* sequence of elements <IncludedSources> of XSD type tt:SourceReference */
	tt__SourceReference **IncludedSources;
	int __sizeIncludedRecordings;	/* sequence of elements <IncludedRecordings> of XSD type tt:RecordingReference */
	char **IncludedRecordings;
	char *RecordingInformationFilter;	/* optional element of XSD type tt:XPathExpression */
	tt__SearchScopeExtension *Extension;	/* optional element of XSD type tt:SearchScopeExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScope (778)
	virtual int soap_type(void) const { return 778; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScope, default initialized and not managed by a soap context
	virtual tt__SearchScope *soap_alloc(void) const { return SOAP_NEW(tt__SearchScope); }
	         tt__SearchScope() { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
	friend SOAP_FMAC1 tt__SearchScope * SOAP_FMAC2 soap_instantiate_tt__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1868 */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (779)
/* tt:SearchScopeExtension complex type: */
class SOAP_CMAC tt__SearchScopeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScopeExtension (779)
	virtual int soap_type(void) const { return 779; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScopeExtension, default initialized and not managed by a soap context
	virtual tt__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SearchScopeExtension); }
	         tt__SearchScopeExtension() { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
	friend SOAP_FMAC1 tt__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_tt__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1874 */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (781)
/* tt:PTZPositionFilter complex type: */
class SOAP_CMAC tt__PTZPositionFilter
{
public:
	tt__PTZVector *MinPosition;	/* required element of XSD type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of XSD type tt:PTZVector */
	bool EnterOrExit;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPositionFilter (781)
	virtual int soap_type(void) const { return 781; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPositionFilter, default initialized and not managed by a soap context
	virtual tt__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZPositionFilter); }
	         tt__PTZPositionFilter() { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
	friend SOAP_FMAC1 tt__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_tt__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1877 */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (782)
/* tt:MetadataFilter complex type: */
class SOAP_CMAC tt__MetadataFilter
{
public:
	char *MetadataStreamFilter;	/* required element of XSD type tt:XPathExpression */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataFilter (782)
	virtual int soap_type(void) const { return 782; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataFilter, default initialized and not managed by a soap context
	virtual tt__MetadataFilter *soap_alloc(void) const { return SOAP_NEW(tt__MetadataFilter); }
	         tt__MetadataFilter() { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
	friend SOAP_FMAC1 tt__MetadataFilter * SOAP_FMAC2 soap_instantiate_tt__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1880 */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (783)
/* tt:FindRecordingResultList complex type: */
class SOAP_CMAC tt__FindRecordingResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeRecordingInformation;	/* sequence of elements <RecordingInformation> of XSD type tt:RecordingInformation */
	tt__RecordingInformation **RecordingInformation;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindRecordingResultList (783)
	virtual int soap_type(void) const { return 783; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindRecordingResultList, default initialized and not managed by a soap context
	virtual tt__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindRecordingResultList); }
	         tt__FindRecordingResultList() { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
	friend SOAP_FMAC1 tt__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_tt__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1883 */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (784)
/* tt:FindEventResultList complex type: */
class SOAP_CMAC tt__FindEventResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindEventResult */
	tt__FindEventResult **Result;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResultList (784)
	virtual int soap_type(void) const { return 784; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResultList, default initialized and not managed by a soap context
	virtual tt__FindEventResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResultList); }
	         tt__FindEventResultList() { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
	friend SOAP_FMAC1 tt__FindEventResultList * SOAP_FMAC2 soap_instantiate_tt__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1886 */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (785)
/* tt:FindEventResult complex type: */
class SOAP_CMAC tt__FindEventResult
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	wsnt__NotificationMessageHolderType *Event;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResult (785)
	virtual int soap_type(void) const { return 785; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResult, default initialized and not managed by a soap context
	virtual tt__FindEventResult *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResult); }
	         tt__FindEventResult() { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
	friend SOAP_FMAC1 tt__FindEventResult * SOAP_FMAC2 soap_instantiate_tt__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1889 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (786)
/* tt:FindPTZPositionResultList complex type: */
class SOAP_CMAC tt__FindPTZPositionResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindPTZPositionResult */
	tt__FindPTZPositionResult **Result;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResultList (786)
	virtual int soap_type(void) const { return 786; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResultList, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResultList); }
	         tt__FindPTZPositionResultList() { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1892 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (787)
/* tt:FindPTZPositionResult complex type: */
class SOAP_CMAC tt__FindPTZPositionResult
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResult (787)
	virtual int soap_type(void) const { return 787; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResult, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResult); }
	         tt__FindPTZPositionResult() { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1895 */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (788)
/* tt:FindMetadataResultList complex type: */
class SOAP_CMAC tt__FindMetadataResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindMetadataResult */
	tt__FindMetadataResult **Result;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResultList (788)
	virtual int soap_type(void) const { return 788; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResultList, default initialized and not managed by a soap context
	virtual tt__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResultList); }
	         tt__FindMetadataResultList() { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
	friend SOAP_FMAC1 tt__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1898 */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (789)
/* tt:FindMetadataResult complex type: */
class SOAP_CMAC tt__FindMetadataResult
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResult (789)
	virtual int soap_type(void) const { return 789; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResult, default initialized and not managed by a soap context
	virtual tt__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResult); }
	         tt__FindMetadataResult() { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
	friend SOAP_FMAC1 tt__FindMetadataResult * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1901 */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (790)
/* tt:RecordingInformation complex type: */
class SOAP_CMAC tt__RecordingInformation
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of XSD type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of XSD type xsd:dateTime */
	char *Content;	/* required element of XSD type tt:Description */
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:TrackInformation */
	tt__TrackInformation **Track;
	enum tt__RecordingStatus RecordingStatus;	/* required element of XSD type tt:RecordingStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingInformation (790)
	virtual int soap_type(void) const { return 790; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingInformation, default initialized and not managed by a soap context
	virtual tt__RecordingInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingInformation); }
	         tt__RecordingInformation() { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
	friend SOAP_FMAC1 tt__RecordingInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1904 */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (791)
/* tt:RecordingSourceInformation complex type: */
class SOAP_CMAC tt__RecordingSourceInformation
{
public:
	char *SourceId;	/* required element of XSD type xsd:anyURI */
	char *Name;	/* required element of XSD type tt:Name */
	char *Location;	/* required element of XSD type tt:Description */
	char *Description;	/* required element of XSD type tt:Description */
	char *Address;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSourceInformation (791)
	virtual int soap_type(void) const { return 791; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSourceInformation, default initialized and not managed by a soap context
	virtual tt__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSourceInformation); }
	         tt__RecordingSourceInformation() { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
	friend SOAP_FMAC1 tt__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1907 */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (792)
/* tt:TrackInformation complex type: */
class SOAP_CMAC tt__TrackInformation
{
public:
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	char *Description;	/* required element of XSD type tt:Description */
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataTo;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackInformation (792)
	virtual int soap_type(void) const { return 792; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackInformation, default initialized and not managed by a soap context
	virtual tt__TrackInformation *soap_alloc(void) const { return SOAP_NEW(tt__TrackInformation); }
	         tt__TrackInformation() { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
	friend SOAP_FMAC1 tt__TrackInformation * SOAP_FMAC2 soap_instantiate_tt__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1910 */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (793)
/* tt:MediaAttributes complex type: */
class SOAP_CMAC tt__MediaAttributes
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	int __sizeTrackAttributes;	/* sequence of elements <TrackAttributes> of XSD type tt:TrackAttributes */
	tt__TrackAttributes **TrackAttributes;
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaAttributes (793)
	virtual int soap_type(void) const { return 793; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaAttributes, default initialized and not managed by a soap context
	virtual tt__MediaAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MediaAttributes); }
	         tt__MediaAttributes() { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
	friend SOAP_FMAC1 tt__MediaAttributes * SOAP_FMAC2 soap_instantiate_tt__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1913 */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (794)
/* tt:TrackAttributes complex type: */
class SOAP_CMAC tt__TrackAttributes
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of XSD type tt:TrackInformation */
	tt__VideoAttributes *VideoAttributes;	/* optional element of XSD type tt:VideoAttributes */
	tt__AudioAttributes *AudioAttributes;	/* optional element of XSD type tt:AudioAttributes */
	tt__MetadataAttributes *MetadataAttributes;	/* optional element of XSD type tt:MetadataAttributes */
	tt__TrackAttributesExtension *Extension;	/* optional element of XSD type tt:TrackAttributesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributes (794)
	virtual int soap_type(void) const { return 794; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributes, default initialized and not managed by a soap context
	virtual tt__TrackAttributes *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributes); }
	         tt__TrackAttributes() { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
	friend SOAP_FMAC1 tt__TrackAttributes * SOAP_FMAC2 soap_instantiate_tt__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1916 */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (795)
/* tt:TrackAttributesExtension complex type: */
class SOAP_CMAC tt__TrackAttributesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributesExtension (795)
	virtual int soap_type(void) const { return 795; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributesExtension, default initialized and not managed by a soap context
	virtual tt__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributesExtension); }
	         tt__TrackAttributesExtension() { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
	friend SOAP_FMAC1 tt__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_tt__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1919 */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (796)
/* tt:VideoAttributes complex type: */
class SOAP_CMAC tt__VideoAttributes
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	char *Encoding;	/* required element of XSD type xsd:string */
	float Framerate;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAttributes (796)
	virtual int soap_type(void) const { return 796; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAttributes, default initialized and not managed by a soap context
	virtual tt__VideoAttributes *soap_alloc(void) const { return SOAP_NEW(tt__VideoAttributes); }
	         tt__VideoAttributes() { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
	friend SOAP_FMAC1 tt__VideoAttributes * SOAP_FMAC2 soap_instantiate_tt__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1922 */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (797)
/* tt:AudioAttributes complex type: */
class SOAP_CMAC tt__AudioAttributes
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	char *Encoding;	/* required element of XSD type xsd:string */
	int Samplerate;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAttributes (797)
	virtual int soap_type(void) const { return 797; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAttributes, default initialized and not managed by a soap context
	virtual tt__AudioAttributes *soap_alloc(void) const { return SOAP_NEW(tt__AudioAttributes); }
	         tt__AudioAttributes() { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
	friend SOAP_FMAC1 tt__AudioAttributes * SOAP_FMAC2 soap_instantiate_tt__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1925 */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (798)
/* tt:MetadataAttributes complex type: */
class SOAP_CMAC tt__MetadataAttributes
{
public:
	bool CanContainPTZ;	/* required element of XSD type xsd:boolean */
	bool CanContainAnalytics;	/* required element of XSD type xsd:boolean */
	bool CanContainNotifications;	/* required element of XSD type xsd:boolean */
	char *PtzSpaces;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataAttributes (798)
	virtual int soap_type(void) const { return 798; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataAttributes, default initialized and not managed by a soap context
	virtual tt__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MetadataAttributes); }
	         tt__MetadataAttributes() { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
	friend SOAP_FMAC1 tt__MetadataAttributes * SOAP_FMAC2 soap_instantiate_tt__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1928 */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (799)
/* tt:RecordingConfiguration complex type: */
class SOAP_CMAC tt__RecordingConfiguration
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	char *Content;	/* required element of XSD type tt:Description */
	LONG64 MaximumRetentionTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingConfiguration (799)
	virtual int soap_type(void) const { return 799; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingConfiguration); }
	         tt__RecordingConfiguration() { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1931 */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (800)
/* tt:TrackConfiguration complex type: */
class SOAP_CMAC tt__TrackConfiguration
{
public:
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	char *Description;	/* required element of XSD type tt:Description */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackConfiguration (800)
	virtual int soap_type(void) const { return 800; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackConfiguration, default initialized and not managed by a soap context
	virtual tt__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TrackConfiguration); }
	         tt__TrackConfiguration() { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
	friend SOAP_FMAC1 tt__TrackConfiguration * SOAP_FMAC2 soap_instantiate_tt__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1934 */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (801)
/* tt:GetRecordingsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingsResponseItem
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of XSD type tt:RecordingConfiguration */
	tt__GetTracksResponseList *Tracks;	/* required element of XSD type tt:GetTracksResponseList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingsResponseItem (801)
	virtual int soap_type(void) const { return 801; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingsResponseItem); }
	         tt__GetRecordingsResponseItem() { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1937 */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (802)
/* tt:GetTracksResponseList complex type: */
class SOAP_CMAC tt__GetTracksResponseList
{
public:
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:GetTracksResponseItem */
	tt__GetTracksResponseItem **Track;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseList (802)
	virtual int soap_type(void) const { return 802; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseList, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseList); }
	         tt__GetTracksResponseList() { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
	friend SOAP_FMAC1 tt__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1940 */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (803)
/* tt:GetTracksResponseItem complex type: */
class SOAP_CMAC tt__GetTracksResponseItem
{
public:
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseItem (803)
	virtual int soap_type(void) const { return 803; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseItem, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseItem); }
	         tt__GetTracksResponseItem() { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
	friend SOAP_FMAC1 tt__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1943 */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (804)
/* tt:RecordingJobConfiguration complex type: */
class SOAP_CMAC tt__RecordingJobConfiguration
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *Mode;	/* required element of XSD type tt:RecordingJobMode */
	int Priority;	/* required element of XSD type xsd:int */
	int __sizeSource;	/* sequence of elements <Source> of XSD type tt:RecordingJobSource */
	tt__RecordingJobSource **Source;
	tt__RecordingJobConfigurationExtension *Extension;	/* optional element of XSD type tt:RecordingJobConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfiguration (804)
	virtual int soap_type(void) const { return 804; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfiguration); }
	         tt__RecordingJobConfiguration() { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1946 */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (805)
/* tt:RecordingJobConfigurationExtension complex type: */
class SOAP_CMAC tt__RecordingJobConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfigurationExtension (805)
	virtual int soap_type(void) const { return 805; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfigurationExtension); }
	         tt__RecordingJobConfigurationExtension() { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1949 */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (806)
/* tt:RecordingJobSource complex type: */
class SOAP_CMAC tt__RecordingJobSource
{
public:
	tt__SourceReference *SourceToken;	/* optional element of XSD type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of XSD type xsd:boolean */
	int __sizeTracks;	/* sequence of elements <Tracks> of XSD type tt:RecordingJobTrack */
	tt__RecordingJobTrack **Tracks;
	tt__RecordingJobSourceExtension *Extension;	/* optional element of XSD type tt:RecordingJobSourceExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSource (806)
	virtual int soap_type(void) const { return 806; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSource); }
	         tt__RecordingJobSource() { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
	friend SOAP_FMAC1 tt__RecordingJobSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1952 */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (807)
/* tt:RecordingJobSourceExtension complex type: */
class SOAP_CMAC tt__RecordingJobSourceExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSourceExtension (807)
	virtual int soap_type(void) const { return 807; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSourceExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSourceExtension); }
	         tt__RecordingJobSourceExtension() { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1955 */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (808)
/* tt:RecordingJobTrack complex type: */
class SOAP_CMAC tt__RecordingJobTrack
{
public:
	char *SourceTag;	/* required element of XSD type xsd:string */
	char *Destination;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobTrack (808)
	virtual int soap_type(void) const { return 808; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobTrack); }
	         tt__RecordingJobTrack() { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1958 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (809)
/* tt:RecordingJobStateInformation complex type: */
class SOAP_CMAC tt__RecordingJobStateInformation
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	int __sizeSources;	/* sequence of elements <Sources> of XSD type tt:RecordingJobStateSource */
	tt__RecordingJobStateSource **Sources;
	tt__RecordingJobStateInformationExtension *Extension;	/* optional element of XSD type tt:RecordingJobStateInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformation (809)
	virtual int soap_type(void) const { return 809; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformation, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformation); }
	         tt__RecordingJobStateInformation() { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1961 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (810)
/* tt:RecordingJobStateInformationExtension complex type: */
class SOAP_CMAC tt__RecordingJobStateInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformationExtension (810)
	virtual int soap_type(void) const { return 810; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformationExtension); }
	         tt__RecordingJobStateInformationExtension() { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1964 */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (811)
/* tt:RecordingJobStateSource complex type: */
class SOAP_CMAC tt__RecordingJobStateSource
{
public:
	tt__SourceReference *SourceToken;	/* required element of XSD type tt:SourceReference */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	tt__RecordingJobStateTracks *Tracks;	/* required element of XSD type tt:RecordingJobStateTracks */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateSource (811)
	virtual int soap_type(void) const { return 811; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateSource); }
	         tt__RecordingJobStateSource() { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
	friend SOAP_FMAC1 tt__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1967 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (812)
/* tt:RecordingJobStateTracks complex type: */
class SOAP_CMAC tt__RecordingJobStateTracks
{
public:
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:RecordingJobStateTrack */
	tt__RecordingJobStateTrack **Track;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTracks (812)
	virtual int soap_type(void) const { return 812; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTracks, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTracks); }
	         tt__RecordingJobStateTracks() { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1970 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (813)
/* tt:RecordingJobStateTrack complex type: */
class SOAP_CMAC tt__RecordingJobStateTrack
{
public:
	char *SourceTag;	/* required element of XSD type xsd:string */
	char *Destination;	/* required element of XSD type tt:TrackReference */
	char *Error;	/* optional element of XSD type xsd:string */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTrack (813)
	virtual int soap_type(void) const { return 813; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTrack); }
	         tt__RecordingJobStateTrack() { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1973 */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (814)
/* tt:GetRecordingJobsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingJobsResponseItem
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingJobsResponseItem (814)
	virtual int soap_type(void) const { return 814; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingJobsResponseItem); }
	         tt__GetRecordingJobsResponseItem() { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1976 */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (815)
/* tt:ReplayConfiguration complex type: */
class SOAP_CMAC tt__ReplayConfiguration
{
public:
	LONG64 SessionTimeout;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayConfiguration (815)
	virtual int soap_type(void) const { return 815; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayConfiguration, default initialized and not managed by a soap context
	virtual tt__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReplayConfiguration); }
	         tt__ReplayConfiguration() { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
	friend SOAP_FMAC1 tt__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1982 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (817)
/* tt:AnalyticsDeviceEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration
{
public:
	int __sizeEngineConfiguration;	/* sequence of elements <EngineConfiguration> of XSD type tt:EngineConfiguration */
	tt__EngineConfiguration **EngineConfiguration;
	tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (817)
	virtual int soap_type(void) const { return 817; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfiguration); }
	         tt__AnalyticsDeviceEngineConfiguration() { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1985 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (818)
/* tt:AnalyticsDeviceEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (818)
	virtual int soap_type(void) const { return 818; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfigurationExtension); }
	         tt__AnalyticsDeviceEngineConfigurationExtension() { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1988 */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (819)
/* tt:EngineConfiguration complex type: */
class SOAP_CMAC tt__EngineConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of XSD type tt:AnalyticsEngineInputInfo */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EngineConfiguration (819)
	virtual int soap_type(void) const { return 819; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EngineConfiguration, default initialized and not managed by a soap context
	virtual tt__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EngineConfiguration); }
	         tt__EngineConfiguration() { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
	friend SOAP_FMAC1 tt__EngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1991 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (820)
/* tt:AnalyticsEngineInputInfo complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfo
{
public:
	tt__Config *InputInfo;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineInputInfoExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfo (820)
	virtual int soap_type(void) const { return 820; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfo); }
	         tt__AnalyticsEngineInputInfo() { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1994 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (821)
/* tt:AnalyticsEngineInputInfoExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (821)
	virtual int soap_type(void) const { return 821; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfoExtension); }
	         tt__AnalyticsEngineInputInfoExtension() { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2000 */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (823)
/* tt:SourceIdentification complex type: */
class SOAP_CMAC tt__SourceIdentification
{
public:
	char *Name;	/* required element of XSD type xsd:string */
	int __sizeToken;	/* sequence of elements <Token> of XSD type tt:ReferenceToken */
	char **Token;
	tt__SourceIdentificationExtension *Extension;	/* optional element of XSD type tt:SourceIdentificationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentification (823)
	virtual int soap_type(void) const { return 823; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentification, default initialized and not managed by a soap context
	virtual tt__SourceIdentification *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentification); }
	         tt__SourceIdentification() { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
	friend SOAP_FMAC1 tt__SourceIdentification * SOAP_FMAC2 soap_instantiate_tt__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2003 */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (824)
/* tt:SourceIdentificationExtension complex type: */
class SOAP_CMAC tt__SourceIdentificationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentificationExtension (824)
	virtual int soap_type(void) const { return 824; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentificationExtension, default initialized and not managed by a soap context
	virtual tt__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentificationExtension); }
	         tt__SourceIdentificationExtension() { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
	friend SOAP_FMAC1 tt__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_tt__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2006 */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (825)
/* tt:MetadataInput complex type: */
class SOAP_CMAC tt__MetadataInput
{
public:
	int __sizeMetadataConfig;	/* sequence of elements <MetadataConfig> of XSD type tt:Config */
	tt__Config **MetadataConfig;
	tt__MetadataInputExtension *Extension;	/* optional element of XSD type tt:MetadataInputExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInput (825)
	virtual int soap_type(void) const { return 825; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInput, default initialized and not managed by a soap context
	virtual tt__MetadataInput *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInput); }
	         tt__MetadataInput() { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
	friend SOAP_FMAC1 tt__MetadataInput * SOAP_FMAC2 soap_instantiate_tt__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2009 */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (826)
/* tt:MetadataInputExtension complex type: */
class SOAP_CMAC tt__MetadataInputExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInputExtension (826)
	virtual int soap_type(void) const { return 826; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInputExtension, default initialized and not managed by a soap context
	virtual tt__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInputExtension); }
	         tt__MetadataInputExtension() { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
	friend SOAP_FMAC1 tt__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2015 */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (828)
/* tt:AnalyticsStateInformation complex type: */
class SOAP_CMAC tt__AnalyticsStateInformation
{
public:
	char *AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	tt__AnalyticsState *State;	/* required element of XSD type tt:AnalyticsState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsStateInformation (828)
	virtual int soap_type(void) const { return 828; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsStateInformation, default initialized and not managed by a soap context
	virtual tt__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsStateInformation); }
	         tt__AnalyticsStateInformation() { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
	friend SOAP_FMAC1 tt__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_tt__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2018 */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (829)
/* tt:AnalyticsState complex type: */
class SOAP_CMAC tt__AnalyticsState
{
public:
	char *Error;	/* optional element of XSD type xsd:string */
	char *State;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsState (829)
	virtual int soap_type(void) const { return 829; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsState, default initialized and not managed by a soap context
	virtual tt__AnalyticsState *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsState); }
	         tt__AnalyticsState() { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
	friend SOAP_FMAC1 tt__AnalyticsState * SOAP_FMAC2 soap_instantiate_tt__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2021 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (830)
/* tt:ActionEngineEventPayload complex type: */
class SOAP_CMAC tt__ActionEngineEventPayload
{
public:
	struct SOAP_ENV__Envelope *RequestInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Envelope *ResponseInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of XSD type SOAP-ENV:Fault */
	tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of XSD type tt:ActionEngineEventPayloadExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayload (830)
	virtual int soap_type(void) const { return 830; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayload, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayload); }
	         tt__ActionEngineEventPayload() { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2024 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (831)
/* tt:ActionEngineEventPayloadExtension complex type: */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayloadExtension (831)
	virtual int soap_type(void) const { return 831; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayloadExtension); }
	         tt__ActionEngineEventPayloadExtension() { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2027 */
#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (832)
/* tt:AudioClassCandidate complex type: */
class SOAP_CMAC tt__AudioClassCandidate
{
public:
	char *Type;	/* required element of XSD type tt:AudioClassType */
	float Likelihood;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassCandidate (832)
	virtual int soap_type(void) const { return 832; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassCandidate, default initialized and not managed by a soap context
	virtual tt__AudioClassCandidate *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassCandidate); }
	         tt__AudioClassCandidate() { tt__AudioClassCandidate::soap_default(NULL); }
	virtual ~tt__AudioClassCandidate() { }
	friend SOAP_FMAC1 tt__AudioClassCandidate * SOAP_FMAC2 soap_instantiate_tt__AudioClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2030 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (833)
/* tt:AudioClassDescriptor complex type: */
class SOAP_CMAC tt__AudioClassDescriptor
{
public:
	int __sizeClassCandidate;	/* sequence of elements <ClassCandidate> of XSD type tt:AudioClassCandidate */
	tt__AudioClassCandidate **ClassCandidate;
	tt__AudioClassDescriptorExtension *Extension;	/* optional element of XSD type tt:AudioClassDescriptorExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptor (833)
	virtual int soap_type(void) const { return 833; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptor, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptor); }
	         tt__AudioClassDescriptor() { tt__AudioClassDescriptor::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptor() { }
	friend SOAP_FMAC1 tt__AudioClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2033 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (834)
/* tt:AudioClassDescriptorExtension complex type: */
class SOAP_CMAC tt__AudioClassDescriptorExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptorExtension (834)
	virtual int soap_type(void) const { return 834; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptorExtension); }
	         tt__AudioClassDescriptorExtension() { tt__AudioClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptorExtension() { }
	friend SOAP_FMAC1 tt__AudioClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2036 */
#ifndef SOAP_TYPE_tt__ActiveConnection
#define SOAP_TYPE_tt__ActiveConnection (835)
/* tt:ActiveConnection complex type: */
class SOAP_CMAC tt__ActiveConnection
{
public:
	float CurrentBitrate;	/* required element of XSD type xsd:float */
	float CurrentFps;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActiveConnection (835)
	virtual int soap_type(void) const { return 835; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActiveConnection, default initialized and not managed by a soap context
	virtual tt__ActiveConnection *soap_alloc(void) const { return SOAP_NEW(tt__ActiveConnection); }
	         tt__ActiveConnection() { tt__ActiveConnection::soap_default(NULL); }
	virtual ~tt__ActiveConnection() { }
	friend SOAP_FMAC1 tt__ActiveConnection * SOAP_FMAC2 soap_instantiate_tt__ActiveConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2039 */
#ifndef SOAP_TYPE_tt__ProfileStatus
#define SOAP_TYPE_tt__ProfileStatus (836)
/* tt:ProfileStatus complex type: */
class SOAP_CMAC tt__ProfileStatus
{
public:
	int __sizeActiveConnections;	/* sequence of elements <ActiveConnections> of XSD type tt:ActiveConnection */
	tt__ActiveConnection **ActiveConnections;
	tt__ProfileStatusExtension *Extension;	/* optional element of XSD type tt:ProfileStatusExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileStatus (836)
	virtual int soap_type(void) const { return 836; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileStatus, default initialized and not managed by a soap context
	virtual tt__ProfileStatus *soap_alloc(void) const { return SOAP_NEW(tt__ProfileStatus); }
	         tt__ProfileStatus() { tt__ProfileStatus::soap_default(NULL); }
	virtual ~tt__ProfileStatus() { }
	friend SOAP_FMAC1 tt__ProfileStatus * SOAP_FMAC2 soap_instantiate_tt__ProfileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2042 */
#ifndef SOAP_TYPE_tt__ProfileStatusExtension
#define SOAP_TYPE_tt__ProfileStatusExtension (837)
/* tt:ProfileStatusExtension complex type: */
class SOAP_CMAC tt__ProfileStatusExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileStatusExtension (837)
	virtual int soap_type(void) const { return 837; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileStatusExtension, default initialized and not managed by a soap context
	virtual tt__ProfileStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileStatusExtension); }
	         tt__ProfileStatusExtension() { tt__ProfileStatusExtension::soap_default(NULL); }
	virtual ~tt__ProfileStatusExtension() { }
	friend SOAP_FMAC1 tt__ProfileStatusExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2048 */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (839)
/* tt:OSDPosConfiguration complex type: */
class SOAP_CMAC tt__OSDPosConfiguration
{
public:
	char *Type;	/* required element of XSD type xsd:string */
	tt__Vector *Pos;	/* optional element of XSD type tt:Vector */
	tt__OSDPosConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDPosConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfiguration (839)
	virtual int soap_type(void) const { return 839; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfiguration); }
	         tt__OSDPosConfiguration() { tt__OSDPosConfiguration::soap_default(NULL); }
	virtual ~tt__OSDPosConfiguration() { }
	friend SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2051 */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (840)
/* tt:OSDPosConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDPosConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfigurationExtension (840)
	virtual int soap_type(void) const { return 840; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfigurationExtension); }
	         tt__OSDPosConfigurationExtension() { tt__OSDPosConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDPosConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2054 */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (841)
/* tt:OSDColor complex type: */
class SOAP_CMAC tt__OSDColor
{
public:
	tt__Color *Color;	/* required element of XSD type tt:Color */
	int *Transparent;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColor (841)
	virtual int soap_type(void) const { return 841; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColor, default initialized and not managed by a soap context
	virtual tt__OSDColor *soap_alloc(void) const { return SOAP_NEW(tt__OSDColor); }
	         tt__OSDColor() { tt__OSDColor::soap_default(NULL); }
	virtual ~tt__OSDColor() { }
	friend SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2057 */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (842)
/* tt:OSDTextConfiguration complex type: */
class SOAP_CMAC tt__OSDTextConfiguration
{
public:
	char *Type;	/* required element of XSD type xsd:string */
	char *DateFormat;	/* optional element of XSD type xsd:string */
	char *TimeFormat;	/* optional element of XSD type xsd:string */
	int *FontSize;	/* optional element of XSD type xsd:int */
	tt__OSDColor *FontColor;	/* optional element of XSD type tt:OSDColor */
	tt__OSDColor *BackgroundColor;	/* optional element of XSD type tt:OSDColor */
	char *PlainText;	/* optional element of XSD type xsd:string */
	tt__OSDTextConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDTextConfigurationExtension */
	bool *IsPersistentText;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfiguration (842)
	virtual int soap_type(void) const { return 842; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfiguration); }
	         tt__OSDTextConfiguration() { tt__OSDTextConfiguration::soap_default(NULL); }
	virtual ~tt__OSDTextConfiguration() { }
	friend SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2060 */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (843)
/* tt:OSDTextConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDTextConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfigurationExtension (843)
	virtual int soap_type(void) const { return 843; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfigurationExtension); }
	         tt__OSDTextConfigurationExtension() { tt__OSDTextConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDTextConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2063 */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (844)
/* tt:OSDImgConfiguration complex type: */
class SOAP_CMAC tt__OSDImgConfiguration
{
public:
	char *ImgPath;	/* required element of XSD type xsd:anyURI */
	tt__OSDImgConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDImgConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfiguration (844)
	virtual int soap_type(void) const { return 844; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfiguration); }
	         tt__OSDImgConfiguration() { tt__OSDImgConfiguration::soap_default(NULL); }
	virtual ~tt__OSDImgConfiguration() { }
	friend SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2066 */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (845)
/* tt:OSDImgConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDImgConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfigurationExtension (845)
	virtual int soap_type(void) const { return 845; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfigurationExtension); }
	         tt__OSDImgConfigurationExtension() { tt__OSDImgConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDImgConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2069 */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (846)
/* tt:ColorspaceRange complex type: */
class SOAP_CMAC tt__ColorspaceRange
{
public:
	tt__FloatRange *X;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Y;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Z;	/* required element of XSD type tt:FloatRange */
	char *Colorspace;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorspaceRange (846)
	virtual int soap_type(void) const { return 846; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorspaceRange, default initialized and not managed by a soap context
	virtual tt__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW(tt__ColorspaceRange); }
	         tt__ColorspaceRange() { tt__ColorspaceRange::soap_default(NULL); }
	virtual ~tt__ColorspaceRange() { }
	friend SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2072 */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (847)
/* tt:ColorOptions complex type: */
class SOAP_CMAC tt__ColorOptions
{
public:
	int __sizeColorList;	/* sequence of elements <ColorList> of XSD type tt:Color */
	tt__Color **ColorList;
	int __sizeColorspaceRange;	/* sequence of elements <ColorspaceRange> of XSD type tt:ColorspaceRange */
	tt__ColorspaceRange **ColorspaceRange;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorOptions (847)
	virtual int soap_type(void) const { return 847; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorOptions, default initialized and not managed by a soap context
	virtual tt__ColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__ColorOptions); }
	         tt__ColorOptions() { tt__ColorOptions::soap_default(NULL); }
	virtual ~tt__ColorOptions() { }
	friend SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2075 */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (848)
/* tt:OSDColorOptions complex type: */
class SOAP_CMAC tt__OSDColorOptions
{
public:
	tt__ColorOptions *Color;	/* optional element of XSD type tt:ColorOptions */
	tt__IntRange *Transparent;	/* optional element of XSD type tt:IntRange */
	tt__OSDColorOptionsExtension *Extension;	/* optional element of XSD type tt:OSDColorOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptions (848)
	virtual int soap_type(void) const { return 848; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptions, default initialized and not managed by a soap context
	virtual tt__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptions); }
	         tt__OSDColorOptions() { tt__OSDColorOptions::soap_default(NULL); }
	virtual ~tt__OSDColorOptions() { }
	friend SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2078 */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (849)
/* tt:OSDColorOptionsExtension complex type: */
class SOAP_CMAC tt__OSDColorOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptionsExtension (849)
	virtual int soap_type(void) const { return 849; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptionsExtension); }
	         tt__OSDColorOptionsExtension() { tt__OSDColorOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDColorOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2081 */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (850)
/* tt:OSDTextOptions complex type: */
class SOAP_CMAC tt__OSDTextOptions
{
public:
	int __sizeType;	/* sequence of elements <Type> of XSD type xsd:string */
	char **Type;
	tt__IntRange *FontSizeRange;	/* optional element of XSD type tt:IntRange */
	int __sizeDateFormat;	/* sequence of elements <DateFormat> of XSD type xsd:string */
	char **DateFormat;
	int __sizeTimeFormat;	/* sequence of elements <TimeFormat> of XSD type xsd:string */
	char **TimeFormat;
	tt__OSDColorOptions *FontColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDColorOptions *BackgroundColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDTextOptionsExtension *Extension;	/* optional element of XSD type tt:OSDTextOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptions (850)
	virtual int soap_type(void) const { return 850; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptions, default initialized and not managed by a soap context
	virtual tt__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptions); }
	         tt__OSDTextOptions() { tt__OSDTextOptions::soap_default(NULL); }
	virtual ~tt__OSDTextOptions() { }
	friend SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2084 */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (851)
/* tt:OSDTextOptionsExtension complex type: */
class SOAP_CMAC tt__OSDTextOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptionsExtension (851)
	virtual int soap_type(void) const { return 851; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptionsExtension); }
	         tt__OSDTextOptionsExtension() { tt__OSDTextOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDTextOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2087 */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (852)
/* tt:OSDImgOptions complex type: */
class SOAP_CMAC tt__OSDImgOptions
{
public:
	int __sizeImagePath;	/* sequence of elements <ImagePath> of XSD type xsd:anyURI */
	char **ImagePath;
	tt__OSDImgOptionsExtension *Extension;	/* optional element of XSD type tt:OSDImgOptionsExtension */
	char *FormatsSupported;	/* optional attribute of XSD type tt:StringAttrList */
	int *MaxSize;	/* optional attribute of XSD type xsd:int */
	int *MaxWidth;	/* optional attribute of XSD type xsd:int */
	int *MaxHeight;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptions (852)
	virtual int soap_type(void) const { return 852; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptions, default initialized and not managed by a soap context
	virtual tt__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptions); }
	         tt__OSDImgOptions() { tt__OSDImgOptions::soap_default(NULL); }
	virtual ~tt__OSDImgOptions() { }
	friend SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2090 */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (853)
/* tt:OSDImgOptionsExtension complex type: */
class SOAP_CMAC tt__OSDImgOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptionsExtension (853)
	virtual int soap_type(void) const { return 853; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptionsExtension); }
	         tt__OSDImgOptionsExtension() { tt__OSDImgOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDImgOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2096 */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (855)
/* tt:OSDConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationExtension (855)
	virtual int soap_type(void) const { return 855; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationExtension); }
	         tt__OSDConfigurationExtension() { tt__OSDConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2099 */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (856)
/* tt:MaximumNumberOfOSDs complex type: */
class SOAP_CMAC tt__MaximumNumberOfOSDs
{
public:
	int Total;	/* required attribute of XSD type xsd:int */
	int *Image;	/* optional attribute of XSD type xsd:int */
	int *PlainText;	/* optional attribute of XSD type xsd:int */
	int *Date;	/* optional attribute of XSD type xsd:int */
	int *Time;	/* optional attribute of XSD type xsd:int */
	int *DateAndTime;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MaximumNumberOfOSDs (856)
	virtual int soap_type(void) const { return 856; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MaximumNumberOfOSDs, default initialized and not managed by a soap context
	virtual tt__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW(tt__MaximumNumberOfOSDs); }
	         tt__MaximumNumberOfOSDs() { tt__MaximumNumberOfOSDs::soap_default(NULL); }
	virtual ~tt__MaximumNumberOfOSDs() { }
	friend SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2102 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (857)
/* tt:OSDConfigurationOptions complex type: */
class SOAP_CMAC tt__OSDConfigurationOptions
{
public:
	tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;	/* required element of XSD type tt:MaximumNumberOfOSDs */
	int __sizeType;	/* sequence of elements <Type> of XSD type tt:OSDType */
	enum tt__OSDType *Type;
	int __sizePositionOption;	/* sequence of elements <PositionOption> of XSD type xsd:string */
	char **PositionOption;
	tt__OSDTextOptions *TextOption;	/* optional element of XSD type tt:OSDTextOptions */
	tt__OSDImgOptions *ImageOption;	/* optional element of XSD type tt:OSDImgOptions */
	tt__OSDConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptions (857)
	virtual int soap_type(void) const { return 857; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptions); }
	         tt__OSDConfigurationOptions() { tt__OSDConfigurationOptions::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptions() { }
	friend SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2105 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (858)
/* tt:OSDConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptionsExtension (858)
	virtual int soap_type(void) const { return 858; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptionsExtension); }
	         tt__OSDConfigurationOptionsExtension() { tt__OSDConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2108 */
#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (859)
/* tt:FileProgress complex type: */
class SOAP_CMAC tt__FileProgress
{
public:
	char *FileName;	/* required element of XSD type xsd:string */
	float Progress;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FileProgress (859)
	virtual int soap_type(void) const { return 859; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FileProgress, default initialized and not managed by a soap context
	virtual tt__FileProgress *soap_alloc(void) const { return SOAP_NEW(tt__FileProgress); }
	         tt__FileProgress() { tt__FileProgress::soap_default(NULL); }
	virtual ~tt__FileProgress() { }
	friend SOAP_FMAC1 tt__FileProgress * SOAP_FMAC2 soap_instantiate_tt__FileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2111 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (860)
/* tt:ArrayOfFileProgress complex type: */
class SOAP_CMAC tt__ArrayOfFileProgress
{
public:
	int __sizeFileProgress;	/* sequence of elements <FileProgress> of XSD type tt:FileProgress */
	tt__FileProgress **FileProgress;
	tt__ArrayOfFileProgressExtension *Extension;	/* optional element of XSD type tt:ArrayOfFileProgressExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgress (860)
	virtual int soap_type(void) const { return 860; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgress, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgress *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgress); }
	         tt__ArrayOfFileProgress() { tt__ArrayOfFileProgress::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgress() { }
	friend SOAP_FMAC1 tt__ArrayOfFileProgress * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2114 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (861)
/* tt:ArrayOfFileProgressExtension complex type: */
class SOAP_CMAC tt__ArrayOfFileProgressExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgressExtension (861)
	virtual int soap_type(void) const { return 861; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgressExtension, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgressExtension *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgressExtension); }
	         tt__ArrayOfFileProgressExtension() { tt__ArrayOfFileProgressExtension::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgressExtension() { }
	friend SOAP_FMAC1 tt__ArrayOfFileProgressExtension * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgressExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2117 */
#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (862)
/* tt:StorageReferencePath complex type: */
class SOAP_CMAC tt__StorageReferencePath
{
public:
	char *StorageToken;	/* required element of XSD type tt:ReferenceToken */
	char *RelativePath;	/* optional element of XSD type xsd:string */
	tt__StorageReferencePathExtension *Extension;	/* optional element of XSD type tt:StorageReferencePathExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePath (862)
	virtual int soap_type(void) const { return 862; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePath, default initialized and not managed by a soap context
	virtual tt__StorageReferencePath *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePath); }
	         tt__StorageReferencePath() { tt__StorageReferencePath::soap_default(NULL); }
	virtual ~tt__StorageReferencePath() { }
	friend SOAP_FMAC1 tt__StorageReferencePath * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2120 */
#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (863)
/* tt:StorageReferencePathExtension complex type: */
class SOAP_CMAC tt__StorageReferencePathExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePathExtension (863)
	virtual int soap_type(void) const { return 863; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePathExtension, default initialized and not managed by a soap context
	virtual tt__StorageReferencePathExtension *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePathExtension); }
	         tt__StorageReferencePathExtension() { tt__StorageReferencePathExtension::soap_default(NULL); }
	virtual ~tt__StorageReferencePathExtension() { }
	friend SOAP_FMAC1 tt__StorageReferencePathExtension * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePathExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2123 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (864)
/* tt:Vector2D complex type: */
class SOAP_CMAC tt__Vector2D
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	float y;	/* required attribute of XSD type xsd:float */
	char *space;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector2D (864)
	virtual int soap_type(void) const { return 864; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
	virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW(tt__Vector2D); }
	         tt__Vector2D() { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
	friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2126 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (865)
/* tt:Vector1D complex type: */
class SOAP_CMAC tt__Vector1D
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	char *space;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector1D (865)
	virtual int soap_type(void) const { return 865; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
	virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW(tt__Vector1D); }
	         tt__Vector1D() { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
	friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2129 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (866)
/* tt:PTZVector complex type: */
class SOAP_CMAC tt__PTZVector
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZVector (866)
	virtual int soap_type(void) const { return 866; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
	virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW(tt__PTZVector); }
	         tt__PTZVector() { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
	friend SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2132 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (867)
/* tt:PTZStatus complex type: */
class SOAP_CMAC tt__PTZStatus
{
public:
	tt__PTZVector *Position;	/* optional element of XSD type tt:PTZVector */
	tt__PTZMoveStatus *MoveStatus;	/* optional element of XSD type tt:PTZMoveStatus */
	char *Error;	/* optional element of XSD type xsd:string */
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatus (867)
	virtual int soap_type(void) const { return 867; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
	virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatus); }
	         tt__PTZStatus() { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
	friend SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2135 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (868)
/* tt:PTZMoveStatus complex type: */
class SOAP_CMAC tt__PTZMoveStatus
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of XSD type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of XSD type tt:MoveStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZMoveStatus (868)
	virtual int soap_type(void) const { return 868; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
	virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZMoveStatus); }
	         tt__PTZMoveStatus() { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
	friend SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2138 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (869)
/* tt:Vector complex type: */
class SOAP_CMAC tt__Vector
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector (869)
	virtual int soap_type(void) const { return 869; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector, default initialized and not managed by a soap context
	virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW(tt__Vector); }
	         tt__Vector() { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
	friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2141 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (870)
/* tt:Rectangle complex type: */
class SOAP_CMAC tt__Rectangle
{
public:
	float *bottom;	/* optional attribute of XSD type xsd:float */
	float *top;	/* optional attribute of XSD type xsd:float */
	float *right;	/* optional attribute of XSD type xsd:float */
	float *left;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rectangle (870)
	virtual int soap_type(void) const { return 870; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
	virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW(tt__Rectangle); }
	         tt__Rectangle() { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
	friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2144 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (871)
/* tt:Polygon complex type: */
class SOAP_CMAC tt__Polygon
{
public:
	int __sizePoint;	/* sequence of elements <Point> of XSD type tt:Vector */
	tt__Vector **Point;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polygon (871)
	virtual int soap_type(void) const { return 871; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
	virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW(tt__Polygon); }
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
	friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2147 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (872)
/* tt:Color complex type: */
class SOAP_CMAC tt__Color
{
public:
	float X;	/* required attribute of XSD type xsd:float */
	float Y;	/* required attribute of XSD type xsd:float */
	float Z;	/* required attribute of XSD type xsd:float */
	char *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Color (872)
	virtual int soap_type(void) const { return 872; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Color, default initialized and not managed by a soap context
	virtual tt__Color *soap_alloc(void) const { return SOAP_NEW(tt__Color); }
	         tt__Color() { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
	friend SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2150 */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (873)
/* tt:ColorCovariance complex type: */
class SOAP_CMAC tt__ColorCovariance
{
public:
	float XX;	/* required attribute of XSD type xsd:float */
	float YY;	/* required attribute of XSD type xsd:float */
	float ZZ;	/* required attribute of XSD type xsd:float */
	float *XY;	/* optional attribute of XSD type xsd:float */
	float *XZ;	/* optional attribute of XSD type xsd:float */
	float *YZ;	/* optional attribute of XSD type xsd:float */
	char *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorCovariance (873)
	virtual int soap_type(void) const { return 873; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorCovariance, default initialized and not managed by a soap context
	virtual tt__ColorCovariance *soap_alloc(void) const { return SOAP_NEW(tt__ColorCovariance); }
	         tt__ColorCovariance() { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
	friend SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2153 */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (874)
/* tt:Transformation complex type: */
class SOAP_CMAC tt__Transformation
{
public:
	tt__Vector *Translate;	/* optional element of XSD type tt:Vector */
	tt__Vector *Scale;	/* optional element of XSD type tt:Vector */
	tt__TransformationExtension *Extension;	/* optional element of XSD type tt:TransformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transformation (874)
	virtual int soap_type(void) const { return 874; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transformation, default initialized and not managed by a soap context
	virtual tt__Transformation *soap_alloc(void) const { return SOAP_NEW(tt__Transformation); }
	         tt__Transformation() { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
	friend SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2156 */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (875)
/* tt:TransformationExtension complex type: */
class SOAP_CMAC tt__TransformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransformationExtension (875)
	virtual int soap_type(void) const { return 875; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransformationExtension, default initialized and not managed by a soap context
	virtual tt__TransformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__TransformationExtension); }
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
	friend SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2159 */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (876)
/* tt:GeoLocation complex type: */
class SOAP_CMAC tt__GeoLocation
{
public:
	double *lon;	/* optional attribute of XSD type xsd:double */
	double *lat;	/* optional attribute of XSD type xsd:double */
	float *elevation;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GeoLocation (876)
	virtual int soap_type(void) const { return 876; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GeoLocation, default initialized and not managed by a soap context
	virtual tt__GeoLocation *soap_alloc(void) const { return SOAP_NEW(tt__GeoLocation); }
	         tt__GeoLocation() { tt__GeoLocation::soap_default(NULL); }
	virtual ~tt__GeoLocation() { }
	friend SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2162 */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (877)
/* tt:GeoOrientation complex type: */
class SOAP_CMAC tt__GeoOrientation
{
public:
	float *roll;	/* optional attribute of XSD type xsd:float */
	float *pitch;	/* optional attribute of XSD type xsd:float */
	float *yaw;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GeoOrientation (877)
	virtual int soap_type(void) const { return 877; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GeoOrientation, default initialized and not managed by a soap context
	virtual tt__GeoOrientation *soap_alloc(void) const { return SOAP_NEW(tt__GeoOrientation); }
	         tt__GeoOrientation() { tt__GeoOrientation::soap_default(NULL); }
	virtual ~tt__GeoOrientation() { }
	friend SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2165 */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (878)
/* tt:LocalLocation complex type: */
class SOAP_CMAC tt__LocalLocation
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	float *z;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocalLocation (878)
	virtual int soap_type(void) const { return 878; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocalLocation, default initialized and not managed by a soap context
	virtual tt__LocalLocation *soap_alloc(void) const { return SOAP_NEW(tt__LocalLocation); }
	         tt__LocalLocation() { tt__LocalLocation::soap_default(NULL); }
	virtual ~tt__LocalLocation() { }
	friend SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2168 */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (879)
/* tt:LocalOrientation complex type: */
class SOAP_CMAC tt__LocalOrientation
{
public:
	float *pan;	/* optional attribute of XSD type xsd:float */
	float *tilt;	/* optional attribute of XSD type xsd:float */
	float *roll;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocalOrientation (879)
	virtual int soap_type(void) const { return 879; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocalOrientation, default initialized and not managed by a soap context
	virtual tt__LocalOrientation *soap_alloc(void) const { return SOAP_NEW(tt__LocalOrientation); }
	         tt__LocalOrientation() { tt__LocalOrientation::soap_default(NULL); }
	virtual ~tt__LocalOrientation() { }
	friend SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2171 */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (880)
/* tt:LocationEntity complex type: */
class SOAP_CMAC tt__LocationEntity
{
public:
	tt__GeoLocation *GeoLocation;	/* optional element of XSD type tt:GeoLocation */
	tt__GeoOrientation *GeoOrientation;	/* optional element of XSD type tt:GeoOrientation */
	tt__LocalLocation *LocalLocation;	/* optional element of XSD type tt:LocalLocation */
	tt__LocalOrientation *LocalOrientation;	/* optional element of XSD type tt:LocalOrientation */
	char *Entity;	/* optional attribute of XSD type xsd:string */
	char *Token;	/* optional attribute of XSD type tt:ReferenceToken */
	bool *Fixed;	/* optional attribute of XSD type xsd:boolean */
	char *GeoSource;	/* optional attribute of XSD type xsd:anyURI */
	bool *AutoGeo;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocationEntity (880)
	virtual int soap_type(void) const { return 880; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocationEntity, default initialized and not managed by a soap context
	virtual tt__LocationEntity *soap_alloc(void) const { return SOAP_NEW(tt__LocationEntity); }
	         tt__LocationEntity() { tt__LocationEntity::soap_default(NULL); }
	virtual ~tt__LocationEntity() { }
	friend SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2174 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (881)
/* tt:Message complex type: */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Key;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Data;	/* optional element of XSD type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of XSD type tt:MessageExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute of XSD type tt:PropertyOperation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Message (881)
	virtual int soap_type(void) const { return 881; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Message, default initialized and not managed by a soap context
	virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW(_tt__Message); }
	         _tt__Message() { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
	friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2177 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (882)
/* wsnt:QueryExpressionType complex type: */
class SOAP_CMAC wsnt__QueryExpressionType
{
public:
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__QueryExpressionType (882)
	virtual int soap_type(void) const { return 882; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
	virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__QueryExpressionType); }
	         wsnt__QueryExpressionType() { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
	friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2180 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (883)
/* wsnt:TopicExpressionType complex type: */
class SOAP_CMAC wsnt__TopicExpressionType
{
public:
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionType (883)
	virtual int soap_type(void) const { return 883; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionType); }
	         wsnt__TopicExpressionType() { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2183 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (884)
/* Type wsnt__FilterType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:FilterType complex type: */
class SOAP_CMAC wsnt__FilterType
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__FilterType (884)
	virtual int soap_type(void) const { return 884; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
	virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW(wsnt__FilterType); }
	         wsnt__FilterType() { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
	friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2186 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (885)
/* wsnt:SubscriptionPolicyType complex type: */
class SOAP_CMAC wsnt__SubscriptionPolicyType
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscriptionPolicyType (885)
	virtual int soap_type(void) const { return 885; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
	virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscriptionPolicyType); }
	         wsnt__SubscriptionPolicyType() { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
	friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:23935 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1689)
/* wsnt:NotificationMessageHolderType-Message complex type: */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1689)
	virtual int soap_type(void) const { return 1689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
	virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationMessageHolderType_Message); }
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
	friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2189 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (886)
/* wsnt:NotificationMessageHolderType complex type: */
class SOAP_CMAC wsnt__NotificationMessageHolderType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of XSD type wsnt:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of XSD type wsnt:NotificationMessageHolderType-Message */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotificationMessageHolderType (886)
	virtual int soap_type(void) const { return 886; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
	virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotificationMessageHolderType); }
	         wsnt__NotificationMessageHolderType() { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
	friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2252 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (907)
/* wsnt:NotificationProducerRP complex type: */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	int __sizeTopicExpression;	/* sequence of elements <TopicExpression> of XSD type wsnt:TopicExpressionType */
	wsnt__TopicExpressionType **TopicExpression;
	bool FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	int __sizeTopicExpressionDialect;	/* sequence of elements <TopicExpressionDialect> of XSD type xsd:anyURI */
	char **TopicExpressionDialect;
	wstop__TopicSetType *wstop__TopicSet;	/* optional element of XSD type wstop:TopicSetType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationProducerRP (907)
	virtual int soap_type(void) const { return 907; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
	virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationProducerRP); }
	         _wsnt__NotificationProducerRP() { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
	friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2255 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (908)
/* wsnt:SubscriptionManagerRP complex type: */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of XSD type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscriptionManagerRP (908)
	virtual int soap_type(void) const { return 908; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
	virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscriptionManagerRP); }
	         _wsnt__SubscriptionManagerRP() { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
	friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2258 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (909)
/* wsnt:Notify complex type: */
class SOAP_CMAC _wsnt__Notify
{
public:
	int __sizeNotificationMessage;	/* sequence of elements <NotificationMessage> of XSD type wsnt:NotificationMessageHolderType */
	wsnt__NotificationMessageHolderType **NotificationMessage;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Notify (909)
	virtual int soap_type(void) const { return 909; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
	virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW(_wsnt__Notify); }
	         _wsnt__Notify() { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
	friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2261 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (910)
/* wsnt:UseRaw complex type: */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UseRaw (910)
	virtual int soap_type(void) const { return 910; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
	virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW(_wsnt__UseRaw); }
	         _wsnt__UseRaw() { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
	friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:24085 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1694)
/* wsnt:Subscribe-SubscriptionPolicy complex type: */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1694)
	virtual int soap_type(void) const { return 1694; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe_SubscriptionPolicy); }
	         _wsnt__Subscribe_SubscriptionPolicy() { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2264 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (911)
/* wsnt:Subscribe complex type: */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	char *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type wsnt:Subscribe-SubscriptionPolicy */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe (911)
	virtual int soap_type(void) const { return 911; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe); }
	         _wsnt__Subscribe() { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
	friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2267 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (912)
/* wsnt:SubscribeResponse complex type: */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscribeResponse (912)
	virtual int soap_type(void) const { return 912; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscribeResponse); }
	         _wsnt__SubscribeResponse() { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2270 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (913)
/* wsnt:GetCurrentMessage complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of XSD type wsnt:TopicExpressionType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessage (913)
	virtual int soap_type(void) const { return 913; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessage); }
	         _wsnt__GetCurrentMessage() { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2273 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (914)
/* wsnt:GetCurrentMessageResponse complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessageResponse (914)
	virtual int soap_type(void) const { return 914; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessageResponse); }
	         _wsnt__GetCurrentMessageResponse() { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2276 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (915)
/* wsnt:GetMessages complex type: */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	char *MaximumNumber;	/* optional element of XSD type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessages (915)
	virtual int soap_type(void) const { return 915; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
	virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessages); }
	         _wsnt__GetMessages() { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
	friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2279 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (916)
/* wsnt:GetMessagesResponse complex type: */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	int __sizeNotificationMessage;	/* sequence of elements <NotificationMessage> of XSD type wsnt:NotificationMessageHolderType */
	wsnt__NotificationMessageHolderType **NotificationMessage;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessagesResponse (916)
	virtual int soap_type(void) const { return 916; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessagesResponse); }
	         _wsnt__GetMessagesResponse() { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
	friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2282 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (917)
/* wsnt:DestroyPullPoint complex type: */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPoint (917)
	virtual int soap_type(void) const { return 917; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPoint); }
	         _wsnt__DestroyPullPoint() { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2285 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (918)
/* wsnt:DestroyPullPointResponse complex type: */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPointResponse (918)
	virtual int soap_type(void) const { return 918; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPointResponse); }
	         _wsnt__DestroyPullPointResponse() { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2288 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (919)
/* wsnt:CreatePullPoint complex type: */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPoint (919)
	virtual int soap_type(void) const { return 919; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPoint); }
	         _wsnt__CreatePullPoint() { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2291 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (920)
/* wsnt:CreatePullPointResponse complex type: */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* required element of XSD type wsa5:EndpointReferenceType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPointResponse (920)
	virtual int soap_type(void) const { return 920; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPointResponse); }
	         _wsnt__CreatePullPointResponse() { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2294 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (921)
/* wsnt:Renew complex type: */
class SOAP_CMAC _wsnt__Renew
{
public:
	char *TerminationTime;	/* required element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Renew (921)
	virtual int soap_type(void) const { return 921; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
	virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW(_wsnt__Renew); }
	         _wsnt__Renew() { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
	friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2297 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (922)
/* wsnt:RenewResponse complex type: */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* required element of XSD type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__RenewResponse (922)
	virtual int soap_type(void) const { return 922; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
	virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__RenewResponse); }
	         _wsnt__RenewResponse() { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
	friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2300 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (923)
/* wsnt:Unsubscribe complex type: */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Unsubscribe (923)
	virtual int soap_type(void) const { return 923; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
	virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Unsubscribe); }
	         _wsnt__Unsubscribe() { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
	friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2303 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (924)
/* wsnt:UnsubscribeResponse complex type: */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UnsubscribeResponse (924)
	virtual int soap_type(void) const { return 924; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__UnsubscribeResponse); }
	         _wsnt__UnsubscribeResponse() { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2306 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (925)
/* wsnt:PauseSubscription complex type: */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscription (925)
	virtual int soap_type(void) const { return 925; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscription); }
	         _wsnt__PauseSubscription() { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2309 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (926)
/* wsnt:PauseSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscriptionResponse (926)
	virtual int soap_type(void) const { return 926; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscriptionResponse); }
	         _wsnt__PauseSubscriptionResponse() { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2312 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (927)
/* wsnt:ResumeSubscription complex type: */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscription (927)
	virtual int soap_type(void) const { return 927; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscription); }
	         _wsnt__ResumeSubscription() { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2315 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (928)
/* wsnt:ResumeSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscriptionResponse (928)
	virtual int soap_type(void) const { return 928; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscriptionResponse); }
	         _wsnt__ResumeSubscriptionResponse() { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:24623 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1696)
/* wsrfbf:BaseFaultType-ErrorCode complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode
{
public:
	char *dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1696)
	virtual int soap_type(void) const { return 1696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode); }
	         _wsrfbf__BaseFaultType_ErrorCode() { _wsrfbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:24644 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1698)
/* wsrfbf:BaseFaultType-Description simple type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description
{
public:
	char *__item;	/* mixed XML content */
	char *xml__lang;	/* optional attribute of XSD type xml:lang */
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_Description (1698)
	virtual int soap_type(void) const { return 1698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_Description); }
	         _wsrfbf__BaseFaultType_Description() { _wsrfbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_Description() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:24661 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1700)
/* wsrfbf:BaseFaultType-FaultCause complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1700)
	virtual int soap_type(void) const { return 1700; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause); }
	         _wsrfbf__BaseFaultType_FaultCause() { _wsrfbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2318 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (929)
/* Type wsrfbf__BaseFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfbf:BaseFaultType complex type: */
class SOAP_CMAC wsrfbf__BaseFaultType
{
public:
	time_t Timestamp;	/* required element of XSD type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of XSD type wsrfbf:BaseFaultType-ErrorCode */
	int __sizeDescription;	/* sequence of elements <Description> of XSD type wsrfbf:BaseFaultType-Description */
	_wsrfbf__BaseFaultType_Description *Description;
	_wsrfbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of XSD type wsrfbf:BaseFaultType-FaultCause */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfbf__BaseFaultType (929)
	virtual int soap_type(void) const { return 929; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
	virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfbf__BaseFaultType); }
	         wsrfbf__BaseFaultType() { wsrfbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsrfbf__BaseFaultType() { }
	friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2321 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (930)
/* wstop:Documentation complex type: */
class SOAP_CMAC wstop__Documentation
{
public:
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__Documentation (930)
	virtual int soap_type(void) const { return 930; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
	virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW(wstop__Documentation); }
	         wstop__Documentation() { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
	friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2324 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (931)
/* Type wstop__ExtensibleDocumented is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ExtensibleDocumented complex type: */
class SOAP_CMAC wstop__ExtensibleDocumented
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ExtensibleDocumented (931)
	virtual int soap_type(void) const { return 931; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
	virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(wstop__ExtensibleDocumented); }
	         wstop__ExtensibleDocumented() { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
	friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2327 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (932)
/* wstop:QueryExpressionType complex type: */
class SOAP_CMAC wstop__QueryExpressionType
{
public:
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__QueryExpressionType (932)
	virtual int soap_type(void) const { return 932; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
	virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wstop__QueryExpressionType); }
	         wstop__QueryExpressionType() { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
	friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2339 */
#ifndef SOAP_TYPE_trt__Capabilities
#define SOAP_TYPE_trt__Capabilities (936)
/* trt:Capabilities complex type: */
class SOAP_CMAC trt__Capabilities
{
public:
	trt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type trt:ProfileCapabilities */
	trt__StreamingCapabilities *StreamingCapabilities;	/* required element of XSD type trt:StreamingCapabilities */
	bool *SnapshotUri;	/* optional attribute of XSD type xsd:boolean */
	bool *Rotation;	/* optional attribute of XSD type xsd:boolean */
	bool *VideoSourceMode;	/* optional attribute of XSD type xsd:boolean */
	bool *OSD;	/* optional attribute of XSD type xsd:boolean */
	bool *TemporaryOSDText;	/* optional attribute of XSD type xsd:boolean */
	bool *EXICompression;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__Capabilities (936)
	virtual int soap_type(void) const { return 936; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__Capabilities, default initialized and not managed by a soap context
	virtual trt__Capabilities *soap_alloc(void) const { return SOAP_NEW(trt__Capabilities); }
	         trt__Capabilities() { trt__Capabilities::soap_default(NULL); }
	virtual ~trt__Capabilities() { }
	friend SOAP_FMAC1 trt__Capabilities * SOAP_FMAC2 soap_instantiate_trt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2342 */
#ifndef SOAP_TYPE_trt__ProfileCapabilities
#define SOAP_TYPE_trt__ProfileCapabilities (937)
/* trt:ProfileCapabilities complex type: */
class SOAP_CMAC trt__ProfileCapabilities
{
public:
	int *MaximumNumberOfProfiles;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__ProfileCapabilities (937)
	virtual int soap_type(void) const { return 937; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual trt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__ProfileCapabilities); }
	         trt__ProfileCapabilities() { trt__ProfileCapabilities::soap_default(NULL); }
	virtual ~trt__ProfileCapabilities() { }
	friend SOAP_FMAC1 trt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_trt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2345 */
#ifndef SOAP_TYPE_trt__StreamingCapabilities
#define SOAP_TYPE_trt__StreamingCapabilities (938)
/* trt:StreamingCapabilities complex type: */
class SOAP_CMAC trt__StreamingCapabilities
{
public:
	bool *RTPMulticast;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *NonAggregateControl;	/* optional attribute of XSD type xsd:boolean */
	bool *NoRTSPStreaming;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__StreamingCapabilities (938)
	virtual int soap_type(void) const { return 938; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__StreamingCapabilities, default initialized and not managed by a soap context
	virtual trt__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__StreamingCapabilities); }
	         trt__StreamingCapabilities() { trt__StreamingCapabilities::soap_default(NULL); }
	virtual ~trt__StreamingCapabilities() { }
	friend SOAP_FMAC1 trt__StreamingCapabilities * SOAP_FMAC2 soap_instantiate_trt__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2348 */
#ifndef SOAP_TYPE_trt__VideoSourceMode
#define SOAP_TYPE_trt__VideoSourceMode (939)
/* trt:VideoSourceMode complex type: */
class SOAP_CMAC trt__VideoSourceMode
{
public:
	float MaxFramerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *MaxResolution;	/* required element of XSD type tt:VideoResolution */
	char *Encodings;	/* required element of XSD type trt:EncodingTypes */
	bool Reboot;	/* required element of XSD type xsd:boolean */
	char *Description;	/* optional element of XSD type tt:Description */
	trt__VideoSourceModeExtension *Extension;	/* optional element of XSD type trt:VideoSourceModeExtension */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *Enabled;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__VideoSourceMode (939)
	virtual int soap_type(void) const { return 939; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__VideoSourceMode, default initialized and not managed by a soap context
	virtual trt__VideoSourceMode *soap_alloc(void) const { return SOAP_NEW(trt__VideoSourceMode); }
	         trt__VideoSourceMode() { trt__VideoSourceMode::soap_default(NULL); }
	virtual ~trt__VideoSourceMode() { }
	friend SOAP_FMAC1 trt__VideoSourceMode * SOAP_FMAC2 soap_instantiate_trt__VideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2351 */
#ifndef SOAP_TYPE_trt__VideoSourceModeExtension
#define SOAP_TYPE_trt__VideoSourceModeExtension (940)
/* trt:VideoSourceModeExtension complex type: */
class SOAP_CMAC trt__VideoSourceModeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__VideoSourceModeExtension (940)
	virtual int soap_type(void) const { return 940; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__VideoSourceModeExtension, default initialized and not managed by a soap context
	virtual trt__VideoSourceModeExtension *soap_alloc(void) const { return SOAP_NEW(trt__VideoSourceModeExtension); }
	         trt__VideoSourceModeExtension() { trt__VideoSourceModeExtension::soap_default(NULL); }
	virtual ~trt__VideoSourceModeExtension() { }
	friend SOAP_FMAC1 trt__VideoSourceModeExtension * SOAP_FMAC2 soap_instantiate_trt__VideoSourceModeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2354 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilities
#define SOAP_TYPE__trt__GetServiceCapabilities (941)
/* trt:GetServiceCapabilities complex type: */
class SOAP_CMAC _trt__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilities (941)
	virtual int soap_type(void) const { return 941; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilities); }
	         _trt__GetServiceCapabilities() { _trt__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2357 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trt__GetServiceCapabilitiesResponse (942)
/* trt:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trt__GetServiceCapabilitiesResponse
{
public:
	trt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilitiesResponse (942)
	virtual int soap_type(void) const { return 942; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilitiesResponse); }
	         _trt__GetServiceCapabilitiesResponse() { _trt__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _trt__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2360 */
#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (943)
/* trt:GetVideoSources complex type: */
class SOAP_CMAC _trt__GetVideoSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSources (943)
	virtual int soap_type(void) const { return 943; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSources, default initialized and not managed by a soap context
	virtual _trt__GetVideoSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSources); }
	         _trt__GetVideoSources() { _trt__GetVideoSources::soap_default(NULL); }
	virtual ~_trt__GetVideoSources() { }
	friend SOAP_FMAC1 _trt__GetVideoSources * SOAP_FMAC2 soap_instantiate__trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2363 */
#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (944)
/* trt:GetVideoSourcesResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourcesResponse
{
public:
	int __sizeVideoSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <VideoSources> of XSD type tt:VideoSource */
	tt__VideoSource **VideoSources;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourcesResponse (944)
	virtual int soap_type(void) const { return 944; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourcesResponse); }
	         _trt__GetVideoSourcesResponse() { _trt__GetVideoSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourcesResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2366 */
#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (945)
/* trt:GetAudioSources complex type: */
class SOAP_CMAC _trt__GetAudioSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSources (945)
	virtual int soap_type(void) const { return 945; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSources, default initialized and not managed by a soap context
	virtual _trt__GetAudioSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSources); }
	         _trt__GetAudioSources() { _trt__GetAudioSources::soap_default(NULL); }
	virtual ~_trt__GetAudioSources() { }
	friend SOAP_FMAC1 _trt__GetAudioSources * SOAP_FMAC2 soap_instantiate__trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2369 */
#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (946)
/* trt:GetAudioSourcesResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourcesResponse
{
public:
	int __sizeAudioSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AudioSources> of XSD type tt:AudioSource */
	tt__AudioSource **AudioSources;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourcesResponse (946)
	virtual int soap_type(void) const { return 946; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourcesResponse); }
	         _trt__GetAudioSourcesResponse() { _trt__GetAudioSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourcesResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2372 */
#ifndef SOAP_TYPE__trt__GetAudioOutputs
#define SOAP_TYPE__trt__GetAudioOutputs (947)
/* trt:GetAudioOutputs complex type: */
class SOAP_CMAC _trt__GetAudioOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputs (947)
	virtual int soap_type(void) const { return 947; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputs, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputs *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputs); }
	         _trt__GetAudioOutputs() { _trt__GetAudioOutputs::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputs() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2375 */
#ifndef SOAP_TYPE__trt__GetAudioOutputsResponse
#define SOAP_TYPE__trt__GetAudioOutputsResponse (948)
/* trt:GetAudioOutputsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputsResponse
{
public:
	int __sizeAudioOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AudioOutputs> of XSD type tt:AudioOutput */
	tt__AudioOutput **AudioOutputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputsResponse (948)
	virtual int soap_type(void) const { return 948; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputsResponse); }
	         _trt__GetAudioOutputsResponse() { _trt__GetAudioOutputsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2378 */
#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (949)
/* trt:CreateProfile complex type: */
class SOAP_CMAC _trt__CreateProfile
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	char *Token;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfile (949)
	virtual int soap_type(void) const { return 949; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfile, default initialized and not managed by a soap context
	virtual _trt__CreateProfile *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfile); }
	         _trt__CreateProfile() { _trt__CreateProfile::soap_default(NULL); }
	virtual ~_trt__CreateProfile() { }
	friend SOAP_FMAC1 _trt__CreateProfile * SOAP_FMAC2 soap_instantiate__trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2381 */
#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (950)
/* trt:CreateProfileResponse complex type: */
class SOAP_CMAC _trt__CreateProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfileResponse (950)
	virtual int soap_type(void) const { return 950; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfileResponse, default initialized and not managed by a soap context
	virtual _trt__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfileResponse); }
	         _trt__CreateProfileResponse() { _trt__CreateProfileResponse::soap_default(NULL); }
	virtual ~_trt__CreateProfileResponse() { }
	friend SOAP_FMAC1 _trt__CreateProfileResponse * SOAP_FMAC2 soap_instantiate__trt__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2384 */
#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (951)
/* trt:GetProfile complex type: */
class SOAP_CMAC _trt__GetProfile
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfile (951)
	virtual int soap_type(void) const { return 951; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfile, default initialized and not managed by a soap context
	virtual _trt__GetProfile *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfile); }
	         _trt__GetProfile() { _trt__GetProfile::soap_default(NULL); }
	virtual ~_trt__GetProfile() { }
	friend SOAP_FMAC1 _trt__GetProfile * SOAP_FMAC2 soap_instantiate__trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2387 */
#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (952)
/* trt:GetProfileResponse complex type: */
class SOAP_CMAC _trt__GetProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfileResponse (952)
	virtual int soap_type(void) const { return 952; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfileResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfileResponse); }
	         _trt__GetProfileResponse() { _trt__GetProfileResponse::soap_default(NULL); }
	virtual ~_trt__GetProfileResponse() { }
	friend SOAP_FMAC1 _trt__GetProfileResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2390 */
#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (953)
/* trt:GetProfiles complex type: */
class SOAP_CMAC _trt__GetProfiles
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfiles (953)
	virtual int soap_type(void) const { return 953; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfiles, default initialized and not managed by a soap context
	virtual _trt__GetProfiles *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfiles); }
	         _trt__GetProfiles() { _trt__GetProfiles::soap_default(NULL); }
	virtual ~_trt__GetProfiles() { }
	friend SOAP_FMAC1 _trt__GetProfiles * SOAP_FMAC2 soap_instantiate__trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2393 */
#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (954)
/* trt:GetProfilesResponse complex type: */
class SOAP_CMAC _trt__GetProfilesResponse
{
public:
	int __sizeProfiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Profiles> of XSD type tt:Profile */
	tt__Profile **Profiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfilesResponse (954)
	virtual int soap_type(void) const { return 954; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfilesResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfilesResponse); }
	         _trt__GetProfilesResponse() { _trt__GetProfilesResponse::soap_default(NULL); }
	virtual ~_trt__GetProfilesResponse() { }
	friend SOAP_FMAC1 _trt__GetProfilesResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2396 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (955)
/* trt:AddVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfiguration (955)
	virtual int soap_type(void) const { return 955; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfiguration); }
	         _trt__AddVideoEncoderConfiguration() { _trt__AddVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2399 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (956)
/* trt:AddVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (956)
	virtual int soap_type(void) const { return 956; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfigurationResponse); }
	         _trt__AddVideoEncoderConfigurationResponse() { _trt__AddVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2402 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (957)
/* trt:RemoveVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (957)
	virtual int soap_type(void) const { return 957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfiguration); }
	         _trt__RemoveVideoEncoderConfiguration() { _trt__RemoveVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2405 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (958)
/* trt:RemoveVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (958)
	virtual int soap_type(void) const { return 958; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfigurationResponse); }
	         _trt__RemoveVideoEncoderConfigurationResponse() { _trt__RemoveVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2408 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (959)
/* trt:AddVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfiguration (959)
	virtual int soap_type(void) const { return 959; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfiguration); }
	         _trt__AddVideoSourceConfiguration() { _trt__AddVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2411 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (960)
/* trt:AddVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (960)
	virtual int soap_type(void) const { return 960; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfigurationResponse); }
	         _trt__AddVideoSourceConfigurationResponse() { _trt__AddVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2414 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (961)
/* trt:RemoveVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfiguration (961)
	virtual int soap_type(void) const { return 961; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfiguration); }
	         _trt__RemoveVideoSourceConfiguration() { _trt__RemoveVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2417 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (962)
/* trt:RemoveVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (962)
	virtual int soap_type(void) const { return 962; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfigurationResponse); }
	         _trt__RemoveVideoSourceConfigurationResponse() { _trt__RemoveVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2420 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (963)
/* trt:AddAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfiguration (963)
	virtual int soap_type(void) const { return 963; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfiguration); }
	         _trt__AddAudioEncoderConfiguration() { _trt__AddAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2423 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (964)
/* trt:AddAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (964)
	virtual int soap_type(void) const { return 964; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfigurationResponse); }
	         _trt__AddAudioEncoderConfigurationResponse() { _trt__AddAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2426 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (965)
/* trt:RemoveAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (965)
	virtual int soap_type(void) const { return 965; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfiguration); }
	         _trt__RemoveAudioEncoderConfiguration() { _trt__RemoveAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2429 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (966)
/* trt:RemoveAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (966)
	virtual int soap_type(void) const { return 966; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfigurationResponse); }
	         _trt__RemoveAudioEncoderConfigurationResponse() { _trt__RemoveAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2432 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (967)
/* trt:AddAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfiguration (967)
	virtual int soap_type(void) const { return 967; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfiguration); }
	         _trt__AddAudioSourceConfiguration() { _trt__AddAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2435 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (968)
/* trt:AddAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (968)
	virtual int soap_type(void) const { return 968; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfigurationResponse); }
	         _trt__AddAudioSourceConfigurationResponse() { _trt__AddAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2438 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (969)
/* trt:RemoveAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfiguration (969)
	virtual int soap_type(void) const { return 969; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfiguration); }
	         _trt__RemoveAudioSourceConfiguration() { _trt__RemoveAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2441 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (970)
/* trt:RemoveAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (970)
	virtual int soap_type(void) const { return 970; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfigurationResponse); }
	         _trt__RemoveAudioSourceConfigurationResponse() { _trt__RemoveAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2444 */
#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (971)
/* trt:AddPTZConfiguration complex type: */
class SOAP_CMAC _trt__AddPTZConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfiguration (971)
	virtual int soap_type(void) const { return 971; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfiguration); }
	         _trt__AddPTZConfiguration() { _trt__AddPTZConfiguration::soap_default(NULL); }
	virtual ~_trt__AddPTZConfiguration() { }
	friend SOAP_FMAC1 _trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2447 */
#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (972)
/* trt:AddPTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddPTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfigurationResponse (972)
	virtual int soap_type(void) const { return 972; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfigurationResponse); }
	         _trt__AddPTZConfigurationResponse() { _trt__AddPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddPTZConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddPTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2450 */
#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (973)
/* trt:RemovePTZConfiguration complex type: */
class SOAP_CMAC _trt__RemovePTZConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfiguration (973)
	virtual int soap_type(void) const { return 973; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfiguration); }
	         _trt__RemovePTZConfiguration() { _trt__RemovePTZConfiguration::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfiguration() { }
	friend SOAP_FMAC1 _trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2453 */
#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (974)
/* trt:RemovePTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemovePTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfigurationResponse (974)
	virtual int soap_type(void) const { return 974; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfigurationResponse); }
	         _trt__RemovePTZConfigurationResponse() { _trt__RemovePTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemovePTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2456 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (975)
/* trt:AddVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (975)
	virtual int soap_type(void) const { return 975; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfiguration); }
	         _trt__AddVideoAnalyticsConfiguration() { _trt__AddVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2459 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (976)
/* trt:AddVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (976)
	virtual int soap_type(void) const { return 976; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfigurationResponse); }
	         _trt__AddVideoAnalyticsConfigurationResponse() { _trt__AddVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2462 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (977)
/* trt:RemoveVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (977)
	virtual int soap_type(void) const { return 977; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfiguration); }
	         _trt__RemoveVideoAnalyticsConfiguration() { _trt__RemoveVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2465 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (978)
/* trt:RemoveVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (978)
	virtual int soap_type(void) const { return 978; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfigurationResponse); }
	         _trt__RemoveVideoAnalyticsConfigurationResponse() { _trt__RemoveVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2468 */
#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (979)
/* trt:AddMetadataConfiguration complex type: */
class SOAP_CMAC _trt__AddMetadataConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfiguration (979)
	virtual int soap_type(void) const { return 979; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfiguration); }
	         _trt__AddMetadataConfiguration() { _trt__AddMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2471 */
#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (980)
/* trt:AddMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfigurationResponse (980)
	virtual int soap_type(void) const { return 980; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfigurationResponse); }
	         _trt__AddMetadataConfigurationResponse() { _trt__AddMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2474 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (981)
/* trt:RemoveMetadataConfiguration complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfiguration (981)
	virtual int soap_type(void) const { return 981; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfiguration); }
	         _trt__RemoveMetadataConfiguration() { _trt__RemoveMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2477 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (982)
/* trt:RemoveMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (982)
	virtual int soap_type(void) const { return 982; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfigurationResponse); }
	         _trt__RemoveMetadataConfigurationResponse() { _trt__RemoveMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2480 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfiguration
#define SOAP_TYPE__trt__AddAudioOutputConfiguration (983)
/* trt:AddAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfiguration (983)
	virtual int soap_type(void) const { return 983; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfiguration); }
	         _trt__AddAudioOutputConfiguration() { _trt__AddAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2483 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (984)
/* trt:AddAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (984)
	virtual int soap_type(void) const { return 984; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfigurationResponse); }
	         _trt__AddAudioOutputConfigurationResponse() { _trt__AddAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2486 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE__trt__RemoveAudioOutputConfiguration (985)
/* trt:RemoveAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfiguration (985)
	virtual int soap_type(void) const { return 985; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfiguration); }
	         _trt__RemoveAudioOutputConfiguration() { _trt__RemoveAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2489 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (986)
/* trt:RemoveAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (986)
	virtual int soap_type(void) const { return 986; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfigurationResponse); }
	         _trt__RemoveAudioOutputConfigurationResponse() { _trt__RemoveAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2492 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfiguration
#define SOAP_TYPE__trt__AddAudioDecoderConfiguration (987)
/* trt:AddAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfiguration (987)
	virtual int soap_type(void) const { return 987; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfiguration); }
	         _trt__AddAudioDecoderConfiguration() { _trt__AddAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2495 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (988)
/* trt:AddAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (988)
	virtual int soap_type(void) const { return 988; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfigurationResponse); }
	         _trt__AddAudioDecoderConfigurationResponse() { _trt__AddAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2498 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (989)
/* trt:RemoveAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (989)
	virtual int soap_type(void) const { return 989; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfiguration); }
	         _trt__RemoveAudioDecoderConfiguration() { _trt__RemoveAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2501 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (990)
/* trt:RemoveAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (990)
	virtual int soap_type(void) const { return 990; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfigurationResponse); }
	         _trt__RemoveAudioDecoderConfigurationResponse() { _trt__RemoveAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2504 */
#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (991)
/* trt:DeleteProfile complex type: */
class SOAP_CMAC _trt__DeleteProfile
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfile (991)
	virtual int soap_type(void) const { return 991; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfile, default initialized and not managed by a soap context
	virtual _trt__DeleteProfile *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfile); }
	         _trt__DeleteProfile() { _trt__DeleteProfile::soap_default(NULL); }
	virtual ~_trt__DeleteProfile() { }
	friend SOAP_FMAC1 _trt__DeleteProfile * SOAP_FMAC2 soap_instantiate__trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2507 */
#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (992)
/* trt:DeleteProfileResponse complex type: */
class SOAP_CMAC _trt__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfileResponse (992)
	virtual int soap_type(void) const { return 992; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfileResponse, default initialized and not managed by a soap context
	virtual _trt__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfileResponse); }
	         _trt__DeleteProfileResponse() { _trt__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_trt__DeleteProfileResponse() { }
	friend SOAP_FMAC1 _trt__DeleteProfileResponse * SOAP_FMAC2 soap_instantiate__trt__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2510 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (993)
/* trt:GetVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurations (993)
	virtual int soap_type(void) const { return 993; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurations); }
	         _trt__GetVideoEncoderConfigurations() { _trt__GetVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2513 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (994)
/* trt:GetVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoEncoderConfiguration */
	tt__VideoEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (994)
	virtual int soap_type(void) const { return 994; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationsResponse); }
	         _trt__GetVideoEncoderConfigurationsResponse() { _trt__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2516 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (995)
/* trt:GetVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurations (995)
	virtual int soap_type(void) const { return 995; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurations); }
	         _trt__GetVideoSourceConfigurations() { _trt__GetVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2519 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (996)
/* trt:GetVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoSourceConfiguration */
	tt__VideoSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (996)
	virtual int soap_type(void) const { return 996; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationsResponse); }
	         _trt__GetVideoSourceConfigurationsResponse() { _trt__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2522 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (997)
/* trt:GetAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurations (997)
	virtual int soap_type(void) const { return 997; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurations); }
	         _trt__GetAudioEncoderConfigurations() { _trt__GetAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2525 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (998)
/* trt:GetAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioEncoderConfiguration */
	tt__AudioEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (998)
	virtual int soap_type(void) const { return 998; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationsResponse); }
	         _trt__GetAudioEncoderConfigurationsResponse() { _trt__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2528 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (999)
/* trt:GetAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurations (999)
	virtual int soap_type(void) const { return 999; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurations); }
	         _trt__GetAudioSourceConfigurations() { _trt__GetAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2531 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (1000)
/* trt:GetAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioSourceConfiguration */
	tt__AudioSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (1000)
	virtual int soap_type(void) const { return 1000; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationsResponse); }
	         _trt__GetAudioSourceConfigurationsResponse() { _trt__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2534 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (1001)
/* trt:GetVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (1001)
	virtual int soap_type(void) const { return 1001; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurations); }
	         _trt__GetVideoAnalyticsConfigurations() { _trt__GetVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2537 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (1002)
/* trt:GetVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoAnalyticsConfiguration */
	tt__VideoAnalyticsConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (1002)
	virtual int soap_type(void) const { return 1002; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationsResponse); }
	         _trt__GetVideoAnalyticsConfigurationsResponse() { _trt__GetVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2540 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (1003)
/* trt:GetMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurations (1003)
	virtual int soap_type(void) const { return 1003; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurations); }
	         _trt__GetMetadataConfigurations() { _trt__GetMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurations() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2543 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (1004)
/* trt:GetMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:MetadataConfiguration */
	tt__MetadataConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationsResponse (1004)
	virtual int soap_type(void) const { return 1004; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationsResponse); }
	         _trt__GetMetadataConfigurationsResponse() { _trt__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2546 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurations
#define SOAP_TYPE__trt__GetAudioOutputConfigurations (1005)
/* trt:GetAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurations (1005)
	virtual int soap_type(void) const { return 1005; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurations); }
	         _trt__GetAudioOutputConfigurations() { _trt__GetAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2549 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (1006)
/* trt:GetAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioOutputConfiguration */
	tt__AudioOutputConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (1006)
	virtual int soap_type(void) const { return 1006; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationsResponse); }
	         _trt__GetAudioOutputConfigurationsResponse() { _trt__GetAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2552 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetAudioDecoderConfigurations (1007)
/* trt:GetAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurations (1007)
	virtual int soap_type(void) const { return 1007; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurations); }
	         _trt__GetAudioDecoderConfigurations() { _trt__GetAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2555 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (1008)
/* trt:GetAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioDecoderConfiguration */
	tt__AudioDecoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (1008)
	virtual int soap_type(void) const { return 1008; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationsResponse); }
	         _trt__GetAudioDecoderConfigurationsResponse() { _trt__GetAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2558 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (1009)
/* trt:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfiguration (1009)
	virtual int soap_type(void) const { return 1009; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfiguration); }
	         _trt__GetVideoSourceConfiguration() { _trt__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2561 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (1010)
/* trt:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (1010)
	virtual int soap_type(void) const { return 1010; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationResponse); }
	         _trt__GetVideoSourceConfigurationResponse() { _trt__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2564 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (1011)
/* trt:GetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfiguration (1011)
	virtual int soap_type(void) const { return 1011; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfiguration); }
	         _trt__GetVideoEncoderConfiguration() { _trt__GetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2567 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (1012)
/* trt:GetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationResponse
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (1012)
	virtual int soap_type(void) const { return 1012; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationResponse); }
	         _trt__GetVideoEncoderConfigurationResponse() { _trt__GetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2570 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (1013)
/* trt:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfiguration (1013)
	virtual int soap_type(void) const { return 1013; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfiguration); }
	         _trt__GetAudioSourceConfiguration() { _trt__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2573 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (1014)
/* trt:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (1014)
	virtual int soap_type(void) const { return 1014; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationResponse); }
	         _trt__GetAudioSourceConfigurationResponse() { _trt__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2576 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (1015)
/* trt:GetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfiguration (1015)
	virtual int soap_type(void) const { return 1015; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfiguration); }
	         _trt__GetAudioEncoderConfiguration() { _trt__GetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2579 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (1016)
/* trt:GetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationResponse
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (1016)
	virtual int soap_type(void) const { return 1016; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationResponse); }
	         _trt__GetAudioEncoderConfigurationResponse() { _trt__GetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2582 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (1017)
/* trt:GetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (1017)
	virtual int soap_type(void) const { return 1017; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfiguration); }
	         _trt__GetVideoAnalyticsConfiguration() { _trt__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2585 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (1018)
/* trt:GetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationResponse
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (1018)
	virtual int soap_type(void) const { return 1018; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationResponse); }
	         _trt__GetVideoAnalyticsConfigurationResponse() { _trt__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2588 */
#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (1019)
/* trt:GetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__GetMetadataConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfiguration (1019)
	virtual int soap_type(void) const { return 1019; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfiguration); }
	         _trt__GetMetadataConfiguration() { _trt__GetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2591 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (1020)
/* trt:GetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationResponse
{
public:
	tt__MetadataConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationResponse (1020)
	virtual int soap_type(void) const { return 1020; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationResponse); }
	         _trt__GetMetadataConfigurationResponse() { _trt__GetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2594 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfiguration
#define SOAP_TYPE__trt__GetAudioOutputConfiguration (1021)
/* trt:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfiguration (1021)
	virtual int soap_type(void) const { return 1021; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfiguration); }
	         _trt__GetAudioOutputConfiguration() { _trt__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2597 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (1022)
/* trt:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (1022)
	virtual int soap_type(void) const { return 1022; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationResponse); }
	         _trt__GetAudioOutputConfigurationResponse() { _trt__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2600 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfiguration
#define SOAP_TYPE__trt__GetAudioDecoderConfiguration (1023)
/* trt:GetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfiguration (1023)
	virtual int soap_type(void) const { return 1023; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfiguration); }
	         _trt__GetAudioDecoderConfiguration() { _trt__GetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2603 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (1024)
/* trt:GetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationResponse
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (1024)
	virtual int soap_type(void) const { return 1024; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationResponse); }
	         _trt__GetAudioDecoderConfigurationResponse() { _trt__GetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2606 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (1025)
/* trt:GetCompatibleVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (1025)
	virtual int soap_type(void) const { return 1025; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurations); }
	         _trt__GetCompatibleVideoEncoderConfigurations() { _trt__GetCompatibleVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2609 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (1026)
/* trt:GetCompatibleVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoEncoderConfiguration */
	tt__VideoEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (1026)
	virtual int soap_type(void) const { return 1026; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurationsResponse); }
	         _trt__GetCompatibleVideoEncoderConfigurationsResponse() { _trt__GetCompatibleVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2612 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (1027)
/* trt:GetCompatibleVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (1027)
	virtual int soap_type(void) const { return 1027; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurations); }
	         _trt__GetCompatibleVideoSourceConfigurations() { _trt__GetCompatibleVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2615 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (1028)
/* trt:GetCompatibleVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoSourceConfiguration */
	tt__VideoSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (1028)
	virtual int soap_type(void) const { return 1028; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurationsResponse); }
	         _trt__GetCompatibleVideoSourceConfigurationsResponse() { _trt__GetCompatibleVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2618 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (1029)
/* trt:GetCompatibleAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (1029)
	virtual int soap_type(void) const { return 1029; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurations); }
	         _trt__GetCompatibleAudioEncoderConfigurations() { _trt__GetCompatibleAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2621 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (1030)
/* trt:GetCompatibleAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioEncoderConfiguration */
	tt__AudioEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (1030)
	virtual int soap_type(void) const { return 1030; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioEncoderConfigurationsResponse() { _trt__GetCompatibleAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2624 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (1031)
/* trt:GetCompatibleAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (1031)
	virtual int soap_type(void) const { return 1031; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurations); }
	         _trt__GetCompatibleAudioSourceConfigurations() { _trt__GetCompatibleAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2627 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (1032)
/* trt:GetCompatibleAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioSourceConfiguration */
	tt__AudioSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (1032)
	virtual int soap_type(void) const { return 1032; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurationsResponse); }
	         _trt__GetCompatibleAudioSourceConfigurationsResponse() { _trt__GetCompatibleAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2630 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (1033)
/* trt:GetCompatibleVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (1033)
	virtual int soap_type(void) const { return 1033; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurations); }
	         _trt__GetCompatibleVideoAnalyticsConfigurations() { _trt__GetCompatibleVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2633 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (1034)
/* trt:GetCompatibleVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoAnalyticsConfiguration */
	tt__VideoAnalyticsConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (1034)
	virtual int soap_type(void) const { return 1034; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse); }
	         _trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { _trt__GetCompatibleVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2636 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (1035)
/* trt:GetCompatibleMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (1035)
	virtual int soap_type(void) const { return 1035; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurations); }
	         _trt__GetCompatibleMetadataConfigurations() { _trt__GetCompatibleMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2639 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (1036)
/* trt:GetCompatibleMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:MetadataConfiguration */
	tt__MetadataConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (1036)
	virtual int soap_type(void) const { return 1036; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurationsResponse); }
	         _trt__GetCompatibleMetadataConfigurationsResponse() { _trt__GetCompatibleMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2642 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (1037)
/* trt:GetCompatibleAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (1037)
	virtual int soap_type(void) const { return 1037; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurations); }
	         _trt__GetCompatibleAudioOutputConfigurations() { _trt__GetCompatibleAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2645 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (1038)
/* trt:GetCompatibleAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioOutputConfiguration */
	tt__AudioOutputConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (1038)
	virtual int soap_type(void) const { return 1038; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurationsResponse); }
	         _trt__GetCompatibleAudioOutputConfigurationsResponse() { _trt__GetCompatibleAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2648 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (1039)
/* trt:GetCompatibleAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (1039)
	virtual int soap_type(void) const { return 1039; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurations); }
	         _trt__GetCompatibleAudioDecoderConfigurations() { _trt__GetCompatibleAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2651 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (1040)
/* trt:GetCompatibleAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioDecoderConfiguration */
	tt__AudioDecoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (1040)
	virtual int soap_type(void) const { return 1040; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioDecoderConfigurationsResponse() { _trt__GetCompatibleAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2654 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (1041)
/* trt:SetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfiguration
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* required element of XSD type tt:VideoEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfiguration (1041)
	virtual int soap_type(void) const { return 1041; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfiguration); }
	         _trt__SetVideoEncoderConfiguration() { _trt__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2657 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (1042)
/* trt:SetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (1042)
	virtual int soap_type(void) const { return 1042; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfigurationResponse); }
	         _trt__SetVideoEncoderConfigurationResponse() { _trt__SetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2660 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (1043)
/* trt:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfiguration (1043)
	virtual int soap_type(void) const { return 1043; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfiguration); }
	         _trt__SetVideoSourceConfiguration() { _trt__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2663 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (1044)
/* trt:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (1044)
	virtual int soap_type(void) const { return 1044; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfigurationResponse); }
	         _trt__SetVideoSourceConfigurationResponse() { _trt__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2666 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (1045)
/* trt:SetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfiguration
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* required element of XSD type tt:AudioEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfiguration (1045)
	virtual int soap_type(void) const { return 1045; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfiguration); }
	         _trt__SetAudioEncoderConfiguration() { _trt__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2669 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (1046)
/* trt:SetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (1046)
	virtual int soap_type(void) const { return 1046; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfigurationResponse); }
	         _trt__SetAudioEncoderConfigurationResponse() { _trt__SetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2672 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (1047)
/* trt:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfiguration (1047)
	virtual int soap_type(void) const { return 1047; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfiguration); }
	         _trt__SetAudioSourceConfiguration() { _trt__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2675 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (1048)
/* trt:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (1048)
	virtual int soap_type(void) const { return 1048; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfigurationResponse); }
	         _trt__SetAudioSourceConfigurationResponse() { _trt__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2678 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (1049)
/* trt:SetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (1049)
	virtual int soap_type(void) const { return 1049; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfiguration); }
	         _trt__SetVideoAnalyticsConfiguration() { _trt__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2681 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (1050)
/* trt:SetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (1050)
	virtual int soap_type(void) const { return 1050; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfigurationResponse); }
	         _trt__SetVideoAnalyticsConfigurationResponse() { _trt__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2684 */
#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (1051)
/* trt:SetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__SetMetadataConfiguration
{
public:
	tt__MetadataConfiguration *Configuration;	/* required element of XSD type tt:MetadataConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfiguration (1051)
	virtual int soap_type(void) const { return 1051; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfiguration); }
	         _trt__SetMetadataConfiguration() { _trt__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2687 */
#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (1052)
/* trt:SetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfigurationResponse (1052)
	virtual int soap_type(void) const { return 1052; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfigurationResponse); }
	         _trt__SetMetadataConfigurationResponse() { _trt__SetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2690 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfiguration
#define SOAP_TYPE__trt__SetAudioOutputConfiguration (1053)
/* trt:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfiguration (1053)
	virtual int soap_type(void) const { return 1053; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfiguration); }
	         _trt__SetAudioOutputConfiguration() { _trt__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2693 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (1054)
/* trt:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (1054)
	virtual int soap_type(void) const { return 1054; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfigurationResponse); }
	         _trt__SetAudioOutputConfigurationResponse() { _trt__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2696 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfiguration
#define SOAP_TYPE__trt__SetAudioDecoderConfiguration (1055)
/* trt:SetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfiguration
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* required element of XSD type tt:AudioDecoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfiguration (1055)
	virtual int soap_type(void) const { return 1055; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfiguration); }
	         _trt__SetAudioDecoderConfiguration() { _trt__SetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2699 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (1056)
/* trt:SetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (1056)
	virtual int soap_type(void) const { return 1056; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfigurationResponse); }
	         _trt__SetAudioDecoderConfigurationResponse() { _trt__SetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2702 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (1057)
/* trt:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (1057)
	virtual int soap_type(void) const { return 1057; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptions); }
	         _trt__GetVideoSourceConfigurationOptions() { _trt__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2705 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (1058)
/* trt:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (1058)
	virtual int soap_type(void) const { return 1058; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptionsResponse); }
	         _trt__GetVideoSourceConfigurationOptionsResponse() { _trt__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2708 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (1059)
/* trt:GetVideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (1059)
	virtual int soap_type(void) const { return 1059; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptions); }
	         _trt__GetVideoEncoderConfigurationOptions() { _trt__GetVideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2711 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (1060)
/* trt:GetVideoEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptionsResponse
{
public:
	tt__VideoEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (1060)
	virtual int soap_type(void) const { return 1060; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptionsResponse); }
	         _trt__GetVideoEncoderConfigurationOptionsResponse() { _trt__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2714 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (1061)
/* trt:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (1061)
	virtual int soap_type(void) const { return 1061; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptions); }
	         _trt__GetAudioSourceConfigurationOptions() { _trt__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2717 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (1062)
/* trt:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (1062)
	virtual int soap_type(void) const { return 1062; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptionsResponse); }
	         _trt__GetAudioSourceConfigurationOptionsResponse() { _trt__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2720 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (1063)
/* trt:GetAudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (1063)
	virtual int soap_type(void) const { return 1063; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptions); }
	         _trt__GetAudioEncoderConfigurationOptions() { _trt__GetAudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2723 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (1064)
/* trt:GetAudioEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptionsResponse
{
public:
	tt__AudioEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (1064)
	virtual int soap_type(void) const { return 1064; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptionsResponse); }
	         _trt__GetAudioEncoderConfigurationOptionsResponse() { _trt__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2726 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (1065)
/* trt:GetMetadataConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptions (1065)
	virtual int soap_type(void) const { return 1065; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptions); }
	         _trt__GetMetadataConfigurationOptions() { _trt__GetMetadataConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2729 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (1066)
/* trt:GetMetadataConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptionsResponse
{
public:
	tt__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (1066)
	virtual int soap_type(void) const { return 1066; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptionsResponse); }
	         _trt__GetMetadataConfigurationOptionsResponse() { _trt__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2732 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (1067)
/* trt:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (1067)
	virtual int soap_type(void) const { return 1067; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptions); }
	         _trt__GetAudioOutputConfigurationOptions() { _trt__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2735 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (1068)
/* trt:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (1068)
	virtual int soap_type(void) const { return 1068; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptionsResponse); }
	         _trt__GetAudioOutputConfigurationOptionsResponse() { _trt__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2738 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (1069)
/* trt:GetAudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (1069)
	virtual int soap_type(void) const { return 1069; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptions); }
	         _trt__GetAudioDecoderConfigurationOptions() { _trt__GetAudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2741 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (1070)
/* trt:GetAudioDecoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptionsResponse
{
public:
	tt__AudioDecoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (1070)
	virtual int soap_type(void) const { return 1070; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptionsResponse); }
	         _trt__GetAudioDecoderConfigurationOptionsResponse() { _trt__GetAudioDecoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2744 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (1071)
/* trt:GetGuaranteedNumberOfVideoEncoderInstances complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (1071)
	virtual int soap_type(void) const { return 1071; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstances, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstances); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstances() { _trt__GetGuaranteedNumberOfVideoEncoderInstances::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
	friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2747 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1072)
/* trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
{
public:
	int TotalNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:int */
	int *JPEG;	/* optional element of XSD type xsd:int */
	int *H264;	/* optional element of XSD type xsd:int */
	int *MPEG4;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1072)
	virtual int soap_type(void) const { return 1072; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
	friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2750 */
#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (1073)
/* trt:GetStreamUri complex type: */
class SOAP_CMAC _trt__GetStreamUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUri (1073)
	virtual int soap_type(void) const { return 1073; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUri, default initialized and not managed by a soap context
	virtual _trt__GetStreamUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUri); }
	         _trt__GetStreamUri() { _trt__GetStreamUri::soap_default(NULL); }
	virtual ~_trt__GetStreamUri() { }
	friend SOAP_FMAC1 _trt__GetStreamUri * SOAP_FMAC2 soap_instantiate__trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2753 */
#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (1074)
/* trt:GetStreamUriResponse complex type: */
class SOAP_CMAC _trt__GetStreamUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUriResponse (1074)
	virtual int soap_type(void) const { return 1074; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUriResponse); }
	         _trt__GetStreamUriResponse() { _trt__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_trt__GetStreamUriResponse() { }
	friend SOAP_FMAC1 _trt__GetStreamUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2756 */
#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (1075)
/* trt:StartMulticastStreaming complex type: */
class SOAP_CMAC _trt__StartMulticastStreaming
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreaming (1075)
	virtual int soap_type(void) const { return 1075; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreaming); }
	         _trt__StartMulticastStreaming() { _trt__StartMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreaming() { }
	friend SOAP_FMAC1 _trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2759 */
#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (1076)
/* trt:StartMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StartMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreamingResponse (1076)
	virtual int soap_type(void) const { return 1076; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreamingResponse); }
	         _trt__StartMulticastStreamingResponse() { _trt__StartMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreamingResponse() { }
	friend SOAP_FMAC1 _trt__StartMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2762 */
#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (1077)
/* trt:StopMulticastStreaming complex type: */
class SOAP_CMAC _trt__StopMulticastStreaming
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreaming (1077)
	virtual int soap_type(void) const { return 1077; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreaming); }
	         _trt__StopMulticastStreaming() { _trt__StopMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreaming() { }
	friend SOAP_FMAC1 _trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2765 */
#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (1078)
/* trt:StopMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StopMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreamingResponse (1078)
	virtual int soap_type(void) const { return 1078; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreamingResponse); }
	         _trt__StopMulticastStreamingResponse() { _trt__StopMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreamingResponse() { }
	friend SOAP_FMAC1 _trt__StopMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2768 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (1079)
/* trt:SetSynchronizationPoint complex type: */
class SOAP_CMAC _trt__SetSynchronizationPoint
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPoint (1079)
	virtual int soap_type(void) const { return 1079; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPoint, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPoint); }
	         _trt__SetSynchronizationPoint() { _trt__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPoint() { }
	friend SOAP_FMAC1 _trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2771 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (1080)
/* trt:SetSynchronizationPointResponse complex type: */
class SOAP_CMAC _trt__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPointResponse (1080)
	virtual int soap_type(void) const { return 1080; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPointResponse, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPointResponse); }
	         _trt__SetSynchronizationPointResponse() { _trt__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPointResponse() { }
	friend SOAP_FMAC1 _trt__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2774 */
#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (1081)
/* trt:GetSnapshotUri complex type: */
class SOAP_CMAC _trt__GetSnapshotUri
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUri (1081)
	virtual int soap_type(void) const { return 1081; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUri, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUri); }
	         _trt__GetSnapshotUri() { _trt__GetSnapshotUri::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUri() { }
	friend SOAP_FMAC1 _trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2777 */
#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (1082)
/* trt:GetSnapshotUriResponse complex type: */
class SOAP_CMAC _trt__GetSnapshotUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUriResponse (1082)
	virtual int soap_type(void) const { return 1082; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUriResponse); }
	         _trt__GetSnapshotUriResponse() { _trt__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUriResponse() { }
	friend SOAP_FMAC1 _trt__GetSnapshotUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2780 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModes
#define SOAP_TYPE__trt__GetVideoSourceModes (1083)
/* trt:GetVideoSourceModes complex type: */
class SOAP_CMAC _trt__GetVideoSourceModes
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceModes (1083)
	virtual int soap_type(void) const { return 1083; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceModes, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceModes *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceModes); }
	         _trt__GetVideoSourceModes() { _trt__GetVideoSourceModes::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceModes() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2783 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModesResponse
#define SOAP_TYPE__trt__GetVideoSourceModesResponse (1084)
/* trt:GetVideoSourceModesResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceModesResponse
{
public:
	int __sizeVideoSourceModes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <VideoSourceModes> of XSD type trt:VideoSourceMode */
	trt__VideoSourceMode **VideoSourceModes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceModesResponse (1084)
	virtual int soap_type(void) const { return 1084; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceModesResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceModesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceModesResponse); }
	         _trt__GetVideoSourceModesResponse() { _trt__GetVideoSourceModesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceModesResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceModesResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceModesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2786 */
#ifndef SOAP_TYPE__trt__SetVideoSourceMode
#define SOAP_TYPE__trt__SetVideoSourceMode (1085)
/* trt:SetVideoSourceMode complex type: */
class SOAP_CMAC _trt__SetVideoSourceMode
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	char *VideoSourceModeToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceMode (1085)
	virtual int soap_type(void) const { return 1085; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceMode, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceMode *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceMode); }
	         _trt__SetVideoSourceMode() { _trt__SetVideoSourceMode::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceMode() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2789 */
#ifndef SOAP_TYPE__trt__SetVideoSourceModeResponse
#define SOAP_TYPE__trt__SetVideoSourceModeResponse (1086)
/* trt:SetVideoSourceModeResponse complex type: */
class SOAP_CMAC _trt__SetVideoSourceModeResponse
{
public:
	bool Reboot;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceModeResponse (1086)
	virtual int soap_type(void) const { return 1086; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceModeResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceModeResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceModeResponse); }
	         _trt__SetVideoSourceModeResponse() { _trt__SetVideoSourceModeResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceModeResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceModeResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2792 */
#ifndef SOAP_TYPE__trt__GetOSDs
#define SOAP_TYPE__trt__GetOSDs (1087)
/* trt:GetOSDs complex type: */
class SOAP_CMAC _trt__GetOSDs
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDs (1087)
	virtual int soap_type(void) const { return 1087; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDs, default initialized and not managed by a soap context
	virtual _trt__GetOSDs *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDs); }
	         _trt__GetOSDs() { _trt__GetOSDs::soap_default(NULL); }
	virtual ~_trt__GetOSDs() { }
	friend SOAP_FMAC1 _trt__GetOSDs * SOAP_FMAC2 soap_instantiate__trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2795 */
#ifndef SOAP_TYPE__trt__GetOSDsResponse
#define SOAP_TYPE__trt__GetOSDsResponse (1088)
/* trt:GetOSDsResponse complex type: */
class SOAP_CMAC _trt__GetOSDsResponse
{
public:
	int __sizeOSDs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <OSDs> of XSD type tt:OSDConfiguration */
	tt__OSDConfiguration **OSDs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDsResponse (1088)
	virtual int soap_type(void) const { return 1088; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDsResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDsResponse); }
	         _trt__GetOSDsResponse() { _trt__GetOSDsResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDsResponse() { }
	friend SOAP_FMAC1 _trt__GetOSDsResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2798 */
#ifndef SOAP_TYPE__trt__GetOSD
#define SOAP_TYPE__trt__GetOSD (1089)
/* trt:GetOSD complex type: */
class SOAP_CMAC _trt__GetOSD
{
public:
	char *OSDToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSD (1089)
	virtual int soap_type(void) const { return 1089; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSD, default initialized and not managed by a soap context
	virtual _trt__GetOSD *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSD); }
	         _trt__GetOSD() { _trt__GetOSD::soap_default(NULL); }
	virtual ~_trt__GetOSD() { }
	friend SOAP_FMAC1 _trt__GetOSD * SOAP_FMAC2 soap_instantiate__trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2801 */
#ifndef SOAP_TYPE__trt__GetOSDResponse
#define SOAP_TYPE__trt__GetOSDResponse (1090)
/* trt:GetOSDResponse complex type: */
class SOAP_CMAC _trt__GetOSDResponse
{
public:
	tt__OSDConfiguration *OSD;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:OSDConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDResponse (1090)
	virtual int soap_type(void) const { return 1090; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDResponse); }
	         _trt__GetOSDResponse() { _trt__GetOSDResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDResponse() { }
	friend SOAP_FMAC1 _trt__GetOSDResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2804 */
#ifndef SOAP_TYPE__trt__SetOSD
#define SOAP_TYPE__trt__SetOSD (1091)
/* trt:SetOSD complex type: */
class SOAP_CMAC _trt__SetOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of XSD type tt:OSDConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetOSD (1091)
	virtual int soap_type(void) const { return 1091; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetOSD, default initialized and not managed by a soap context
	virtual _trt__SetOSD *soap_alloc(void) const { return SOAP_NEW(_trt__SetOSD); }
	         _trt__SetOSD() { _trt__SetOSD::soap_default(NULL); }
	virtual ~_trt__SetOSD() { }
	friend SOAP_FMAC1 _trt__SetOSD * SOAP_FMAC2 soap_instantiate__trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2807 */
#ifndef SOAP_TYPE__trt__SetOSDResponse
#define SOAP_TYPE__trt__SetOSDResponse (1092)
/* trt:SetOSDResponse complex type: */
class SOAP_CMAC _trt__SetOSDResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetOSDResponse (1092)
	virtual int soap_type(void) const { return 1092; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetOSDResponse, default initialized and not managed by a soap context
	virtual _trt__SetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetOSDResponse); }
	         _trt__SetOSDResponse() { _trt__SetOSDResponse::soap_default(NULL); }
	virtual ~_trt__SetOSDResponse() { }
	friend SOAP_FMAC1 _trt__SetOSDResponse * SOAP_FMAC2 soap_instantiate__trt__SetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2810 */
#ifndef SOAP_TYPE__trt__GetOSDOptions
#define SOAP_TYPE__trt__GetOSDOptions (1093)
/* trt:GetOSDOptions complex type: */
class SOAP_CMAC _trt__GetOSDOptions
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDOptions (1093)
	virtual int soap_type(void) const { return 1093; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDOptions, default initialized and not managed by a soap context
	virtual _trt__GetOSDOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDOptions); }
	         _trt__GetOSDOptions() { _trt__GetOSDOptions::soap_default(NULL); }
	virtual ~_trt__GetOSDOptions() { }
	friend SOAP_FMAC1 _trt__GetOSDOptions * SOAP_FMAC2 soap_instantiate__trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2813 */
#ifndef SOAP_TYPE__trt__GetOSDOptionsResponse
#define SOAP_TYPE__trt__GetOSDOptionsResponse (1094)
/* trt:GetOSDOptionsResponse complex type: */
class SOAP_CMAC _trt__GetOSDOptionsResponse
{
public:
	tt__OSDConfigurationOptions *OSDOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:OSDConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDOptionsResponse (1094)
	virtual int soap_type(void) const { return 1094; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDOptionsResponse); }
	         _trt__GetOSDOptionsResponse() { _trt__GetOSDOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetOSDOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2816 */
#ifndef SOAP_TYPE__trt__CreateOSD
#define SOAP_TYPE__trt__CreateOSD (1095)
/* trt:CreateOSD complex type: */
class SOAP_CMAC _trt__CreateOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of XSD type tt:OSDConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateOSD (1095)
	virtual int soap_type(void) const { return 1095; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateOSD, default initialized and not managed by a soap context
	virtual _trt__CreateOSD *soap_alloc(void) const { return SOAP_NEW(_trt__CreateOSD); }
	         _trt__CreateOSD() { _trt__CreateOSD::soap_default(NULL); }
	virtual ~_trt__CreateOSD() { }
	friend SOAP_FMAC1 _trt__CreateOSD * SOAP_FMAC2 soap_instantiate__trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2819 */
#ifndef SOAP_TYPE__trt__CreateOSDResponse
#define SOAP_TYPE__trt__CreateOSDResponse (1096)
/* trt:CreateOSDResponse complex type: */
class SOAP_CMAC _trt__CreateOSDResponse
{
public:
	char *OSDToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateOSDResponse (1096)
	virtual int soap_type(void) const { return 1096; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateOSDResponse, default initialized and not managed by a soap context
	virtual _trt__CreateOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__CreateOSDResponse); }
	         _trt__CreateOSDResponse() { _trt__CreateOSDResponse::soap_default(NULL); }
	virtual ~_trt__CreateOSDResponse() { }
	friend SOAP_FMAC1 _trt__CreateOSDResponse * SOAP_FMAC2 soap_instantiate__trt__CreateOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2822 */
#ifndef SOAP_TYPE__trt__DeleteOSD
#define SOAP_TYPE__trt__DeleteOSD (1097)
/* trt:DeleteOSD complex type: */
class SOAP_CMAC _trt__DeleteOSD
{
public:
	char *OSDToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteOSD (1097)
	virtual int soap_type(void) const { return 1097; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteOSD, default initialized and not managed by a soap context
	virtual _trt__DeleteOSD *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteOSD); }
	         _trt__DeleteOSD() { _trt__DeleteOSD::soap_default(NULL); }
	virtual ~_trt__DeleteOSD() { }
	friend SOAP_FMAC1 _trt__DeleteOSD * SOAP_FMAC2 soap_instantiate__trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2825 */
#ifndef SOAP_TYPE__trt__DeleteOSDResponse
#define SOAP_TYPE__trt__DeleteOSDResponse (1098)
/* trt:DeleteOSDResponse complex type: */
class SOAP_CMAC _trt__DeleteOSDResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteOSDResponse (1098)
	virtual int soap_type(void) const { return 1098; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteOSDResponse, default initialized and not managed by a soap context
	virtual _trt__DeleteOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteOSDResponse); }
	         _trt__DeleteOSDResponse() { _trt__DeleteOSDResponse::soap_default(NULL); }
	virtual ~_trt__DeleteOSDResponse() { }
	friend SOAP_FMAC1 _trt__DeleteOSDResponse * SOAP_FMAC2 soap_instantiate__trt__DeleteOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:245 */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (238)
/* Type tds__StorageConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:StorageConfiguration complex type: */
class SOAP_CMAC tds__StorageConfiguration : public tt__DeviceEntity
{
public:
	tds__StorageConfigurationData *Data;	/* required element of XSD type tds:StorageConfigurationData */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfiguration (238)
	virtual int soap_type(void) const { return 238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfiguration, default initialized and not managed by a soap context
	virtual tds__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfiguration); }
	         tds__StorageConfiguration() { tds__StorageConfiguration::soap_default(NULL); }
	virtual ~tds__StorageConfiguration() { }
	friend SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:815 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (428)
/* Type tt__VideoSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSource complex type: */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of XSD type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of XSD type tt:VideoSourceExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSource (428)
	virtual int soap_type(void) const { return 428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
	virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW(tt__VideoSource); }
	         tt__VideoSource() { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
	friend SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:824 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (431)
/* Type tt__AudioSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSource complex type: */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSource (431)
	virtual int soap_type(void) const { return 431; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
	virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW(tt__AudioSource); }
	         tt__AudioSource() { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
	friend SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:839 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (436)
/* Type tt__VideoSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfiguration complex type: */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of XSD type tt:IntRectangle */
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension */
	char *ViewMode;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfiguration (436)
	virtual int soap_type(void) const { return 436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfiguration); }
	         tt__VideoSourceConfiguration() { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
	friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:881 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (450)
/* Type tt__VideoEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfiguration complex type: */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	float Quality;	/* required element of XSD type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of XSD type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of XSD type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of XSD type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfiguration (450)
	virtual int soap_type(void) const { return 450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfiguration); }
	         tt__VideoEncoderConfiguration() { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:908 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (459)
/* Type tt__JpegOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions2 complex type: */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions2 (459)
	virtual int soap_type(void) const { return 459; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
	virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions2); }
	         tt__JpegOptions2() { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
	friend SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:914 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (461)
/* Type tt__Mpeg4Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options2 complex type: */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options2 (461)
	virtual int soap_type(void) const { return 461; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options2); }
	         tt__Mpeg4Options2() { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
	friend SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:920 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (463)
/* Type tt__H264Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options2 complex type: */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options2 (463)
	virtual int soap_type(void) const { return 463; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
	virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW(tt__H264Options2); }
	         tt__H264Options2() { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
	friend SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:923 */
#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (464)
/* Type tt__VideoEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoder2Configuration complex type: */
class SOAP_CMAC tt__VideoEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	char *Encoding;	/* required element of XSD type xsd:string */
	tt__VideoResolution2 *Resolution;	/* required element of XSD type tt:VideoResolution2 */
	tt__VideoRateControl2 *RateControl;	/* optional element of XSD type tt:VideoRateControl2 */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	float Quality;	/* required element of XSD type xsd:float */
	int *GovLength;	/* optional attribute of XSD type xsd:int */
	char *Profile;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2Configuration (464)
	virtual int soap_type(void) const { return 464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2Configuration); }
	         tt__VideoEncoder2Configuration() { tt__VideoEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__VideoEncoder2Configuration() { }
	friend SOAP_FMAC1 tt__VideoEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:935 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (468)
/* Type tt__AudioSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfiguration complex type: */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfiguration (468)
	virtual int soap_type(void) const { return 468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfiguration); }
	         tt__AudioSourceConfiguration() { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
	friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:944 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (471)
/* Type tt__AudioEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfiguration complex type: */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfiguration (471)
	virtual int soap_type(void) const { return 471; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfiguration); }
	         tt__AudioEncoderConfiguration() { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:953 */
#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (474)
/* Type tt__AudioEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoder2Configuration complex type: */
class SOAP_CMAC tt__AudioEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	char *Encoding;	/* required element of XSD type xsd:string */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2Configuration (474)
	virtual int soap_type(void) const { return 474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2Configuration); }
	         tt__AudioEncoder2Configuration() { tt__AudioEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__AudioEncoder2Configuration() { }
	friend SOAP_FMAC1 tt__AudioEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:959 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (476)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsConfiguration complex type: */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of XSD type tt:RuleEngineConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsConfiguration (476)
	virtual int soap_type(void) const { return 476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsConfiguration); }
	         tt__VideoAnalyticsConfiguration() { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:962 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (477)
/* Type tt__MetadataConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfiguration complex type: */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of XSD type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of XSD type tt:EventSubscription */
	bool *Analytics;	/* optional element of XSD type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of XSD type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationExtension */
	char *CompressionType;	/* optional attribute of XSD type xsd:string */
	bool *GeoLocation;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfiguration (477)
	virtual int soap_type(void) const { return 477; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
	virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfiguration); }
	         tt__MetadataConfiguration() { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
	friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:989 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (486)
/* Type tt__VideoOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutput complex type: */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of XSD type tt:VideoResolution */
	float *RefreshRate;	/* optional element of XSD type xsd:float */
	float *AspectRatio;	/* optional element of XSD type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of XSD type tt:VideoOutputExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutput (486)
	virtual int soap_type(void) const { return 486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
	virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutput); }
	         tt__VideoOutput() { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
	friend SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:995 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (488)
/* Type tt__VideoOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfiguration complex type: */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfiguration (488)
	virtual int soap_type(void) const { return 488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfiguration); }
	         tt__VideoOutputConfiguration() { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
	friend SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1016 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (495)
/* Type tt__AudioOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutput complex type: */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutput (495)
	virtual int soap_type(void) const { return 495; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
	virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutput); }
	         tt__AudioOutput() { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
	friend SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1019 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (496)
/* Type tt__AudioOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfiguration complex type: */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of XSD type tt:ReferenceToken */
	char *SendPrimacy;	/* optional element of XSD type xsd:anyURI */
	int OutputLevel;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfiguration (496)
	virtual int soap_type(void) const { return 496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfiguration); }
	         tt__AudioOutputConfiguration() { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
	friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1025 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (498)
/* Type tt__AudioDecoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfiguration complex type: */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfiguration (498)
	virtual int soap_type(void) const { return 498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfiguration); }
	         tt__AudioDecoderConfiguration() { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1058 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (509)
/* Type tt__NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterface complex type: */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of XSD type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of XSD type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterface (509)
	virtual int soap_type(void) const { return 509; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
	virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterface); }
	         tt__NetworkInterface() { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
	friend SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1370 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (613)
/* tt:CertificateUsage simple type: */
class SOAP_CMAC tt__CertificateUsage
{
public:
	char *__item;	/* mixed XML content */
	bool Critical;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateUsage (613)
	virtual int soap_type(void) const { return 613; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
	virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW(tt__CertificateUsage); }
	         tt__CertificateUsage() { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
	friend SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1397 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (622)
/* Type tt__RelayOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutput complex type: */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutput (622)
	virtual int soap_type(void) const { return 622; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
	virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutput); }
	         tt__RelayOutput() { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
	friend SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1400 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (623)
/* Type tt__DigitalInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DigitalInput complex type: */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	enum tt__DigitalIdleState *IdleState;	/* optional attribute of XSD type tt:DigitalIdleState */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DigitalInput (623)
	virtual int soap_type(void) const { return 623; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
	virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW(tt__DigitalInput); }
	         tt__DigitalInput() { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
	friend SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1403 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (624)
/* Type tt__PTZNode is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNode complex type: */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of XSD type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of XSD type xsd:int */
	bool HomeSupported;	/* required element of XSD type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> of XSD type tt:AuxiliaryData */
	char **AuxiliaryCommands;
	tt__PTZNodeExtension *Extension;	/* optional element of XSD type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute of XSD type xsd:boolean */
	bool *GeoMove;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNode (624)
	virtual int soap_type(void) const { return 624; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
	virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW(tt__PTZNode); }
	         tt__PTZNode() { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
	friend SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1418 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (629)
/* Type tt__PTZConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfiguration complex type: */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	char *NodeToken;	/* required element of XSD type tt:ReferenceToken */
	char *DefaultAbsolutePantTiltPositionSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultAbsoluteZoomPositionSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultRelativePanTiltTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultRelativeZoomTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultContinuousPanTiltVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultContinuousZoomVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of XSD type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of XSD type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of XSD type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension */
	int *MoveRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetTourRamp;	/* optional attribute of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfiguration (629)
	virtual int soap_type(void) const { return 629; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
	virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfiguration); }
	         tt__PTZConfiguration() { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
	friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1871 */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (780)
/* Type tt__EventFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventFilter complex type: */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventFilter (780)
	virtual int soap_type(void) const { return 780; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventFilter, default initialized and not managed by a soap context
	virtual tt__EventFilter *soap_alloc(void) const { return SOAP_NEW(tt__EventFilter); }
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
	friend SOAP_FMAC1 tt__EventFilter * SOAP_FMAC2 soap_instantiate_tt__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1979 */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (816)
/* Type tt__AnalyticsEngine is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngine complex type: */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsDeviceEngineConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngine (816)
	virtual int soap_type(void) const { return 816; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngine, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngine); }
	         tt__AnalyticsEngine() { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
	friend SOAP_FMAC1 tt__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1997 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (822)
/* Type tt__AnalyticsEngineInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInput complex type: */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of XSD type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of XSD type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of XSD type tt:MetadataInput */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInput (822)
	virtual int soap_type(void) const { return 822; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInput, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInput); }
	         tt__AnalyticsEngineInput() { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2012 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (827)
/* Type tt__AnalyticsEngineControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineControl complex type: */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	char *EngineToken;	/* required element of XSD type tt:ReferenceToken */
	char *EngineConfigToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeInputToken;	/* sequence of elements <InputToken> of XSD type tt:ReferenceToken */
	char **InputToken;
	int __sizeReceiverToken;	/* sequence of elements <ReceiverToken> of XSD type tt:ReferenceToken */
	char **ReceiverToken;
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of XSD type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of XSD type tt:ModeOfOperation */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineControl (827)
	virtual int soap_type(void) const { return 827; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineControl, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineControl); }
	         tt__AnalyticsEngineControl() { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2093 */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (854)
/* Type tt__OSDConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfiguration complex type: */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity
{
public:
	tt__OSDReference *VideoSourceConfigurationToken;	/* required element of XSD type tt:OSDReference */
	enum tt__OSDType Type;	/* required element of XSD type tt:OSDType */
	tt__OSDPosConfiguration *Position;	/* required element of XSD type tt:OSDPosConfiguration */
	tt__OSDTextConfiguration *TextString;	/* optional element of XSD type tt:OSDTextConfiguration */
	tt__OSDImgConfiguration *Image;	/* optional element of XSD type tt:OSDImgConfiguration */
	tt__OSDConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfiguration (854)
	virtual int soap_type(void) const { return 854; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfiguration); }
	         tt__OSDConfiguration() { tt__OSDConfiguration::soap_default(NULL); }
	virtual ~tt__OSDConfiguration() { }
	friend SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2192 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (887)
/* Type wsnt__SubscribeCreationFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscribeCreationFailedFaultType complex type: */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (887)
	virtual int soap_type(void) const { return 887; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscribeCreationFailedFaultType); }
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2195 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (888)
/* Type wsnt__InvalidFilterFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidFilterFaultType complex type: */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnknownFilter;	/* sequence of elements <UnknownFilter> of XSD type xsd:QName */
	char **UnknownFilter;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidFilterFaultType (888)
	virtual int soap_type(void) const { return 888; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidFilterFaultType); }
	         wsnt__InvalidFilterFaultType() { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2198 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (889)
/* Type wsnt__TopicExpressionDialectUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionDialectUnknownFaultType complex type: */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (889)
	virtual int soap_type(void) const { return 889; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionDialectUnknownFaultType); }
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2201 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (890)
/* Type wsnt__InvalidTopicExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidTopicExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (890)
	virtual int soap_type(void) const { return 890; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidTopicExpressionFaultType); }
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2204 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (891)
/* Type wsnt__TopicNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicNotSupportedFaultType (891)
	virtual int soap_type(void) const { return 891; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicNotSupportedFaultType); }
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2207 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (892)
/* Type wsnt__MultipleTopicsSpecifiedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:MultipleTopicsSpecifiedFaultType complex type: */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (892)
	virtual int soap_type(void) const { return 892; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
	virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__MultipleTopicsSpecifiedFaultType); }
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
	friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2210 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (893)
/* Type wsnt__InvalidProducerPropertiesExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidProducerPropertiesExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (893)
	virtual int soap_type(void) const { return 893; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidProducerPropertiesExpressionFaultType); }
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2213 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (894)
/* Type wsnt__InvalidMessageContentExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidMessageContentExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (894)
	virtual int soap_type(void) const { return 894; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidMessageContentExpressionFaultType); }
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2216 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (895)
/* Type wsnt__UnrecognizedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnrecognizedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnrecognizedPolicy;	/* sequence of elements <UnrecognizedPolicy> of XSD type xsd:QName */
	char **UnrecognizedPolicy;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (895)
	virtual int soap_type(void) const { return 895; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnrecognizedPolicyRequestFaultType); }
	         wsnt__UnrecognizedPolicyRequestFaultType() { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2219 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (896)
/* Type wsnt__UnsupportedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnsupportedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnsupportedPolicy;	/* sequence of elements <UnsupportedPolicy> of XSD type xsd:QName */
	char **UnsupportedPolicy;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (896)
	virtual int soap_type(void) const { return 896; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnsupportedPolicyRequestFaultType); }
	         wsnt__UnsupportedPolicyRequestFaultType() { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2222 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (897)
/* Type wsnt__NotifyMessageNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotifyMessageNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (897)
	virtual int soap_type(void) const { return 897; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotifyMessageNotSupportedFaultType); }
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2225 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (898)
/* Type wsnt__UnacceptableInitialTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableInitialTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (898)
	virtual int soap_type(void) const { return 898; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableInitialTerminationTimeFaultType); }
	         wsnt__UnacceptableInitialTerminationTimeFaultType() { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2228 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (899)
/* Type wsnt__NoCurrentMessageOnTopicFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NoCurrentMessageOnTopicFaultType complex type: */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (899)
	virtual int soap_type(void) const { return 899; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
	virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NoCurrentMessageOnTopicFaultType); }
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
	friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2231 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (900)
/* Type wsnt__UnableToGetMessagesFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToGetMessagesFaultType complex type: */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (900)
	virtual int soap_type(void) const { return 900; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToGetMessagesFaultType); }
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2234 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (901)
/* Type wsnt__UnableToDestroyPullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroyPullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (901)
	virtual int soap_type(void) const { return 901; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroyPullPointFaultType); }
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2237 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (902)
/* Type wsnt__UnableToCreatePullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToCreatePullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (902)
	virtual int soap_type(void) const { return 902; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToCreatePullPointFaultType); }
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2240 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (903)
/* Type wsnt__UnacceptableTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (903)
	virtual int soap_type(void) const { return 903; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableTerminationTimeFaultType); }
	         wsnt__UnacceptableTerminationTimeFaultType() { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2243 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (904)
/* Type wsnt__UnableToDestroySubscriptionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroySubscriptionFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (904)
	virtual int soap_type(void) const { return 904; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroySubscriptionFaultType); }
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2246 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (905)
/* Type wsnt__PauseFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:PauseFailedFaultType complex type: */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__PauseFailedFaultType (905)
	virtual int soap_type(void) const { return 905; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__PauseFailedFaultType); }
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2249 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (906)
/* Type wsnt__ResumeFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:ResumeFailedFaultType complex type: */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__ResumeFailedFaultType (906)
	virtual int soap_type(void) const { return 906; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__ResumeFailedFaultType); }
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32359 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1768)
/* wstop:TopicNamespaceType-Topic complex type: */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicType */
	wstop__TopicType **Topic;
	char *name;	/* required attribute of XSD type xsd:NCName */
	char **messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
	char *parent;	/* optional attribute of XSD type wstop:ConcreteTopicExpression */
public:
	/// Return the unique type ID value SOAP_TYPE__wstop__TopicNamespaceType_Topic (1768)
	virtual int soap_type(void) const { return 1768; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
	virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_wstop__TopicNamespaceType_Topic); }
	         _wstop__TopicNamespaceType_Topic() { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
	friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2330 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (933)
/* Type wstop__TopicNamespaceType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicNamespaceType complex type: */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicNamespaceType-Topic */
	_wstop__TopicNamespaceType_Topic *Topic;
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *targetNamespace;	/* required attribute of XSD type xsd:anyURI */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicNamespaceType (933)
	virtual int soap_type(void) const { return 933; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
	virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicNamespaceType); }
	         wstop__TopicNamespaceType() { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
	friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2333 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (934)
/* Type wstop__TopicType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicType complex type: */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicType */
	wstop__TopicType **Topic;
	char *name;	/* required attribute of XSD type xsd:NCName */
	char **messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicType (934)
	virtual int soap_type(void) const { return 934; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
	virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicType); }
	         wstop__TopicType() { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
	friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2336 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (935)
/* Type wstop__TopicSetType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicSetType complex type: */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicSetType (935)
	virtual int soap_type(void) const { return 935; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
	virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicSetType); }
	         wstop__TopicSetType() { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
	friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2045 */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (838)
/* tt:OSDReference simple type: */
class SOAP_CMAC tt__OSDReference
{
public:
	char *__item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDReference (838)
	virtual int soap_type(void) const { return 838; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDReference, default initialized and not managed by a soap context
	virtual tt__OSDReference *soap_alloc(void) const { return SOAP_NEW(tt__OSDReference); }
	         tt__OSDReference() { tt__OSDReference::soap_default(NULL); }
	virtual ~tt__OSDReference() { }
	friend SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33300 */
#ifndef SOAP_TYPE___tdn__Hello
#define SOAP_TYPE___tdn__Hello (1775)
/* Operation wrapper: */
struct __tdn__Hello
{
public:
	struct wsdd__HelloType tdn__Hello;	/* required element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 1775; } /* = unique type id SOAP_TYPE___tdn__Hello */
	         __tdn__Hello();
	friend SOAP_FMAC1 __tdn__Hello * SOAP_FMAC2 soap_instantiate___tdn__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33366 */
#ifndef SOAP_TYPE___tdn__Bye
#define SOAP_TYPE___tdn__Bye (1777)
/* Operation wrapper: */
struct __tdn__Bye
{
public:
	struct wsdd__ByeType tdn__Bye;	/* required element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 1777; } /* = unique type id SOAP_TYPE___tdn__Bye */
	         __tdn__Bye();
	friend SOAP_FMAC1 __tdn__Bye * SOAP_FMAC2 soap_instantiate___tdn__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33432 */
#ifndef SOAP_TYPE___tdn__Probe
#define SOAP_TYPE___tdn__Probe (1780)
/* Operation wrapper: */
struct __tdn__Probe
{
public:
	struct wsdd__ProbeType tdn__Probe;	/* required element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 1780; } /* = unique type id SOAP_TYPE___tdn__Probe */
	         __tdn__Probe();
	friend SOAP_FMAC1 __tdn__Probe * SOAP_FMAC2 soap_instantiate___tdn__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33517 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (1784)
/* Operation wrapper: */
struct __tds__GetServices
{
public:
	_tds__GetServices *tds__GetServices;	/* optional element of XSD type tds:GetServices */
public:
	int soap_type() const { return 1784; } /* = unique type id SOAP_TYPE___tds__GetServices */
	         __tds__GetServices();
	friend SOAP_FMAC1 __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33585 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (1788)
/* Operation wrapper: */
struct __tds__GetServiceCapabilities
{
public:
	_tds__GetServiceCapabilities *tds__GetServiceCapabilities;	/* optional element of XSD type tds:GetServiceCapabilities */
public:
	int soap_type() const { return 1788; } /* = unique type id SOAP_TYPE___tds__GetServiceCapabilities */
	         __tds__GetServiceCapabilities();
	friend SOAP_FMAC1 __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33652 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (1792)
/* Operation wrapper: */
struct __tds__GetDeviceInformation
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of XSD type tds:GetDeviceInformation */
public:
	int soap_type() const { return 1792; } /* = unique type id SOAP_TYPE___tds__GetDeviceInformation */
	         __tds__GetDeviceInformation();
	friend SOAP_FMAC1 __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33724 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (1796)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of XSD type tds:SetSystemDateAndTime */
public:
	int soap_type() const { return 1796; } /* = unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
	         __tds__SetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33796 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (1800)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of XSD type tds:GetSystemDateAndTime */
public:
	int soap_type() const { return 1800; } /* = unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
	         __tds__GetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33863 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (1804)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of XSD type tds:SetSystemFactoryDefault */
public:
	int soap_type() const { return 1804; } /* = unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
	         __tds__SetSystemFactoryDefault();
	friend SOAP_FMAC1 __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33936 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (1808)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of XSD type tds:UpgradeSystemFirmware */
public:
	int soap_type() const { return 1808; } /* = unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
	         __tds__UpgradeSystemFirmware();
	friend SOAP_FMAC1 __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34003 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (1812)
/* Operation wrapper: */
struct __tds__SystemReboot
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of XSD type tds:SystemReboot */
public:
	int soap_type() const { return 1812; } /* = unique type id SOAP_TYPE___tds__SystemReboot */
	         __tds__SystemReboot();
	friend SOAP_FMAC1 __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34078 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (1816)
/* Operation wrapper: */
struct __tds__RestoreSystem
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of XSD type tds:RestoreSystem */
public:
	int soap_type() const { return 1816; } /* = unique type id SOAP_TYPE___tds__RestoreSystem */
	         __tds__RestoreSystem();
	friend SOAP_FMAC1 __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34152 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (1820)
/* Operation wrapper: */
struct __tds__GetSystemBackup
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of XSD type tds:GetSystemBackup */
public:
	int soap_type() const { return 1820; } /* = unique type id SOAP_TYPE___tds__GetSystemBackup */
	         __tds__GetSystemBackup();
	friend SOAP_FMAC1 __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34220 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (1824)
/* Operation wrapper: */
struct __tds__GetSystemLog
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of XSD type tds:GetSystemLog */
public:
	int soap_type() const { return 1824; } /* = unique type id SOAP_TYPE___tds__GetSystemLog */
	         __tds__GetSystemLog();
	friend SOAP_FMAC1 __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34287 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (1828)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of XSD type tds:GetSystemSupportInformation */
public:
	int soap_type() const { return 1828; } /* = unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
	         __tds__GetSystemSupportInformation();
	friend SOAP_FMAC1 __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34358 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (1832)
/* Operation wrapper: */
struct __tds__GetScopes
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of XSD type tds:GetScopes */
public:
	int soap_type() const { return 1832; } /* = unique type id SOAP_TYPE___tds__GetScopes */
	         __tds__GetScopes();
	friend SOAP_FMAC1 __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34433 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (1836)
/* Operation wrapper: */
struct __tds__SetScopes
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of XSD type tds:SetScopes */
public:
	int soap_type() const { return 1836; } /* = unique type id SOAP_TYPE___tds__SetScopes */
	         __tds__SetScopes();
	friend SOAP_FMAC1 __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34504 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (1840)
/* Operation wrapper: */
struct __tds__AddScopes
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of XSD type tds:AddScopes */
public:
	int soap_type() const { return 1840; } /* = unique type id SOAP_TYPE___tds__AddScopes */
	         __tds__AddScopes();
	friend SOAP_FMAC1 __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34577 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (1844)
/* Operation wrapper: */
struct __tds__RemoveScopes
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of XSD type tds:RemoveScopes */
public:
	int soap_type() const { return 1844; } /* = unique type id SOAP_TYPE___tds__RemoveScopes */
	         __tds__RemoveScopes();
	friend SOAP_FMAC1 __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34648 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (1848)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of XSD type tds:GetDiscoveryMode */
public:
	int soap_type() const { return 1848; } /* = unique type id SOAP_TYPE___tds__GetDiscoveryMode */
	         __tds__GetDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34720 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (1852)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of XSD type tds:SetDiscoveryMode */
public:
	int soap_type() const { return 1852; } /* = unique type id SOAP_TYPE___tds__SetDiscoveryMode */
	         __tds__SetDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34793 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (1856)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of XSD type tds:GetRemoteDiscoveryMode */
public:
	int soap_type() const { return 1856; } /* = unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
	         __tds__GetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34866 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (1860)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of XSD type tds:SetRemoteDiscoveryMode */
public:
	int soap_type() const { return 1860; } /* = unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
	         __tds__SetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34937 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (1864)
/* Operation wrapper: */
struct __tds__GetDPAddresses
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of XSD type tds:GetDPAddresses */
public:
	int soap_type() const { return 1864; } /* = unique type id SOAP_TYPE___tds__GetDPAddresses */
	         __tds__GetDPAddresses();
	friend SOAP_FMAC1 __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35010 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (1868)
/* Operation wrapper: */
struct __tds__GetEndpointReference
{
public:
	_tds__GetEndpointReference *tds__GetEndpointReference;	/* optional element of XSD type tds:GetEndpointReference */
public:
	int soap_type() const { return 1868; } /* = unique type id SOAP_TYPE___tds__GetEndpointReference */
	         __tds__GetEndpointReference();
	friend SOAP_FMAC1 __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35081 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (1872)
/* Operation wrapper: */
struct __tds__GetRemoteUser
{
public:
	_tds__GetRemoteUser *tds__GetRemoteUser;	/* optional element of XSD type tds:GetRemoteUser */
public:
	int soap_type() const { return 1872; } /* = unique type id SOAP_TYPE___tds__GetRemoteUser */
	         __tds__GetRemoteUser();
	friend SOAP_FMAC1 __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35151 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (1876)
/* Operation wrapper: */
struct __tds__SetRemoteUser
{
public:
	_tds__SetRemoteUser *tds__SetRemoteUser;	/* optional element of XSD type tds:SetRemoteUser */
public:
	int soap_type() const { return 1876; } /* = unique type id SOAP_TYPE___tds__SetRemoteUser */
	         __tds__SetRemoteUser();
	friend SOAP_FMAC1 __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35222 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (1880)
/* Operation wrapper: */
struct __tds__GetUsers
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of XSD type tds:GetUsers */
public:
	int soap_type() const { return 1880; } /* = unique type id SOAP_TYPE___tds__GetUsers */
	         __tds__GetUsers();
	friend SOAP_FMAC1 __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35295 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (1884)
/* Operation wrapper: */
struct __tds__CreateUsers
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of XSD type tds:CreateUsers */
public:
	int soap_type() const { return 1884; } /* = unique type id SOAP_TYPE___tds__CreateUsers */
	         __tds__CreateUsers();
	friend SOAP_FMAC1 __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35369 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (1888)
/* Operation wrapper: */
struct __tds__DeleteUsers
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of XSD type tds:DeleteUsers */
public:
	int soap_type() const { return 1888; } /* = unique type id SOAP_TYPE___tds__DeleteUsers */
	         __tds__DeleteUsers();
	friend SOAP_FMAC1 __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35441 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (1892)
/* Operation wrapper: */
struct __tds__SetUser
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of XSD type tds:SetUser */
public:
	int soap_type() const { return 1892; } /* = unique type id SOAP_TYPE___tds__SetUser */
	         __tds__SetUser();
	friend SOAP_FMAC1 __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35515 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (1896)
/* Operation wrapper: */
struct __tds__GetWsdlUrl
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of XSD type tds:GetWsdlUrl */
public:
	int soap_type() const { return 1896; } /* = unique type id SOAP_TYPE___tds__GetWsdlUrl */
	         __tds__GetWsdlUrl();
	friend SOAP_FMAC1 __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35591 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (1900)
/* Operation wrapper: */
struct __tds__GetCapabilities
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of XSD type tds:GetCapabilities */
public:
	int soap_type() const { return 1900; } /* = unique type id SOAP_TYPE___tds__GetCapabilities */
	         __tds__GetCapabilities();
	friend SOAP_FMAC1 __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35663 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (1904)
/* Operation wrapper: */
struct __tds__SetDPAddresses
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of XSD type tds:SetDPAddresses */
public:
	int soap_type() const { return 1904; } /* = unique type id SOAP_TYPE___tds__SetDPAddresses */
	         __tds__SetDPAddresses();
	friend SOAP_FMAC1 __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35733 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (1908)
/* Operation wrapper: */
struct __tds__GetHostname
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of XSD type tds:GetHostname */
public:
	int soap_type() const { return 1908; } /* = unique type id SOAP_TYPE___tds__GetHostname */
	         __tds__GetHostname();
	friend SOAP_FMAC1 __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35802 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (1912)
/* Operation wrapper: */
struct __tds__SetHostname
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of XSD type tds:SetHostname */
public:
	int soap_type() const { return 1912; } /* = unique type id SOAP_TYPE___tds__SetHostname */
	         __tds__SetHostname();
	friend SOAP_FMAC1 __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35869 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (1916)
/* Operation wrapper: */
struct __tds__SetHostnameFromDHCP
{
public:
	_tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;	/* optional element of XSD type tds:SetHostnameFromDHCP */
public:
	int soap_type() const { return 1916; } /* = unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
	         __tds__SetHostnameFromDHCP();
	friend SOAP_FMAC1 __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35938 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (1920)
/* Operation wrapper: */
struct __tds__GetDNS
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of XSD type tds:GetDNS */
public:
	int soap_type() const { return 1920; } /* = unique type id SOAP_TYPE___tds__GetDNS */
	         __tds__GetDNS();
	friend SOAP_FMAC1 __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36007 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (1924)
/* Operation wrapper: */
struct __tds__SetDNS
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of XSD type tds:SetDNS */
public:
	int soap_type() const { return 1924; } /* = unique type id SOAP_TYPE___tds__SetDNS */
	         __tds__SetDNS();
	friend SOAP_FMAC1 __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36077 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (1928)
/* Operation wrapper: */
struct __tds__GetNTP
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of XSD type tds:GetNTP */
public:
	int soap_type() const { return 1928; } /* = unique type id SOAP_TYPE___tds__GetNTP */
	         __tds__GetNTP();
	friend SOAP_FMAC1 __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36147 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (1932)
/* Operation wrapper: */
struct __tds__SetNTP
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of XSD type tds:SetNTP */
public:
	int soap_type() const { return 1932; } /* = unique type id SOAP_TYPE___tds__SetNTP */
	         __tds__SetNTP();
	friend SOAP_FMAC1 __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36218 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (1936)
/* Operation wrapper: */
struct __tds__GetDynamicDNS
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of XSD type tds:GetDynamicDNS */
public:
	int soap_type() const { return 1936; } /* = unique type id SOAP_TYPE___tds__GetDynamicDNS */
	         __tds__GetDynamicDNS();
	friend SOAP_FMAC1 __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36289 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (1940)
/* Operation wrapper: */
struct __tds__SetDynamicDNS
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of XSD type tds:SetDynamicDNS */
public:
	int soap_type() const { return 1940; } /* = unique type id SOAP_TYPE___tds__SetDynamicDNS */
	         __tds__SetDynamicDNS();
	friend SOAP_FMAC1 __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36360 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (1944)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of XSD type tds:GetNetworkInterfaces */
public:
	int soap_type() const { return 1944; } /* = unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
	         __tds__GetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36431 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (1948)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of XSD type tds:SetNetworkInterfaces */
public:
	int soap_type() const { return 1948; } /* = unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
	         __tds__SetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36501 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (1952)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of XSD type tds:GetNetworkProtocols */
public:
	int soap_type() const { return 1952; } /* = unique type id SOAP_TYPE___tds__GetNetworkProtocols */
	         __tds__GetNetworkProtocols();
	friend SOAP_FMAC1 __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36571 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (1956)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of XSD type tds:SetNetworkProtocols */
public:
	int soap_type() const { return 1956; } /* = unique type id SOAP_TYPE___tds__SetNetworkProtocols */
	         __tds__SetNetworkProtocols();
	friend SOAP_FMAC1 __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36641 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (1960)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of XSD type tds:GetNetworkDefaultGateway */
public:
	int soap_type() const { return 1960; } /* = unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
	         __tds__GetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36710 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (1964)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of XSD type tds:SetNetworkDefaultGateway */
public:
	int soap_type() const { return 1964; } /* = unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
	         __tds__SetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36782 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (1968)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of XSD type tds:GetZeroConfiguration */
public:
	int soap_type() const { return 1968; } /* = unique type id SOAP_TYPE___tds__GetZeroConfiguration */
	         __tds__GetZeroConfiguration();
	friend SOAP_FMAC1 __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36850 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (1972)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of XSD type tds:SetZeroConfiguration */
public:
	int soap_type() const { return 1972; } /* = unique type id SOAP_TYPE___tds__SetZeroConfiguration */
	         __tds__SetZeroConfiguration();
	friend SOAP_FMAC1 __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36921 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (1976)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of XSD type tds:GetIPAddressFilter */
public:
	int soap_type() const { return 1976; } /* = unique type id SOAP_TYPE___tds__GetIPAddressFilter */
	         __tds__GetIPAddressFilter();
	friend SOAP_FMAC1 __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36994 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (1980)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of XSD type tds:SetIPAddressFilter */
public:
	int soap_type() const { return 1980; } /* = unique type id SOAP_TYPE___tds__SetIPAddressFilter */
	         __tds__SetIPAddressFilter();
	friend SOAP_FMAC1 __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37066 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (1984)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of XSD type tds:AddIPAddressFilter */
public:
	int soap_type() const { return 1984; } /* = unique type id SOAP_TYPE___tds__AddIPAddressFilter */
	         __tds__AddIPAddressFilter();
	friend SOAP_FMAC1 __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37138 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (1988)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of XSD type tds:RemoveIPAddressFilter */
public:
	int soap_type() const { return 1988; } /* = unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
	         __tds__RemoveIPAddressFilter();
	friend SOAP_FMAC1 __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37219 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (1992)
/* Operation wrapper: */
struct __tds__GetAccessPolicy
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of XSD type tds:GetAccessPolicy */
public:
	int soap_type() const { return 1992; } /* = unique type id SOAP_TYPE___tds__GetAccessPolicy */
	         __tds__GetAccessPolicy();
	friend SOAP_FMAC1 __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37291 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (1996)
/* Operation wrapper: */
struct __tds__SetAccessPolicy
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of XSD type tds:SetAccessPolicy */
public:
	int soap_type() const { return 1996; } /* = unique type id SOAP_TYPE___tds__SetAccessPolicy */
	         __tds__SetAccessPolicy();
	friend SOAP_FMAC1 __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37362 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (2000)
/* Operation wrapper: */
struct __tds__CreateCertificate
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of XSD type tds:CreateCertificate */
public:
	int soap_type() const { return 2000; } /* = unique type id SOAP_TYPE___tds__CreateCertificate */
	         __tds__CreateCertificate();
	friend SOAP_FMAC1 __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37441 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (2004)
/* Operation wrapper: */
struct __tds__GetCertificates
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of XSD type tds:GetCertificates */
public:
	int soap_type() const { return 2004; } /* = unique type id SOAP_TYPE___tds__GetCertificates */
	         __tds__GetCertificates();
	friend SOAP_FMAC1 __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37511 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (2008)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of XSD type tds:GetCertificatesStatus */
public:
	int soap_type() const { return 2008; } /* = unique type id SOAP_TYPE___tds__GetCertificatesStatus */
	         __tds__GetCertificatesStatus();
	friend SOAP_FMAC1 __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37583 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (2012)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of XSD type tds:SetCertificatesStatus */
public:
	int soap_type() const { return 2012; } /* = unique type id SOAP_TYPE___tds__SetCertificatesStatus */
	         __tds__SetCertificatesStatus();
	friend SOAP_FMAC1 __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37658 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (2016)
/* Operation wrapper: */
struct __tds__DeleteCertificates
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of XSD type tds:DeleteCertificates */
public:
	int soap_type() const { return 2016; } /* = unique type id SOAP_TYPE___tds__DeleteCertificates */
	         __tds__DeleteCertificates();
	friend SOAP_FMAC1 __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37735 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (2020)
/* Operation wrapper: */
struct __tds__GetPkcs10Request
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of XSD type tds:GetPkcs10Request */
public:
	int soap_type() const { return 2020; } /* = unique type id SOAP_TYPE___tds__GetPkcs10Request */
	         __tds__GetPkcs10Request();
	friend SOAP_FMAC1 __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37816 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (2024)
/* Operation wrapper: */
struct __tds__LoadCertificates
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of XSD type tds:LoadCertificates */
public:
	int soap_type() const { return 2024; } /* = unique type id SOAP_TYPE___tds__LoadCertificates */
	         __tds__LoadCertificates();
	friend SOAP_FMAC1 __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37886 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (2028)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of XSD type tds:GetClientCertificateMode */
public:
	int soap_type() const { return 2028; } /* = unique type id SOAP_TYPE___tds__GetClientCertificateMode */
	         __tds__GetClientCertificateMode();
	friend SOAP_FMAC1 __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37956 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (2032)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of XSD type tds:SetClientCertificateMode */
public:
	int soap_type() const { return 2032; } /* = unique type id SOAP_TYPE___tds__SetClientCertificateMode */
	         __tds__SetClientCertificateMode();
	friend SOAP_FMAC1 __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38023 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (2036)
/* Operation wrapper: */
struct __tds__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 2036; } /* = unique type id SOAP_TYPE___tds__GetRelayOutputs */
	         __tds__GetRelayOutputs();
	friend SOAP_FMAC1 __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38091 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (2040)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of XSD type tds:SetRelayOutputSettings */
public:
	int soap_type() const { return 2040; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
	         __tds__SetRelayOutputSettings();
	friend SOAP_FMAC1 __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38159 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (2044)
/* Operation wrapper: */
struct __tds__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 2044; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputState */
	         __tds__SetRelayOutputState();
	friend SOAP_FMAC1 __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38229 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (2048)
/* Operation wrapper: */
struct __tds__SendAuxiliaryCommand
{
public:
	_tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;	/* optional element of XSD type tds:SendAuxiliaryCommand */
public:
	int soap_type() const { return 2048; } /* = unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
	         __tds__SendAuxiliaryCommand();
	friend SOAP_FMAC1 __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38307 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (2052)
/* Operation wrapper: */
struct __tds__GetCACertificates
{
public:
	_tds__GetCACertificates *tds__GetCACertificates;	/* optional element of XSD type tds:GetCACertificates */
public:
	int soap_type() const { return 2052; } /* = unique type id SOAP_TYPE___tds__GetCACertificates */
	         __tds__GetCACertificates();
	friend SOAP_FMAC1 __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38384 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (2056)
/* Operation wrapper: */
struct __tds__LoadCertificateWithPrivateKey
{
public:
	_tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;	/* optional element of XSD type tds:LoadCertificateWithPrivateKey */
public:
	int soap_type() const { return 2056; } /* = unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
	         __tds__LoadCertificateWithPrivateKey();
	friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38459 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (2060)
/* Operation wrapper: */
struct __tds__GetCertificateInformation
{
public:
	_tds__GetCertificateInformation *tds__GetCertificateInformation;	/* optional element of XSD type tds:GetCertificateInformation */
public:
	int soap_type() const { return 2060; } /* = unique type id SOAP_TYPE___tds__GetCertificateInformation */
	         __tds__GetCertificateInformation();
	friend SOAP_FMAC1 __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38531 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (2064)
/* Operation wrapper: */
struct __tds__LoadCACertificates
{
public:
	_tds__LoadCACertificates *tds__LoadCACertificates;	/* optional element of XSD type tds:LoadCACertificates */
public:
	int soap_type() const { return 2064; } /* = unique type id SOAP_TYPE___tds__LoadCACertificates */
	         __tds__LoadCACertificates();
	friend SOAP_FMAC1 __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38606 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (2068)
/* Operation wrapper: */
struct __tds__CreateDot1XConfiguration
{
public:
	_tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;	/* optional element of XSD type tds:CreateDot1XConfiguration */
public:
	int soap_type() const { return 2068; } /* = unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
	         __tds__CreateDot1XConfiguration();
	friend SOAP_FMAC1 __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38677 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (2072)
/* Operation wrapper: */
struct __tds__SetDot1XConfiguration
{
public:
	_tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;	/* optional element of XSD type tds:SetDot1XConfiguration */
public:
	int soap_type() const { return 2072; } /* = unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
	         __tds__SetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38746 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (2076)
/* Operation wrapper: */
struct __tds__GetDot1XConfiguration
{
public:
	_tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;	/* optional element of XSD type tds:GetDot1XConfiguration */
public:
	int soap_type() const { return 2076; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
	         __tds__GetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38818 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (2080)
/* Operation wrapper: */
struct __tds__GetDot1XConfigurations
{
public:
	_tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;	/* optional element of XSD type tds:GetDot1XConfigurations */
public:
	int soap_type() const { return 2080; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
	         __tds__GetDot1XConfigurations();
	friend SOAP_FMAC1 __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38890 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (2084)
/* Operation wrapper: */
struct __tds__DeleteDot1XConfiguration
{
public:
	_tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;	/* optional element of XSD type tds:DeleteDot1XConfiguration */
public:
	int soap_type() const { return 2084; } /* = unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
	         __tds__DeleteDot1XConfiguration();
	friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38958 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (2088)
/* Operation wrapper: */
struct __tds__GetDot11Capabilities
{
public:
	_tds__GetDot11Capabilities *tds__GetDot11Capabilities;	/* optional element of XSD type tds:GetDot11Capabilities */
public:
	int soap_type() const { return 2088; } /* = unique type id SOAP_TYPE___tds__GetDot11Capabilities */
	         __tds__GetDot11Capabilities();
	friend SOAP_FMAC1 __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39027 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (2092)
/* Operation wrapper: */
struct __tds__GetDot11Status
{
public:
	_tds__GetDot11Status *tds__GetDot11Status;	/* optional element of XSD type tds:GetDot11Status */
public:
	int soap_type() const { return 2092; } /* = unique type id SOAP_TYPE___tds__GetDot11Status */
	         __tds__GetDot11Status();
	friend SOAP_FMAC1 __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39096 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (2096)
/* Operation wrapper: */
struct __tds__ScanAvailableDot11Networks
{
public:
	_tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;	/* optional element of XSD type tds:ScanAvailableDot11Networks */
public:
	int soap_type() const { return 2096; } /* = unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
	         __tds__ScanAvailableDot11Networks();
	friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39165 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (2100)
/* Operation wrapper: */
struct __tds__GetSystemUris
{
public:
	_tds__GetSystemUris *tds__GetSystemUris;	/* optional element of XSD type tds:GetSystemUris */
public:
	int soap_type() const { return 2100; } /* = unique type id SOAP_TYPE___tds__GetSystemUris */
	         __tds__GetSystemUris();
	friend SOAP_FMAC1 __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39242 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (2104)
/* Operation wrapper: */
struct __tds__StartFirmwareUpgrade
{
public:
	_tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;	/* optional element of XSD type tds:StartFirmwareUpgrade */
public:
	int soap_type() const { return 2104; } /* = unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
	         __tds__StartFirmwareUpgrade();
	friend SOAP_FMAC1 __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39319 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (2108)
/* Operation wrapper: */
struct __tds__StartSystemRestore
{
public:
	_tds__StartSystemRestore *tds__StartSystemRestore;	/* optional element of XSD type tds:StartSystemRestore */
public:
	int soap_type() const { return 2108; } /* = unique type id SOAP_TYPE___tds__StartSystemRestore */
	         __tds__StartSystemRestore();
	friend SOAP_FMAC1 __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39389 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations
#define SOAP_TYPE___tds__GetStorageConfigurations (2112)
/* Operation wrapper: */
struct __tds__GetStorageConfigurations
{
public:
	_tds__GetStorageConfigurations *tds__GetStorageConfigurations;	/* optional element of XSD type tds:GetStorageConfigurations */
public:
	int soap_type() const { return 2112; } /* = unique type id SOAP_TYPE___tds__GetStorageConfigurations */
	         __tds__GetStorageConfigurations();
	friend SOAP_FMAC1 __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39460 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration
#define SOAP_TYPE___tds__CreateStorageConfiguration (2116)
/* Operation wrapper: */
struct __tds__CreateStorageConfiguration
{
public:
	_tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;	/* optional element of XSD type tds:CreateStorageConfiguration */
public:
	int soap_type() const { return 2116; } /* = unique type id SOAP_TYPE___tds__CreateStorageConfiguration */
	         __tds__CreateStorageConfiguration();
	friend SOAP_FMAC1 __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39530 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration
#define SOAP_TYPE___tds__GetStorageConfiguration (2120)
/* Operation wrapper: */
struct __tds__GetStorageConfiguration
{
public:
	_tds__GetStorageConfiguration *tds__GetStorageConfiguration;	/* optional element of XSD type tds:GetStorageConfiguration */
public:
	int soap_type() const { return 2120; } /* = unique type id SOAP_TYPE___tds__GetStorageConfiguration */
	         __tds__GetStorageConfiguration();
	friend SOAP_FMAC1 __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39599 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration
#define SOAP_TYPE___tds__SetStorageConfiguration (2124)
/* Operation wrapper: */
struct __tds__SetStorageConfiguration
{
public:
	_tds__SetStorageConfiguration *tds__SetStorageConfiguration;	/* optional element of XSD type tds:SetStorageConfiguration */
public:
	int soap_type() const { return 2124; } /* = unique type id SOAP_TYPE___tds__SetStorageConfiguration */
	         __tds__SetStorageConfiguration();
	friend SOAP_FMAC1 __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39669 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration
#define SOAP_TYPE___tds__DeleteStorageConfiguration (2128)
/* Operation wrapper: */
struct __tds__DeleteStorageConfiguration
{
public:
	_tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;	/* optional element of XSD type tds:DeleteStorageConfiguration */
public:
	int soap_type() const { return 2128; } /* = unique type id SOAP_TYPE___tds__DeleteStorageConfiguration */
	         __tds__DeleteStorageConfiguration();
	friend SOAP_FMAC1 __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39739 */
#ifndef SOAP_TYPE___tds__GetGeoLocation
#define SOAP_TYPE___tds__GetGeoLocation (2132)
/* Operation wrapper: */
struct __tds__GetGeoLocation
{
public:
	_tds__GetGeoLocation *tds__GetGeoLocation;	/* optional element of XSD type tds:GetGeoLocation */
public:
	int soap_type() const { return 2132; } /* = unique type id SOAP_TYPE___tds__GetGeoLocation */
	         __tds__GetGeoLocation();
	friend SOAP_FMAC1 __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39809 */
#ifndef SOAP_TYPE___tds__SetGeoLocation
#define SOAP_TYPE___tds__SetGeoLocation (2136)
/* Operation wrapper: */
struct __tds__SetGeoLocation
{
public:
	_tds__SetGeoLocation *tds__SetGeoLocation;	/* optional element of XSD type tds:SetGeoLocation */
public:
	int soap_type() const { return 2136; } /* = unique type id SOAP_TYPE___tds__SetGeoLocation */
	         __tds__SetGeoLocation();
	friend SOAP_FMAC1 __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39878 */
#ifndef SOAP_TYPE___tds__DeleteGeoLocation
#define SOAP_TYPE___tds__DeleteGeoLocation (2140)
/* Operation wrapper: */
struct __tds__DeleteGeoLocation
{
public:
	_tds__DeleteGeoLocation *tds__DeleteGeoLocation;	/* optional element of XSD type tds:DeleteGeoLocation */
public:
	int soap_type() const { return 2140; } /* = unique type id SOAP_TYPE___tds__DeleteGeoLocation */
	         __tds__DeleteGeoLocation();
	friend SOAP_FMAC1 __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39964 */
#ifndef SOAP_TYPE___trt__GetServiceCapabilities
#define SOAP_TYPE___trt__GetServiceCapabilities (2144)
/* Operation wrapper: */
struct __trt__GetServiceCapabilities
{
public:
	_trt__GetServiceCapabilities *trt__GetServiceCapabilities;	/* optional element of XSD type trt:GetServiceCapabilities */
public:
	int soap_type() const { return 2144; } /* = unique type id SOAP_TYPE___trt__GetServiceCapabilities */
	         __trt__GetServiceCapabilities();
	friend SOAP_FMAC1 __trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40031 */
#ifndef SOAP_TYPE___trt__GetVideoSources
#define SOAP_TYPE___trt__GetVideoSources (2148)
/* Operation wrapper: */
struct __trt__GetVideoSources
{
public:
	_trt__GetVideoSources *trt__GetVideoSources;	/* optional element of XSD type trt:GetVideoSources */
public:
	int soap_type() const { return 2148; } /* = unique type id SOAP_TYPE___trt__GetVideoSources */
	         __trt__GetVideoSources();
	friend SOAP_FMAC1 __trt__GetVideoSources * SOAP_FMAC2 soap_instantiate___trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40098 */
#ifndef SOAP_TYPE___trt__GetAudioSources
#define SOAP_TYPE___trt__GetAudioSources (2152)
/* Operation wrapper: */
struct __trt__GetAudioSources
{
public:
	_trt__GetAudioSources *trt__GetAudioSources;	/* optional element of XSD type trt:GetAudioSources */
public:
	int soap_type() const { return 2152; } /* = unique type id SOAP_TYPE___trt__GetAudioSources */
	         __trt__GetAudioSources();
	friend SOAP_FMAC1 __trt__GetAudioSources * SOAP_FMAC2 soap_instantiate___trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40165 */
#ifndef SOAP_TYPE___trt__GetAudioOutputs
#define SOAP_TYPE___trt__GetAudioOutputs (2156)
/* Operation wrapper: */
struct __trt__GetAudioOutputs
{
public:
	_trt__GetAudioOutputs *trt__GetAudioOutputs;	/* optional element of XSD type trt:GetAudioOutputs */
public:
	int soap_type() const { return 2156; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputs */
	         __trt__GetAudioOutputs();
	friend SOAP_FMAC1 __trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40236 */
#ifndef SOAP_TYPE___trt__CreateProfile
#define SOAP_TYPE___trt__CreateProfile (2160)
/* Operation wrapper: */
struct __trt__CreateProfile
{
public:
	_trt__CreateProfile *trt__CreateProfile;	/* optional element of XSD type trt:CreateProfile */
public:
	int soap_type() const { return 2160; } /* = unique type id SOAP_TYPE___trt__CreateProfile */
	         __trt__CreateProfile();
	friend SOAP_FMAC1 __trt__CreateProfile * SOAP_FMAC2 soap_instantiate___trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40304 */
#ifndef SOAP_TYPE___trt__GetProfile
#define SOAP_TYPE___trt__GetProfile (2164)
/* Operation wrapper: */
struct __trt__GetProfile
{
public:
	_trt__GetProfile *trt__GetProfile;	/* optional element of XSD type trt:GetProfile */
public:
	int soap_type() const { return 2164; } /* = unique type id SOAP_TYPE___trt__GetProfile */
	         __trt__GetProfile();
	friend SOAP_FMAC1 __trt__GetProfile * SOAP_FMAC2 soap_instantiate___trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40376 */
#ifndef SOAP_TYPE___trt__GetProfiles
#define SOAP_TYPE___trt__GetProfiles (2168)
/* Operation wrapper: */
struct __trt__GetProfiles
{
public:
	_trt__GetProfiles *trt__GetProfiles;	/* optional element of XSD type trt:GetProfiles */
public:
	int soap_type() const { return 2168; } /* = unique type id SOAP_TYPE___trt__GetProfiles */
	         __trt__GetProfiles();
	friend SOAP_FMAC1 __trt__GetProfiles * SOAP_FMAC2 soap_instantiate___trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40450 */
#ifndef SOAP_TYPE___trt__AddVideoEncoderConfiguration
#define SOAP_TYPE___trt__AddVideoEncoderConfiguration (2172)
/* Operation wrapper: */
struct __trt__AddVideoEncoderConfiguration
{
public:
	_trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration;	/* optional element of XSD type trt:AddVideoEncoderConfiguration */
public:
	int soap_type() const { return 2172; } /* = unique type id SOAP_TYPE___trt__AddVideoEncoderConfiguration */
	         __trt__AddVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40520 */
#ifndef SOAP_TYPE___trt__AddVideoSourceConfiguration
#define SOAP_TYPE___trt__AddVideoSourceConfiguration (2176)
/* Operation wrapper: */
struct __trt__AddVideoSourceConfiguration
{
public:
	_trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration;	/* optional element of XSD type trt:AddVideoSourceConfiguration */
public:
	int soap_type() const { return 2176; } /* = unique type id SOAP_TYPE___trt__AddVideoSourceConfiguration */
	         __trt__AddVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40594 */
#ifndef SOAP_TYPE___trt__AddAudioEncoderConfiguration
#define SOAP_TYPE___trt__AddAudioEncoderConfiguration (2180)
/* Operation wrapper: */
struct __trt__AddAudioEncoderConfiguration
{
public:
	_trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration;	/* optional element of XSD type trt:AddAudioEncoderConfiguration */
public:
	int soap_type() const { return 2180; } /* = unique type id SOAP_TYPE___trt__AddAudioEncoderConfiguration */
	         __trt__AddAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40664 */
#ifndef SOAP_TYPE___trt__AddAudioSourceConfiguration
#define SOAP_TYPE___trt__AddAudioSourceConfiguration (2184)
/* Operation wrapper: */
struct __trt__AddAudioSourceConfiguration
{
public:
	_trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration;	/* optional element of XSD type trt:AddAudioSourceConfiguration */
public:
	int soap_type() const { return 2184; } /* = unique type id SOAP_TYPE___trt__AddAudioSourceConfiguration */
	         __trt__AddAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40738 */
#ifndef SOAP_TYPE___trt__AddPTZConfiguration
#define SOAP_TYPE___trt__AddPTZConfiguration (2188)
/* Operation wrapper: */
struct __trt__AddPTZConfiguration
{
public:
	_trt__AddPTZConfiguration *trt__AddPTZConfiguration;	/* optional element of XSD type trt:AddPTZConfiguration */
public:
	int soap_type() const { return 2188; } /* = unique type id SOAP_TYPE___trt__AddPTZConfiguration */
	         __trt__AddPTZConfiguration();
	friend SOAP_FMAC1 __trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40815 */
#ifndef SOAP_TYPE___trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__AddVideoAnalyticsConfiguration (2192)
/* Operation wrapper: */
struct __trt__AddVideoAnalyticsConfiguration
{
public:
	_trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration;	/* optional element of XSD type trt:AddVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2192; } /* = unique type id SOAP_TYPE___trt__AddVideoAnalyticsConfiguration */
	         __trt__AddVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40886 */
#ifndef SOAP_TYPE___trt__AddMetadataConfiguration
#define SOAP_TYPE___trt__AddMetadataConfiguration (2196)
/* Operation wrapper: */
struct __trt__AddMetadataConfiguration
{
public:
	_trt__AddMetadataConfiguration *trt__AddMetadataConfiguration;	/* optional element of XSD type trt:AddMetadataConfiguration */
public:
	int soap_type() const { return 2196; } /* = unique type id SOAP_TYPE___trt__AddMetadataConfiguration */
	         __trt__AddMetadataConfiguration();
	friend SOAP_FMAC1 __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40955 */
#ifndef SOAP_TYPE___trt__AddAudioOutputConfiguration
#define SOAP_TYPE___trt__AddAudioOutputConfiguration (2200)
/* Operation wrapper: */
struct __trt__AddAudioOutputConfiguration
{
public:
	_trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration;	/* optional element of XSD type trt:AddAudioOutputConfiguration */
public:
	int soap_type() const { return 2200; } /* = unique type id SOAP_TYPE___trt__AddAudioOutputConfiguration */
	         __trt__AddAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41024 */
#ifndef SOAP_TYPE___trt__AddAudioDecoderConfiguration
#define SOAP_TYPE___trt__AddAudioDecoderConfiguration (2204)
/* Operation wrapper: */
struct __trt__AddAudioDecoderConfiguration
{
public:
	_trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration;	/* optional element of XSD type trt:AddAudioDecoderConfiguration */
public:
	int soap_type() const { return 2204; } /* = unique type id SOAP_TYPE___trt__AddAudioDecoderConfiguration */
	         __trt__AddAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41094 */
#ifndef SOAP_TYPE___trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___trt__RemoveVideoEncoderConfiguration (2208)
/* Operation wrapper: */
struct __trt__RemoveVideoEncoderConfiguration
{
public:
	_trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration;	/* optional element of XSD type trt:RemoveVideoEncoderConfiguration */
public:
	int soap_type() const { return 2208; } /* = unique type id SOAP_TYPE___trt__RemoveVideoEncoderConfiguration */
	         __trt__RemoveVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41166 */
#ifndef SOAP_TYPE___trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE___trt__RemoveVideoSourceConfiguration (2212)
/* Operation wrapper: */
struct __trt__RemoveVideoSourceConfiguration
{
public:
	_trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration;	/* optional element of XSD type trt:RemoveVideoSourceConfiguration */
public:
	int soap_type() const { return 2212; } /* = unique type id SOAP_TYPE___trt__RemoveVideoSourceConfiguration */
	         __trt__RemoveVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41237 */
#ifndef SOAP_TYPE___trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioEncoderConfiguration (2216)
/* Operation wrapper: */
struct __trt__RemoveAudioEncoderConfiguration
{
public:
	_trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration;	/* optional element of XSD type trt:RemoveAudioEncoderConfiguration */
public:
	int soap_type() const { return 2216; } /* = unique type id SOAP_TYPE___trt__RemoveAudioEncoderConfiguration */
	         __trt__RemoveAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41310 */
#ifndef SOAP_TYPE___trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE___trt__RemoveAudioSourceConfiguration (2220)
/* Operation wrapper: */
struct __trt__RemoveAudioSourceConfiguration
{
public:
	_trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration;	/* optional element of XSD type trt:RemoveAudioSourceConfiguration */
public:
	int soap_type() const { return 2220; } /* = unique type id SOAP_TYPE___trt__RemoveAudioSourceConfiguration */
	         __trt__RemoveAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41380 */
#ifndef SOAP_TYPE___trt__RemovePTZConfiguration
#define SOAP_TYPE___trt__RemovePTZConfiguration (2224)
/* Operation wrapper: */
struct __trt__RemovePTZConfiguration
{
public:
	_trt__RemovePTZConfiguration *trt__RemovePTZConfiguration;	/* optional element of XSD type trt:RemovePTZConfiguration */
public:
	int soap_type() const { return 2224; } /* = unique type id SOAP_TYPE___trt__RemovePTZConfiguration */
	         __trt__RemovePTZConfiguration();
	friend SOAP_FMAC1 __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41450 */
#ifndef SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration (2228)
/* Operation wrapper: */
struct __trt__RemoveVideoAnalyticsConfiguration
{
public:
	_trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration;	/* optional element of XSD type trt:RemoveVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2228; } /* = unique type id SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration */
	         __trt__RemoveVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41519 */
#ifndef SOAP_TYPE___trt__RemoveMetadataConfiguration
#define SOAP_TYPE___trt__RemoveMetadataConfiguration (2232)
/* Operation wrapper: */
struct __trt__RemoveMetadataConfiguration
{
public:
	_trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration;	/* optional element of XSD type trt:RemoveMetadataConfiguration */
public:
	int soap_type() const { return 2232; } /* = unique type id SOAP_TYPE___trt__RemoveMetadataConfiguration */
	         __trt__RemoveMetadataConfiguration();
	friend SOAP_FMAC1 __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41588 */
#ifndef SOAP_TYPE___trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE___trt__RemoveAudioOutputConfiguration (2236)
/* Operation wrapper: */
struct __trt__RemoveAudioOutputConfiguration
{
public:
	_trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration;	/* optional element of XSD type trt:RemoveAudioOutputConfiguration */
public:
	int soap_type() const { return 2236; } /* = unique type id SOAP_TYPE___trt__RemoveAudioOutputConfiguration */
	         __trt__RemoveAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41657 */
#ifndef SOAP_TYPE___trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioDecoderConfiguration (2240)
/* Operation wrapper: */
struct __trt__RemoveAudioDecoderConfiguration
{
public:
	_trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration;	/* optional element of XSD type trt:RemoveAudioDecoderConfiguration */
public:
	int soap_type() const { return 2240; } /* = unique type id SOAP_TYPE___trt__RemoveAudioDecoderConfiguration */
	         __trt__RemoveAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41725 */
#ifndef SOAP_TYPE___trt__DeleteProfile
#define SOAP_TYPE___trt__DeleteProfile (2244)
/* Operation wrapper: */
struct __trt__DeleteProfile
{
public:
	_trt__DeleteProfile *trt__DeleteProfile;	/* optional element of XSD type trt:DeleteProfile */
public:
	int soap_type() const { return 2244; } /* = unique type id SOAP_TYPE___trt__DeleteProfile */
	         __trt__DeleteProfile();
	friend SOAP_FMAC1 __trt__DeleteProfile * SOAP_FMAC2 soap_instantiate___trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41794 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurations
#define SOAP_TYPE___trt__GetVideoSourceConfigurations (2248)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurations
{
public:
	_trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations;	/* optional element of XSD type trt:GetVideoSourceConfigurations */
public:
	int soap_type() const { return 2248; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurations */
	         __trt__GetVideoSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41864 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetVideoEncoderConfigurations (2252)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurations
{
public:
	_trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations;	/* optional element of XSD type trt:GetVideoEncoderConfigurations */
public:
	int soap_type() const { return 2252; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurations */
	         __trt__GetVideoEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41934 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurations
#define SOAP_TYPE___trt__GetAudioSourceConfigurations (2256)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurations
{
public:
	_trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations;	/* optional element of XSD type trt:GetAudioSourceConfigurations */
public:
	int soap_type() const { return 2256; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurations */
	         __trt__GetAudioSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42003 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetAudioEncoderConfigurations (2260)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurations
{
public:
	_trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations;	/* optional element of XSD type trt:GetAudioEncoderConfigurations */
public:
	int soap_type() const { return 2260; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurations */
	         __trt__GetAudioEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42072 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetVideoAnalyticsConfigurations (2264)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfigurations
{
public:
	_trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 2264; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfigurations */
	         __trt__GetVideoAnalyticsConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42140 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurations
#define SOAP_TYPE___trt__GetMetadataConfigurations (2268)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurations
{
public:
	_trt__GetMetadataConfigurations *trt__GetMetadataConfigurations;	/* optional element of XSD type trt:GetMetadataConfigurations */
public:
	int soap_type() const { return 2268; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurations */
	         __trt__GetMetadataConfigurations();
	friend SOAP_FMAC1 __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42208 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurations
#define SOAP_TYPE___trt__GetAudioOutputConfigurations (2272)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurations
{
public:
	_trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations;	/* optional element of XSD type trt:GetAudioOutputConfigurations */
public:
	int soap_type() const { return 2272; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurations */
	         __trt__GetAudioOutputConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42278 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetAudioDecoderConfigurations (2276)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurations
{
public:
	_trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations;	/* optional element of XSD type trt:GetAudioDecoderConfigurations */
public:
	int soap_type() const { return 2276; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurations */
	         __trt__GetAudioDecoderConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42346 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfiguration
#define SOAP_TYPE___trt__GetVideoSourceConfiguration (2280)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfiguration
{
public:
	_trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration;	/* optional element of XSD type trt:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 2280; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfiguration */
	         __trt__GetVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42414 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfiguration
#define SOAP_TYPE___trt__GetVideoEncoderConfiguration (2284)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfiguration
{
public:
	_trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration;	/* optional element of XSD type trt:GetVideoEncoderConfiguration */
public:
	int soap_type() const { return 2284; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfiguration */
	         __trt__GetVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42482 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfiguration
#define SOAP_TYPE___trt__GetAudioSourceConfiguration (2288)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfiguration
{
public:
	_trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration;	/* optional element of XSD type trt:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 2288; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfiguration */
	         __trt__GetAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42550 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfiguration
#define SOAP_TYPE___trt__GetAudioEncoderConfiguration (2292)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfiguration
{
public:
	_trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration;	/* optional element of XSD type trt:GetAudioEncoderConfiguration */
public:
	int soap_type() const { return 2292; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfiguration */
	         __trt__GetAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42618 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__GetVideoAnalyticsConfiguration (2296)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfiguration
{
public:
	_trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:GetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2296; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfiguration */
	         __trt__GetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42686 */
#ifndef SOAP_TYPE___trt__GetMetadataConfiguration
#define SOAP_TYPE___trt__GetMetadataConfiguration (2300)
/* Operation wrapper: */
struct __trt__GetMetadataConfiguration
{
public:
	_trt__GetMetadataConfiguration *trt__GetMetadataConfiguration;	/* optional element of XSD type trt:GetMetadataConfiguration */
public:
	int soap_type() const { return 2300; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfiguration */
	         __trt__GetMetadataConfiguration();
	friend SOAP_FMAC1 __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42754 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfiguration
#define SOAP_TYPE___trt__GetAudioOutputConfiguration (2304)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfiguration
{
public:
	_trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration;	/* optional element of XSD type trt:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 2304; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfiguration */
	         __trt__GetAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42822 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfiguration
#define SOAP_TYPE___trt__GetAudioDecoderConfiguration (2308)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfiguration
{
public:
	_trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration;	/* optional element of XSD type trt:GetAudioDecoderConfiguration */
public:
	int soap_type() const { return 2308; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfiguration */
	         __trt__GetAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42893 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations (2312)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoEncoderConfigurations
{
public:
	_trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoEncoderConfigurations */
public:
	int soap_type() const { return 2312; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations */
	         __trt__GetCompatibleVideoEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42966 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations (2316)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoSourceConfigurations
{
public:
	_trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoSourceConfigurations */
public:
	int soap_type() const { return 2316; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations */
	         __trt__GetCompatibleVideoSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43037 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations (2320)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioEncoderConfigurations
{
public:
	_trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioEncoderConfigurations */
public:
	int soap_type() const { return 2320; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations */
	         __trt__GetCompatibleAudioEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43108 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations (2324)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioSourceConfigurations
{
public:
	_trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioSourceConfigurations */
public:
	int soap_type() const { return 2324; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations */
	         __trt__GetCompatibleAudioSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43179 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations (2328)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	_trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 2328; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations */
	         __trt__GetCompatibleVideoAnalyticsConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43250 */
#ifndef SOAP_TYPE___trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___trt__GetCompatibleMetadataConfigurations (2332)
/* Operation wrapper: */
struct __trt__GetCompatibleMetadataConfigurations
{
public:
	_trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations;	/* optional element of XSD type trt:GetCompatibleMetadataConfigurations */
public:
	int soap_type() const { return 2332; } /* = unique type id SOAP_TYPE___trt__GetCompatibleMetadataConfigurations */
	         __trt__GetCompatibleMetadataConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43320 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations (2336)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioOutputConfigurations
{
public:
	_trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioOutputConfigurations */
public:
	int soap_type() const { return 2336; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations */
	         __trt__GetCompatibleAudioOutputConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43390 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations (2340)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioDecoderConfigurations
{
public:
	_trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioDecoderConfigurations */
public:
	int soap_type() const { return 2340; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations */
	         __trt__GetCompatibleAudioDecoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43462 */
#ifndef SOAP_TYPE___trt__SetVideoSourceConfiguration
#define SOAP_TYPE___trt__SetVideoSourceConfiguration (2344)
/* Operation wrapper: */
struct __trt__SetVideoSourceConfiguration
{
public:
	_trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration;	/* optional element of XSD type trt:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 2344; } /* = unique type id SOAP_TYPE___trt__SetVideoSourceConfiguration */
	         __trt__SetVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43535 */
#ifndef SOAP_TYPE___trt__SetVideoEncoderConfiguration
#define SOAP_TYPE___trt__SetVideoEncoderConfiguration (2348)
/* Operation wrapper: */
struct __trt__SetVideoEncoderConfiguration
{
public:
	_trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration;	/* optional element of XSD type trt:SetVideoEncoderConfiguration */
public:
	int soap_type() const { return 2348; } /* = unique type id SOAP_TYPE___trt__SetVideoEncoderConfiguration */
	         __trt__SetVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43609 */
#ifndef SOAP_TYPE___trt__SetAudioSourceConfiguration
#define SOAP_TYPE___trt__SetAudioSourceConfiguration (2352)
/* Operation wrapper: */
struct __trt__SetAudioSourceConfiguration
{
public:
	_trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration;	/* optional element of XSD type trt:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 2352; } /* = unique type id SOAP_TYPE___trt__SetAudioSourceConfiguration */
	         __trt__SetAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43684 */
#ifndef SOAP_TYPE___trt__SetAudioEncoderConfiguration
#define SOAP_TYPE___trt__SetAudioEncoderConfiguration (2356)
/* Operation wrapper: */
struct __trt__SetAudioEncoderConfiguration
{
public:
	_trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration;	/* optional element of XSD type trt:SetAudioEncoderConfiguration */
public:
	int soap_type() const { return 2356; } /* = unique type id SOAP_TYPE___trt__SetAudioEncoderConfiguration */
	         __trt__SetAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43761 */
#ifndef SOAP_TYPE___trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__SetVideoAnalyticsConfiguration (2360)
/* Operation wrapper: */
struct __trt__SetVideoAnalyticsConfiguration
{
public:
	_trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:SetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2360; } /* = unique type id SOAP_TYPE___trt__SetVideoAnalyticsConfiguration */
	         __trt__SetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43837 */
#ifndef SOAP_TYPE___trt__SetMetadataConfiguration
#define SOAP_TYPE___trt__SetMetadataConfiguration (2364)
/* Operation wrapper: */
struct __trt__SetMetadataConfiguration
{
public:
	_trt__SetMetadataConfiguration *trt__SetMetadataConfiguration;	/* optional element of XSD type trt:SetMetadataConfiguration */
public:
	int soap_type() const { return 2364; } /* = unique type id SOAP_TYPE___trt__SetMetadataConfiguration */
	         __trt__SetMetadataConfiguration();
	friend SOAP_FMAC1 __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43906 */
#ifndef SOAP_TYPE___trt__SetAudioOutputConfiguration
#define SOAP_TYPE___trt__SetAudioOutputConfiguration (2368)
/* Operation wrapper: */
struct __trt__SetAudioOutputConfiguration
{
public:
	_trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration;	/* optional element of XSD type trt:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 2368; } /* = unique type id SOAP_TYPE___trt__SetAudioOutputConfiguration */
	         __trt__SetAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43975 */
#ifndef SOAP_TYPE___trt__SetAudioDecoderConfiguration
#define SOAP_TYPE___trt__SetAudioDecoderConfiguration (2372)
/* Operation wrapper: */
struct __trt__SetAudioDecoderConfiguration
{
public:
	_trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration;	/* optional element of XSD type trt:SetAudioDecoderConfiguration */
public:
	int soap_type() const { return 2372; } /* = unique type id SOAP_TYPE___trt__SetAudioDecoderConfiguration */
	         __trt__SetAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44048 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___trt__GetVideoSourceConfigurationOptions (2376)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurationOptions
{
public:
	_trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions;	/* optional element of XSD type trt:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 2376; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurationOptions */
	         __trt__GetVideoSourceConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44118 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions (2380)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurationOptions
{
public:
	_trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions;	/* optional element of XSD type trt:GetVideoEncoderConfigurationOptions */
public:
	int soap_type() const { return 2380; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions */
	         __trt__GetVideoEncoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44191 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___trt__GetAudioSourceConfigurationOptions (2384)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurationOptions
{
public:
	_trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions;	/* optional element of XSD type trt:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 2384; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurationOptions */
	         __trt__GetAudioSourceConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44260 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions (2388)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurationOptions
{
public:
	_trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioEncoderConfigurationOptions */
public:
	int soap_type() const { return 2388; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions */
	         __trt__GetAudioEncoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44328 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurationOptions
#define SOAP_TYPE___trt__GetMetadataConfigurationOptions (2392)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurationOptions
{
public:
	_trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions;	/* optional element of XSD type trt:GetMetadataConfigurationOptions */
public:
	int soap_type() const { return 2392; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurationOptions */
	         __trt__GetMetadataConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44396 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___trt__GetAudioOutputConfigurationOptions (2396)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurationOptions
{
public:
	_trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions;	/* optional element of XSD type trt:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 2396; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurationOptions */
	         __trt__GetAudioOutputConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44465 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions (2400)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurationOptions
{
public:
	_trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioDecoderConfigurationOptions */
public:
	int soap_type() const { return 2400; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions */
	         __trt__GetAudioDecoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44534 */
#ifndef SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances (2404)
/* Operation wrapper: */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	_trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* optional element of XSD type trt:GetGuaranteedNumberOfVideoEncoderInstances */
public:
	int soap_type() const { return 2404; } /* = unique type id SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances */
	         __trt__GetGuaranteedNumberOfVideoEncoderInstances();
	friend SOAP_FMAC1 __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44607 */
#ifndef SOAP_TYPE___trt__GetStreamUri
#define SOAP_TYPE___trt__GetStreamUri (2408)
/* Operation wrapper: */
struct __trt__GetStreamUri
{
public:
	_trt__GetStreamUri *trt__GetStreamUri;	/* optional element of XSD type trt:GetStreamUri */
public:
	int soap_type() const { return 2408; } /* = unique type id SOAP_TYPE___trt__GetStreamUri */
	         __trt__GetStreamUri();
	friend SOAP_FMAC1 __trt__GetStreamUri * SOAP_FMAC2 soap_instantiate___trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44681 */
#ifndef SOAP_TYPE___trt__StartMulticastStreaming
#define SOAP_TYPE___trt__StartMulticastStreaming (2412)
/* Operation wrapper: */
struct __trt__StartMulticastStreaming
{
public:
	_trt__StartMulticastStreaming *trt__StartMulticastStreaming;	/* optional element of XSD type trt:StartMulticastStreaming */
public:
	int soap_type() const { return 2412; } /* = unique type id SOAP_TYPE___trt__StartMulticastStreaming */
	         __trt__StartMulticastStreaming();
	friend SOAP_FMAC1 __trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44748 */
#ifndef SOAP_TYPE___trt__StopMulticastStreaming
#define SOAP_TYPE___trt__StopMulticastStreaming (2416)
/* Operation wrapper: */
struct __trt__StopMulticastStreaming
{
public:
	_trt__StopMulticastStreaming *trt__StopMulticastStreaming;	/* optional element of XSD type trt:StopMulticastStreaming */
public:
	int soap_type() const { return 2416; } /* = unique type id SOAP_TYPE___trt__StopMulticastStreaming */
	         __trt__StopMulticastStreaming();
	friend SOAP_FMAC1 __trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44832 */
#ifndef SOAP_TYPE___trt__SetSynchronizationPoint
#define SOAP_TYPE___trt__SetSynchronizationPoint (2420)
/* Operation wrapper: */
struct __trt__SetSynchronizationPoint
{
public:
	_trt__SetSynchronizationPoint *trt__SetSynchronizationPoint;	/* optional element of XSD type trt:SetSynchronizationPoint */
public:
	int soap_type() const { return 2420; } /* = unique type id SOAP_TYPE___trt__SetSynchronizationPoint */
	         __trt__SetSynchronizationPoint();
	friend SOAP_FMAC1 __trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44909 */
#ifndef SOAP_TYPE___trt__GetSnapshotUri
#define SOAP_TYPE___trt__GetSnapshotUri (2424)
/* Operation wrapper: */
struct __trt__GetSnapshotUri
{
public:
	_trt__GetSnapshotUri *trt__GetSnapshotUri;	/* optional element of XSD type trt:GetSnapshotUri */
public:
	int soap_type() const { return 2424; } /* = unique type id SOAP_TYPE___trt__GetSnapshotUri */
	         __trt__GetSnapshotUri();
	friend SOAP_FMAC1 __trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44978 */
#ifndef SOAP_TYPE___trt__GetVideoSourceModes
#define SOAP_TYPE___trt__GetVideoSourceModes (2428)
/* Operation wrapper: */
struct __trt__GetVideoSourceModes
{
public:
	_trt__GetVideoSourceModes *trt__GetVideoSourceModes;	/* optional element of XSD type trt:GetVideoSourceModes */
public:
	int soap_type() const { return 2428; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceModes */
	         __trt__GetVideoSourceModes();
	friend SOAP_FMAC1 __trt__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45048 */
#ifndef SOAP_TYPE___trt__SetVideoSourceMode
#define SOAP_TYPE___trt__SetVideoSourceMode (2432)
/* Operation wrapper: */
struct __trt__SetVideoSourceMode
{
public:
	_trt__SetVideoSourceMode *trt__SetVideoSourceMode;	/* optional element of XSD type trt:SetVideoSourceMode */
public:
	int soap_type() const { return 2432; } /* = unique type id SOAP_TYPE___trt__SetVideoSourceMode */
	         __trt__SetVideoSourceMode();
	friend SOAP_FMAC1 __trt__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45115 */
#ifndef SOAP_TYPE___trt__GetOSDs
#define SOAP_TYPE___trt__GetOSDs (2436)
/* Operation wrapper: */
struct __trt__GetOSDs
{
public:
	_trt__GetOSDs *trt__GetOSDs;	/* optional element of XSD type trt:GetOSDs */
public:
	int soap_type() const { return 2436; } /* = unique type id SOAP_TYPE___trt__GetOSDs */
	         __trt__GetOSDs();
	friend SOAP_FMAC1 __trt__GetOSDs * SOAP_FMAC2 soap_instantiate___trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45182 */
#ifndef SOAP_TYPE___trt__GetOSD
#define SOAP_TYPE___trt__GetOSD (2440)
/* Operation wrapper: */
struct __trt__GetOSD
{
public:
	_trt__GetOSD *trt__GetOSD;	/* optional element of XSD type trt:GetOSD */
public:
	int soap_type() const { return 2440; } /* = unique type id SOAP_TYPE___trt__GetOSD */
	         __trt__GetOSD();
	friend SOAP_FMAC1 __trt__GetOSD * SOAP_FMAC2 soap_instantiate___trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45249 */
#ifndef SOAP_TYPE___trt__GetOSDOptions
#define SOAP_TYPE___trt__GetOSDOptions (2444)
/* Operation wrapper: */
struct __trt__GetOSDOptions
{
public:
	_trt__GetOSDOptions *trt__GetOSDOptions;	/* optional element of XSD type trt:GetOSDOptions */
public:
	int soap_type() const { return 2444; } /* = unique type id SOAP_TYPE___trt__GetOSDOptions */
	         __trt__GetOSDOptions();
	friend SOAP_FMAC1 __trt__GetOSDOptions * SOAP_FMAC2 soap_instantiate___trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45316 */
#ifndef SOAP_TYPE___trt__SetOSD
#define SOAP_TYPE___trt__SetOSD (2448)
/* Operation wrapper: */
struct __trt__SetOSD
{
public:
	_trt__SetOSD *trt__SetOSD;	/* optional element of XSD type trt:SetOSD */
public:
	int soap_type() const { return 2448; } /* = unique type id SOAP_TYPE___trt__SetOSD */
	         __trt__SetOSD();
	friend SOAP_FMAC1 __trt__SetOSD * SOAP_FMAC2 soap_instantiate___trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45383 */
#ifndef SOAP_TYPE___trt__CreateOSD
#define SOAP_TYPE___trt__CreateOSD (2452)
/* Operation wrapper: */
struct __trt__CreateOSD
{
public:
	_trt__CreateOSD *trt__CreateOSD;	/* optional element of XSD type trt:CreateOSD */
public:
	int soap_type() const { return 2452; } /* = unique type id SOAP_TYPE___trt__CreateOSD */
	         __trt__CreateOSD();
	friend SOAP_FMAC1 __trt__CreateOSD * SOAP_FMAC2 soap_instantiate___trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45450 */
#ifndef SOAP_TYPE___trt__DeleteOSD
#define SOAP_TYPE___trt__DeleteOSD (2456)
/* Operation wrapper: */
struct __trt__DeleteOSD
{
public:
	_trt__DeleteOSD *trt__DeleteOSD;	/* optional element of XSD type trt:DeleteOSD */
public:
	int soap_type() const { return 2456; } /* = unique type id SOAP_TYPE___trt__DeleteOSD */
	         __trt__DeleteOSD();
	friend SOAP_FMAC1 __trt__DeleteOSD * SOAP_FMAC2 soap_instantiate___trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* wsu.h:65 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* wsu.h:65 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* ds.h:51 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (28)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:77 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (36)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:91 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (43)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (81)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* wsa.h:220 */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (113)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

/* wsa.h:223 */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (114)
typedef char *_wsa__MessageID;
#endif

/* wsa.h:226 */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (115)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

/* wsa.h:229 */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (116)
typedef char *_wsa__To;
#endif

/* wsa.h:232 */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (117)
typedef char *_wsa__Action;
#endif

/* wsa.h:235 */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (118)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

/* wsa.h:238 */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (119)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

/* wsa.h:241 */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (120)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

/* wsa.h:244 */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (122)
typedef unsigned int _wsa__ReplyAfter;
#endif

/* wsdd10.h:101 */
#ifndef SOAP_TYPE_wsdd__QNameListType
#define SOAP_TYPE_wsdd__QNameListType (148)
typedef _QName wsdd__QNameListType;
#endif

/* wsdd10.h:104 */
#ifndef SOAP_TYPE_wsdd__UriListType
#define SOAP_TYPE_wsdd__UriListType (149)
typedef char *wsdd__UriListType;
#endif

/* wsdd10.h:107 */
#ifndef SOAP_TYPE_wsdd__FaultCodeOpenType
#define SOAP_TYPE_wsdd__FaultCodeOpenType (150)
typedef char *wsdd__FaultCodeOpenType;
#endif

/* wsa5.h:87 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (184)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:90 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (185)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:209 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (190)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:212 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (191)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:215 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (192)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:218 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (193)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:221 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (194)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:224 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (195)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:227 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (196)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:230 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (197)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:233 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (198)
typedef char *_wsa5__To;
#endif

/* wsa5.h:236 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (199)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:239 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (200)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:242 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (201)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:245 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (202)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:248 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (203)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* onvif.h:191 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (223)
typedef char *xsd__NCName;
#endif

/* onvif.h:194 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (224)
typedef char *xsd__anySimpleType;
#endif

/* onvif.h:197 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (225)
typedef char *xsd__anyURI;
#endif

/* onvif.h:200 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (226)
typedef char *xsd__integer;
#endif

/* onvif.h:203 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (227)
typedef char *xsd__nonNegativeInteger;
#endif

/* onvif.h:206 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (228)
typedef char *xsd__token;
#endif

/* onvif.h:210 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (229)
typedef char *_xml__lang;
#endif

/* onvif.h:2845 */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (1099)
typedef char *tds__EAPMethodTypes;
#endif

/* onvif.h:2857 */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (1100)
typedef char *tt__IntAttrList;
#endif

/* onvif.h:2861 */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (1101)
typedef char *tt__FloatAttrList;
#endif

/* onvif.h:2865 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (1102)
typedef char *tt__StringAttrList;
#endif

/* onvif.h:2869 */
#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (1103)
typedef char *tt__ReferenceTokenList;
#endif

/* onvif.h:2880 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (1104)
typedef char *wsnt__AbsoluteOrRelativeTimeType;
#endif

/* onvif.h:2911 */
#ifndef SOAP_TYPE_trt__EncodingTypes
#define SOAP_TYPE_trt__EncodingTypes (1105)
typedef char *trt__EncodingTypes;
#endif

/* onvif.h:2969 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (1108)
typedef char *tt__Name;
#endif

/* onvif.h:3189 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (1125)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* onvif.h:3205 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (1127)
typedef int tt__IANA_IfTypes;
#endif

/* onvif.h:3240 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (1131)
typedef xsd__token tt__IPv4Address;
#endif

/* onvif.h:3244 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (1132)
typedef xsd__token tt__IPv6Address;
#endif

/* onvif.h:3248 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (1133)
typedef xsd__token tt__HwAddress;
#endif

/* onvif.h:3261 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (1135)
typedef xsd__token tt__DNSName;
#endif

/* onvif.h:3265 */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (1136)
typedef xsd__token tt__Domain;
#endif

/* onvif.h:3289 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (1139)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* onvif.h:3327 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (1143)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* onvif.h:3332 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (1144)
typedef char *tt__Dot11PSKPassphrase;
#endif

/* onvif.h:3495 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (1158)
typedef char *tt__AuxiliaryData;
#endif

/* onvif.h:3655 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (1174)
typedef xsd__anyURI tt__TopicNamespaceLocation;
#endif

/* onvif.h:3731 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (1179)
typedef char *tt__Description;
#endif

/* onvif.h:3735 */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (1180)
typedef char *tt__XPathExpression;
#endif

/* onvif.h:3792 */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (1184)
typedef char *tt__RecordingJobMode;
#endif

/* onvif.h:3796 */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (1185)
typedef char *tt__RecordingJobState;
#endif

/* onvif.h:3817 */
#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (1187)
typedef char *tt__AudioClassType;
#endif

/* onvif.h:3837 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (1189)
typedef char *tt__ReferenceToken;
#endif

/* onvif.h:3889 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (1192)
typedef char *wstop__FullTopicExpression;
#endif

/* onvif.h:3898 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1193)
typedef char *wstop__ConcreteTopicExpression;
#endif

/* onvif.h:3906 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (1194)
typedef _QName wstop__SimpleTopicExpression;
#endif

/* onvif.h:3918 */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (1195)
typedef tt__ReferenceToken tt__ReceiverReference;
#endif

/* onvif.h:3922 */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (1196)
typedef tt__ReferenceToken tt__RecordingReference;
#endif

/* onvif.h:3926 */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (1197)
typedef tt__ReferenceToken tt__TrackReference;
#endif

/* onvif.h:3930 */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (1198)
typedef tt__ReferenceToken tt__JobToken;
#endif

/* onvif.h:3934 */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (1199)
typedef tt__ReferenceToken tt__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_send_SOAP_ENV__Fault(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *_param_1);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__HelloType *wsdd__Hello);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *_param_2);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Bye(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ByeType *wsdd__Bye);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *_param_3);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Probe(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeType *wsdd__Probe);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *_param_4);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__ProbeMatches(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeMatchesType *wsdd__ProbeMatches);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *_param_5);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Resolve(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ResolveType *wsdd__Resolve);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *_param_6);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__ResolveMatches(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ResolveMatchesType *wsdd__ResolveMatches);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *_param_7);


SOAP_FMAC5 int SOAP_FMAC6 soap_send_SOAP_ENV__Fault_alex(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv_SOAP_ENV__Fault_alex(struct soap *soap, struct SOAP_ENV__Fault_alex *_param_8);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__HelloType tdn__Hello, struct wsdd__ResolveType &tdn__HelloResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Bye(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ByeType tdn__Bye, struct wsdd__ResolveType &tdn__ByeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Probe(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeType tdn__Probe, struct wsdd__ProbeMatchesType &tdn__ProbeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetServices(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetServices *tds__GetServices, _tds__GetServicesResponse &tds__GetServicesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetServiceCapabilities *tds__GetServiceCapabilities, _tds__GetServiceCapabilitiesResponse &tds__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDeviceInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDeviceInformation *tds__GetDeviceInformation, _tds__GetDeviceInformationResponse &tds__GetDeviceInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, _tds__SetSystemDateAndTimeResponse &tds__SetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, _tds__GetSystemDateAndTimeResponse &tds__GetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemFactoryDefault(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, _tds__SetSystemFactoryDefaultResponse &tds__SetSystemFactoryDefaultResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__UpgradeSystemFirmware(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, _tds__UpgradeSystemFirmwareResponse &tds__UpgradeSystemFirmwareResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SystemReboot(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SystemReboot *tds__SystemReboot, _tds__SystemRebootResponse &tds__SystemRebootResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RestoreSystem(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RestoreSystem *tds__RestoreSystem, _tds__RestoreSystemResponse &tds__RestoreSystemResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemBackup(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemBackup *tds__GetSystemBackup, _tds__GetSystemBackupResponse &tds__GetSystemBackupResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemLog(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemLog *tds__GetSystemLog, _tds__GetSystemLogResponse &tds__GetSystemLogResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemSupportInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, _tds__GetSystemSupportInformationResponse &tds__GetSystemSupportInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetScopes *tds__GetScopes, _tds__GetScopesResponse &tds__GetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetScopes *tds__SetScopes, _tds__SetScopesResponse &tds__SetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddScopes *tds__AddScopes, _tds__AddScopesResponse &tds__AddScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveScopes *tds__RemoveScopes, _tds__RemoveScopesResponse &tds__RemoveScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDiscoveryMode *tds__GetDiscoveryMode, _tds__GetDiscoveryModeResponse &tds__GetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDiscoveryMode *tds__SetDiscoveryMode, _tds__SetDiscoveryModeResponse &tds__SetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, _tds__GetRemoteDiscoveryModeResponse &tds__GetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, _tds__SetRemoteDiscoveryModeResponse &tds__SetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDPAddresses *tds__GetDPAddresses, _tds__GetDPAddressesResponse &tds__GetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetEndpointReference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetEndpointReference *tds__GetEndpointReference, _tds__GetEndpointReferenceResponse &tds__GetEndpointReferenceResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRemoteUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRemoteUser *tds__GetRemoteUser, _tds__GetRemoteUserResponse &tds__GetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRemoteUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRemoteUser *tds__SetRemoteUser, _tds__SetRemoteUserResponse &tds__SetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetUsers *tds__GetUsers, _tds__GetUsersResponse &tds__GetUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateUsers *tds__CreateUsers, _tds__CreateUsersResponse &tds__CreateUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteUsers *tds__DeleteUsers, _tds__DeleteUsersResponse &tds__DeleteUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetUser *tds__SetUser, _tds__SetUserResponse &tds__SetUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetWsdlUrl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetWsdlUrl *tds__GetWsdlUrl, _tds__GetWsdlUrlResponse &tds__GetWsdlUrlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCapabilities *tds__GetCapabilities, _tds__GetCapabilitiesResponse &tds__GetCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDPAddresses *tds__SetDPAddresses, _tds__SetDPAddressesResponse &tds__SetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetHostname *tds__GetHostname, _tds__GetHostnameResponse &tds__GetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetHostname *tds__SetHostname, _tds__SetHostnameResponse &tds__SetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetHostnameFromDHCP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP, _tds__SetHostnameFromDHCPResponse &tds__SetHostnameFromDHCPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDNS *tds__GetDNS, _tds__GetDNSResponse &tds__GetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDNS *tds__SetDNS, _tds__SetDNSResponse &tds__SetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNTP *tds__GetNTP, _tds__GetNTPResponse &tds__GetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNTP *tds__SetNTP, _tds__SetNTPResponse &tds__SetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDynamicDNS *tds__GetDynamicDNS, _tds__GetDynamicDNSResponse &tds__GetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDynamicDNS *tds__SetDynamicDNS, _tds__SetDynamicDNSResponse &tds__SetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, _tds__GetNetworkInterfacesResponse &tds__GetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, _tds__SetNetworkInterfacesResponse &tds__SetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkProtocols *tds__GetNetworkProtocols, _tds__GetNetworkProtocolsResponse &tds__GetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkProtocols *tds__SetNetworkProtocols, _tds__SetNetworkProtocolsResponse &tds__SetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, _tds__GetNetworkDefaultGatewayResponse &tds__GetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, _tds__SetNetworkDefaultGatewayResponse &tds__SetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetZeroConfiguration *tds__GetZeroConfiguration, _tds__GetZeroConfigurationResponse &tds__GetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetZeroConfiguration *tds__SetZeroConfiguration, _tds__SetZeroConfigurationResponse &tds__SetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetIPAddressFilter *tds__GetIPAddressFilter, _tds__GetIPAddressFilterResponse &tds__GetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetIPAddressFilter *tds__SetIPAddressFilter, _tds__SetIPAddressFilterResponse &tds__SetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddIPAddressFilter *tds__AddIPAddressFilter, _tds__AddIPAddressFilterResponse &tds__AddIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, _tds__RemoveIPAddressFilterResponse &tds__RemoveIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetAccessPolicy *tds__GetAccessPolicy, _tds__GetAccessPolicyResponse &tds__GetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetAccessPolicy *tds__SetAccessPolicy, _tds__SetAccessPolicyResponse &tds__SetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateCertificate(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateCertificate *tds__CreateCertificate, _tds__CreateCertificateResponse &tds__CreateCertificateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificates *tds__GetCertificates, _tds__GetCertificatesResponse &tds__GetCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificatesStatus *tds__GetCertificatesStatus, _tds__GetCertificatesStatusResponse &tds__GetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetCertificatesStatus *tds__SetCertificatesStatus, _tds__SetCertificatesStatusResponse &tds__SetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteCertificates *tds__DeleteCertificates, _tds__DeleteCertificatesResponse &tds__DeleteCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetPkcs10Request(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetPkcs10Request *tds__GetPkcs10Request, _tds__GetPkcs10RequestResponse &tds__GetPkcs10RequestResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCertificates *tds__LoadCertificates, _tds__LoadCertificatesResponse &tds__LoadCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetClientCertificateMode *tds__GetClientCertificateMode, _tds__GetClientCertificateModeResponse &tds__GetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetClientCertificateMode *tds__SetClientCertificateMode, _tds__SetClientCertificateModeResponse &tds__SetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRelayOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse &tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, _tds__SetRelayOutputSettingsResponse &tds__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse &tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SendAuxiliaryCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand, _tds__SendAuxiliaryCommandResponse &tds__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCACertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCACertificates *tds__GetCACertificates, _tds__GetCACertificatesResponse &tds__GetCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey, _tds__LoadCertificateWithPrivateKeyResponse &tds__LoadCertificateWithPrivateKeyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificateInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificateInformation *tds__GetCertificateInformation, _tds__GetCertificateInformationResponse &tds__GetCertificateInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCACertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCACertificates *tds__LoadCACertificates, _tds__LoadCACertificatesResponse &tds__LoadCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration, _tds__CreateDot1XConfigurationResponse &tds__CreateDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration, _tds__SetDot1XConfigurationResponse &tds__SetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration, _tds__GetDot1XConfigurationResponse &tds__GetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot1XConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations, _tds__GetDot1XConfigurationsResponse &tds__GetDot1XConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration, _tds__DeleteDot1XConfigurationResponse &tds__DeleteDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot11Capabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot11Capabilities *tds__GetDot11Capabilities, _tds__GetDot11CapabilitiesResponse &tds__GetDot11CapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot11Status(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot11Status *tds__GetDot11Status, _tds__GetDot11StatusResponse &tds__GetDot11StatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__ScanAvailableDot11Networks(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks, _tds__ScanAvailableDot11NetworksResponse &tds__ScanAvailableDot11NetworksResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemUris(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemUris *tds__GetSystemUris, _tds__GetSystemUrisResponse &tds__GetSystemUrisResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__StartFirmwareUpgrade(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade, _tds__StartFirmwareUpgradeResponse &tds__StartFirmwareUpgradeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__StartSystemRestore(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__StartSystemRestore *tds__StartSystemRestore, _tds__StartSystemRestoreResponse &tds__StartSystemRestoreResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetStorageConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetStorageConfigurations *tds__GetStorageConfigurations, _tds__GetStorageConfigurationsResponse &tds__GetStorageConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateStorageConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration, _tds__CreateStorageConfigurationResponse &tds__CreateStorageConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetStorageConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetStorageConfiguration *tds__GetStorageConfiguration, _tds__GetStorageConfigurationResponse &tds__GetStorageConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetStorageConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetStorageConfiguration *tds__SetStorageConfiguration, _tds__SetStorageConfigurationResponse &tds__SetStorageConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteStorageConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration, _tds__DeleteStorageConfigurationResponse &tds__DeleteStorageConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetGeoLocation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetGeoLocation *tds__GetGeoLocation, _tds__GetGeoLocationResponse &tds__GetGeoLocationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetGeoLocation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetGeoLocation *tds__SetGeoLocation, _tds__SetGeoLocationResponse &tds__SetGeoLocationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteGeoLocation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteGeoLocation *tds__DeleteGeoLocation, _tds__DeleteGeoLocationResponse &tds__DeleteGeoLocationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetServiceCapabilities *trt__GetServiceCapabilities, _trt__GetServiceCapabilitiesResponse &trt__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse &trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse &trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputs *trt__GetAudioOutputs, _trt__GetAudioOutputsResponse &trt__GetAudioOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__CreateProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__CreateProfile *trt__CreateProfile, _trt__CreateProfileResponse &trt__CreateProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfile *trt__GetProfile, _trt__GetProfileResponse &trt__GetProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfiles *trt__GetProfiles, _trt__GetProfilesResponse &trt__GetProfilesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, _trt__AddVideoEncoderConfigurationResponse &trt__AddVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, _trt__AddVideoSourceConfigurationResponse &trt__AddVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, _trt__AddAudioEncoderConfigurationResponse &trt__AddAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, _trt__AddAudioSourceConfigurationResponse &trt__AddAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddPTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddPTZConfiguration *trt__AddPTZConfiguration, _trt__AddPTZConfigurationResponse &trt__AddPTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, _trt__AddVideoAnalyticsConfigurationResponse &trt__AddVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, _trt__AddMetadataConfigurationResponse &trt__AddMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration, _trt__AddAudioOutputConfigurationResponse &trt__AddAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration, _trt__AddAudioDecoderConfigurationResponse &trt__AddAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, _trt__RemoveVideoEncoderConfigurationResponse &trt__RemoveVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, _trt__RemoveVideoSourceConfigurationResponse &trt__RemoveVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, _trt__RemoveAudioEncoderConfigurationResponse &trt__RemoveAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, _trt__RemoveAudioSourceConfigurationResponse &trt__RemoveAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemovePTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, _trt__RemovePTZConfigurationResponse &trt__RemovePTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, _trt__RemoveVideoAnalyticsConfigurationResponse &trt__RemoveVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, _trt__RemoveMetadataConfigurationResponse &trt__RemoveMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration, _trt__RemoveAudioOutputConfigurationResponse &trt__RemoveAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration, _trt__RemoveAudioDecoderConfigurationResponse &trt__RemoveAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__DeleteProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__DeleteProfile *trt__DeleteProfile, _trt__DeleteProfileResponse &trt__DeleteProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, _trt__GetVideoSourceConfigurationsResponse &trt__GetVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, _trt__GetVideoEncoderConfigurationsResponse &trt__GetVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, _trt__GetAudioSourceConfigurationsResponse &trt__GetAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, _trt__GetAudioEncoderConfigurationsResponse &trt__GetAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, _trt__GetVideoAnalyticsConfigurationsResponse &trt__GetVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, _trt__GetMetadataConfigurationsResponse &trt__GetMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations, _trt__GetAudioOutputConfigurationsResponse &trt__GetAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations, _trt__GetAudioDecoderConfigurationsResponse &trt__GetAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, _trt__GetVideoSourceConfigurationResponse &trt__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, _trt__GetVideoEncoderConfigurationResponse &trt__GetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, _trt__GetAudioSourceConfigurationResponse &trt__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, _trt__GetAudioEncoderConfigurationResponse &trt__GetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, _trt__GetVideoAnalyticsConfigurationResponse &trt__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, _trt__GetMetadataConfigurationResponse &trt__GetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration, _trt__GetAudioOutputConfigurationResponse &trt__GetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration, _trt__GetAudioDecoderConfigurationResponse &trt__GetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, _trt__GetCompatibleVideoEncoderConfigurationsResponse &trt__GetCompatibleVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, _trt__GetCompatibleVideoSourceConfigurationsResponse &trt__GetCompatibleVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, _trt__GetCompatibleAudioEncoderConfigurationsResponse &trt__GetCompatibleAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, _trt__GetCompatibleAudioSourceConfigurationsResponse &trt__GetCompatibleAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse &trt__GetCompatibleVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, _trt__GetCompatibleMetadataConfigurationsResponse &trt__GetCompatibleMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations, _trt__GetCompatibleAudioOutputConfigurationsResponse &trt__GetCompatibleAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations, _trt__GetCompatibleAudioDecoderConfigurationsResponse &trt__GetCompatibleAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, _trt__SetVideoSourceConfigurationResponse &trt__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, _trt__SetVideoEncoderConfigurationResponse &trt__SetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, _trt__SetAudioSourceConfigurationResponse &trt__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, _trt__SetAudioEncoderConfigurationResponse &trt__SetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, _trt__SetVideoAnalyticsConfigurationResponse &trt__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, _trt__SetMetadataConfigurationResponse &trt__SetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration, _trt__SetAudioOutputConfigurationResponse &trt__SetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration, _trt__SetAudioDecoderConfigurationResponse &trt__SetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, _trt__GetVideoSourceConfigurationOptionsResponse &trt__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, _trt__GetVideoEncoderConfigurationOptionsResponse &trt__GetVideoEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, _trt__GetAudioSourceConfigurationOptionsResponse &trt__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, _trt__GetAudioEncoderConfigurationOptionsResponse &trt__GetAudioEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, _trt__GetMetadataConfigurationOptionsResponse &trt__GetMetadataConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions, _trt__GetAudioOutputConfigurationOptionsResponse &trt__GetAudioOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions, _trt__GetAudioDecoderConfigurationOptionsResponse &trt__GetAudioDecoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse &trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetStreamUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetStreamUri *trt__GetStreamUri, _trt__GetStreamUriResponse &trt__GetStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StartMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StartMulticastStreaming *trt__StartMulticastStreaming, _trt__StartMulticastStreamingResponse &trt__StartMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StopMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StopMulticastStreaming *trt__StopMulticastStreaming, _trt__StopMulticastStreamingResponse &trt__StopMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetSynchronizationPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, _trt__SetSynchronizationPointResponse &trt__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetSnapshotUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetSnapshotUri *trt__GetSnapshotUri, _trt__GetSnapshotUriResponse &trt__GetSnapshotUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceModes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceModes *trt__GetVideoSourceModes, _trt__GetVideoSourceModesResponse &trt__GetVideoSourceModesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoSourceMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoSourceMode *trt__SetVideoSourceMode, _trt__SetVideoSourceModeResponse &trt__SetVideoSourceModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetOSDs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetOSDs *trt__GetOSDs, _trt__GetOSDsResponse &trt__GetOSDsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetOSD(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetOSD *trt__GetOSD, _trt__GetOSDResponse &trt__GetOSDResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetOSDOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetOSDOptions *trt__GetOSDOptions, _trt__GetOSDOptionsResponse &trt__GetOSDOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetOSD(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetOSD *trt__SetOSD, _trt__SetOSDResponse &trt__SetOSDResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__CreateOSD(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__CreateOSD *trt__CreateOSD, _trt__CreateOSDResponse &trt__CreateOSDResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__DeleteOSD(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__DeleteOSD *trt__DeleteOSD, _trt__DeleteOSDResponse &trt__DeleteOSDResponse);

#endif

/* End of soapStub.h */
